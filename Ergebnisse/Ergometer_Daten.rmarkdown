---
title: "Ergometrische Leistungsparameter"
format:
  html:
    resources: 
      - shinylive-sw.js
    fig-responsive: true
    
filters:
  - shinylive
    
bibliography: references.bib
lang: de
number-sections: false
editor: 
  markdown: 
    wrap: 72
    
lightbox:
  match: auto
  effect: fade
  desc-position: right
  loop: false
  css-class: "my-css-class"
  
execute: 
  message: false
  echo: false
  warning: false
  error: false
  freeze: true
  order: sequential
---

```{css}
#| echo: false
p {
  text-align: justify
}
caption, .figure-caption {
  text-align: left;
}
figure.quarto-float-tbl figcaption {
  text-align: left !important;
}

```

```{r}
# Library und dfs laden
library(plotly)
library(ggplot2)
library(dplyr)
library(tidyr)
library(htmltools)
library(htmlwidgets)
library(shiny)
library(DT)
library(RColorBrewer)
library(patchwork)
library(minpack.lm)
library(zoo)
library(purrr)
library(readxl)

EPOC_data_df <- readRDS("rds/EPOC_data_df.rds")
Erg_data_df <- readRDS("rds/Erg_data_df.rds")
Erg_data_komplett <- readRDS("rds/Erg_data_komplett.rds")
Messwerte_Bedingungen_df <- readRDS("rds/Messwerte_Bedingungen_df.rds")
Messwerte_Intensitäten_df <- readRDS("rds/Messwerte_Intensitäten_df.rds")
Messwerte_Bedingung_Intensität_df <- readRDS("rds/Messwerte_Bedingung_Intensität_df.rds")
Bedingungen_data <- readRDS("rds/Bedingungen_data.rds")
P_Ges_df <- readRDS("rds/Efficiency_Daten_df.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_Int_Drehzahl_Masse <- readRDS("rds/P_Int_Drehzahl_Masse.rds")
Simulation_df <- readRDS("rds/Simulation_df.rds")
ΔBLC_list <- readRDS("rds/BLC_list.rds")
proband_data <- readRDS("rds/proband_data.rds")
ΔBLC_data_df <- readRDS("rds/BLC_data_df.rds")
BLC_Modell_list <- readRDS("rds/BLC_Modell_list.rds")
Efficiency_Daten_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_R_list <- readRDS("rds/P_R_list.rds")
P_L_list <- readRDS("rds/P_L_list.rds")
start_vals_list <- readRDS("rds/start_vals_list.rds")
VO2_list <- readRDS("rds/VO2_list.rds")
df_anthropometrisch_female <- readRDS("rds/df_anthropometrisch_female.rds")
df_anthropometrisch_male <- readRDS("rds/df_anthropometrisch_male.rds")

Erg_data_komplett <- readRDS("C:/Users/johan/OneDrive/Desktop/SpoWi/WS 22,23/Masterarbeit - Wirkungsgrad/Wirkungsgrad-Rad.github.io/Ergebnisse/rds/Erg_data_komplett.rds")

# Anpassen des Wertes für Proband 13 unter den spezifischen Bedingungen
Erg_data_komplett$nD_Vorgabe[
  Erg_data_komplett$Proband == 13 & 
    Erg_data_komplett$Nr == 2 & 
    Erg_data_komplett$Intensität == "leicht" &
    Erg_data_komplett$nD_Vorgabe != 100
] <- 100

saveRDS(Erg_data_komplett, "C:/Users/johan/OneDrive/Desktop/SpoWi/WS 22,23/Masterarbeit - Wirkungsgrad/Daten/Probanden_Energieberechnung/xlsm/Erg_data_komplett.rds")
saveRDS(Erg_data_komplett, "C:/Users/johan/OneDrive/Desktop/SpoWi/WS 22,23/Masterarbeit - Wirkungsgrad/Wirkungsgrad-Rad.github.io/Ergebnisse/rds/Erg_data_komplett.rds")

Erg_data_komplett <- readRDS("C:/Users/johan/OneDrive/Desktop/SpoWi/WS 22,23/Masterarbeit - Wirkungsgrad/Wirkungsgrad-Rad.github.io/Ergebnisse/rds/Erg_data_komplett.rds")



# Erg_data_short erstellen
Erg_data_short <- Erg_data_komplett[, c("Proband", "Nr", "Bedingung", "Intensität",
                                       "nD_Vorgabe","nD", "P_mech_Vorgabe", "P_mech", 
                                       "W_kg", "Efficiency", "P_mean_abs", "P_max",
                                       "P_max_kg", "Pedal_Smoothness", "P_L_percent", 
                                       "P_R_percent", "PInt_Kinematik", "PInt_Modell",
                                       "PInt_Kinematik_Modell", "P_Int_Min", "Koerperlaenge",
                                       "Masse", "lBein", "lOS", "lUS", "uOS", "uUS",
                                       "lKurbel")]

names(Erg_data_short)[names(Erg_data_short) == "nD"] <- "nD [U·min⁻¹]"
names(Erg_data_short)[names(Erg_data_short) == "nD_Vorgabe"] <- "nD_Vorgabe [U·min⁻¹]"
names(Erg_data_short)[names(Erg_data_short) == "P_mech_Vorgabe"] <- "P_mech_Vorgabe [W]"
names(Erg_data_short)[names(Erg_data_short) == "P_mech"] <- "P_mech [W]"
names(Erg_data_short)[names(Erg_data_short) == "W_kg"] <- "P_mech_kg [W·kg⁻¹]"
names(Erg_data_short)[names(Erg_data_short) == "Efficiency"] <- "Torque Efficiency [%]"
names(Erg_data_short)[names(Erg_data_short) == "P_mean_abs"] <- "P_mech_abs [W]"
names(Erg_data_short)[names(Erg_data_short) == "P_max"] <- "P_max [W]"
names(Erg_data_short)[names(Erg_data_short) == "P_max_kg"] <- "P_max_kg [W·kg⁻¹]"
names(Erg_data_short)[names(Erg_data_short) == "Pedal_Smoothness"] <- "Pedal_Smoothness [%]"
names(Erg_data_short)[names(Erg_data_short) == "P_L_percent"] <- "P_L_percent [%]"
names(Erg_data_short)[names(Erg_data_short) == "P_R_percent"] <- "P_R_percent [%]"
names(Erg_data_short)[names(Erg_data_short) == "PInt_Kinematik"] <- "P_Int_Kinematik [W]"
names(Erg_data_short)[names(Erg_data_short) == "PInt_Modell"] <- "P_Int_Modell [W]"
names(Erg_data_short)[names(Erg_data_short) == "PInt_Kinematik_Modell"] <- "P_Int_Kinematik_Modell [W]"
names(Erg_data_short)[names(Erg_data_short) == "P_Int_Min"] <- "P_Int_Minetti [W]"
names(Erg_data_short)[names(Erg_data_short) == "Koerperlaenge"] <- "Koerperlaenge [m]"
names(Erg_data_short)[names(Erg_data_short) == "Masse"] <- "Masse [kg]"
names(Erg_data_short)[names(Erg_data_short) == "lBein"] <- "lBein [m]"
names(Erg_data_short)[names(Erg_data_short) == "lOS"] <- "lOS [m]"
names(Erg_data_short)[names(Erg_data_short) == "lUS"] <- "lUS [m]"
names(Erg_data_short)[names(Erg_data_short) == "uOS"] <- "uOS [m]"
names(Erg_data_short)[names(Erg_data_short) == "uUS"] <- "uUS [m]"
names(Erg_data_short)[names(Erg_data_short) == "lKurbel"] <- "lKurbel [m]"
```



# Interaktive Analyse der ergometrischen Leistungsparameter
Die folgende Shiny-App zeigt eine interaktive Tabellenübersicht der am Ergometer erfassten Parameter sämtlicher Belastungsdurchgänge. Die Shiny-App ermöglicht einen flexiblen Wechsel zwischen der Darstellung aller individuellen Testdurchläufe und einer zusammengefassten Übersicht mit Mittelwerten sowie zugehörigen Standardabweichungen. Die Filterfunktion erlaubt eine gezielte Analyse der Daten nach verschiedenen Kombinationen von Intensität (leicht, moderat, schwer) und Bedingung (sitzend, stehend). Für die gefilterten Daten werden sowohl die entsprechenden Mittelwerte als auch die zugehörigen Boxplots mit den statistischen Kennwerten (Mittelwert, Median, erstes Quartil, drittes Quartil, Minimum und Maximum) visualisiert. Zusätzlich besteht die Option, einzelne Probanden in die Analyse ein- oder auszuschließen.<br>
Die dargestellten Daten fungieren als zentrale Grundlage für alle weiteren Analysen der ergometrischen Leistungsparameter.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900

library(shiny)
library(shinylive)
library(DT)
library(dplyr)
library(plotly)

Erg_data_short <- data.frame(
  `Proband` = c( 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 13, 13, 13, 13, 13, 13, 15, 15, 15, 15, 15, 15, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23 ),
  `Nr` = c( 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6 ),
  `Bedingung` = c( "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen" ),
  `Intensität` = c( "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer" ),
  `nD_Vorgabe [U·min⁻¹]` = c( 77, 84, 84, 77, 84, 77, 59, 79, 59, 79, 59, 79, 62, 92, 92, 62, 62, 92, 76, 100, 76, 100, 100, 76, 95, 67, 95, 67, 67, 95, 83, 85, 85, 83, 85, 83, 88, 59, 59, 88, 59, 88, 85, 64, 64, 85, 85, 64, 75, 88, 88, 75, 75, 88 ),
  `nD [U·min⁻¹]` = c( 76.6564376505317, 86.4007340902643, 86.151834718222, 76.9699534010204, 86.1492001342774, 77.7545030427186, 59.6696464126312, 79.340733311971, 59.0120747230942, 78.6315332132975, 58.5778147794659, 74.8376014062797, 64.4031353722102, 93.4309539387749, 93.4798136132308, 64.6513676939208, 63.9226666971842, 92.926017486389, 76.1787191980119, 100.725884150632, 76.4965310227163, 100.706804663599, 101.493737868195, 76.2895930915614, 94.9222147345463, 67.3025317640006, 95.6908060743521, 67.7563334376017, 68.9089393183102, 97.2326216948995, 82.3157999725342, 85.1151334584554, 84.9867423386037, 82.4121919818754, 85.6636667989095, 82.5434000701904, 88.3525337219238, 59.2843333028158, 59.6458305272363, 87.9682001902262, 59.0753999888102, 88.6749836398094, 86.1743334757487, 65.9431711942811, 65.5106667200724, 86.0812543343512, 85.3489333648682, 66.2728181161696, 75.2098000386556, 87.7106668141683, 88.0529021962314, 75.7959332733154, 75.7891333821615, 88.2820788795832 ),
  `P_mech_Vorgabe [W]` = c( 290, 290, 320, 320, 350, 350, 280, 280, 305, 305, 325, 325, 325, 325, 380, 380, 410, 410, 305, 305, 335, 335, 360, 360, 270, 270, 305, 305, 330, 330, 225, 225, 245, 245, 275, 275, 250, 250, 280, 280, 315, 315, 230, 230, 260, 260, 280, 280, 185, 185, 210, 210, 235, 235 ),
  `P_mech [W]` = c( 286.196809943666, 279.856121744776, 308.058185037385, 316.422860962335, 340.826183919876, 347.288435475183, 277.240209227733, 271.455328132766, 304.467347747788, 298.231190808954, 325.412992360824, 309.694617397985, 323.150737156769, 316.844325140231, 371.96441826512, 380.655666884463, 411.774528793808, 405.478497575611, 300.611680063499, 294.276254054958, 330.974610194196, 323.263418911815, 347.877528040632, 356.523758791993, 264.042555125073, 264.046097801302, 296.595675684983, 312.821367725728, 338.374812212103, 340.655624979066, 222.299144497093, 217.725388710054, 237.149862110928, 238.510476030676, 268.299540676442, 270.26756043723, 259.609504812067, 246.984706949108, 281.340838183762, 276.152650787485, 316.924535968906, 309.069638160985, 220.907452101768, 221.311649982903, 250.936106797992, 254.071699215572, 274.36729230484, 276.737918099592, 175.467181480606, 173.18153762583, 199.048429239061, 199.114857295449, 224.703097248925, 224.226593365666 ),
  `P_mech_kg [W·kg⁻¹]` = c( 3.76574749925876, 3.68231739137862, 4.05339717154454, 4.16345869687283, 4.48455505157731, 4.56958467730504, 3.79781108531141, 3.71856613880502, 4.17078558558614, 4.08535877820485, 4.45771222412087, 4.24239201915048, 3.94086264825329, 3.86395518463696, 4.53615144225757, 4.64214227907881, 5.02164059504643, 4.94485972653184, 4.17516222310415, 4.08717019520774, 4.5968695860305, 4.48976970710854, 4.83163233389766, 4.95171887211102, 3.47424414638254, 3.47429076054345, 3.90257468006557, 4.11607062797011, 4.45230016068557, 4.48231085498771, 3.41998683841681, 3.34962136477006, 3.6484594170912, 3.66939193893347, 4.12768524117603, 4.15796246826507, 3.24511881015084, 3.08730883686386, 3.51676047729703, 3.45190813484356, 3.96155669961133, 3.86337047701231, 4.6022385854535, 4.61065937464381, 5.22783555829151, 5.29316040032442, 5.71598525635083, 5.7653732937415, 2.92445302467677, 2.88635896043051, 3.31747382065102, 3.31858095492415, 3.74505162081542, 3.73710988942776 ),
  `Torque Efficiency [%]` = c( 66.42, 80.67, 85.6, 72.95, 87.65, 78.67, 80.04, 86.41, 86.78, 88.63, 88.24, 92.41, 73.99, 73.77, 81.11, 85.39, 91.79, 84.47, 72.05, 72.34, 79.17, 76.95, 79.78, 85.17, 66.52, 69.93, 72.41, 82.58, 87.01, 79.53, 65.43, 72.54, 77.02, 70.47, 80.77, 78.76, 64.47, 62.05, 68.4, 71.35, 77.44, 75.1, 81.99, 82.22, 91.47, 89.76, 92.56, 97.11, 50.58, 59.59, 65.12, 56.31, 63.19, 72.06 ),
  `P_mech_abs [W]` = c( 430.898453269453, 346.932268431489, 359.894794521274, 433.727303347072, 388.867195271955, 441.471798101275, 346.379136378951, 314.139111107741, 350.86692910731, 336.501760889012, 368.792501882788, 335.122366938868, 436.74295487819, 429.476010923678, 458.572565130538, 445.785439492691, 448.616125076261, 480.02899009992, 417.254676419948, 406.786522182967, 418.029194795729, 420.068975285005, 436.036881620291, 418.609977742272, 396.931552233338, 377.562076360227, 409.578155842889, 378.797651732435, 388.906717354007, 428.323957484394, 339.738475124735, 300.163566795685, 307.893824314181, 338.470207382618, 332.172517017126, 343.174345545978, 402.65419504435, 398.061154186489, 411.292076398934, 387.025904346715, 409.236247070283, 411.542819605474, 269.447435024309, 269.166149547195, 274.335758746147, 283.051443499869, 296.406742555017, 284.967630696716, 346.914329776961, 290.644914064715, 305.65464771739, 353.590906241965, 355.615760249487, 311.181510014167 ),
  `P_max [W]` = c( 720.71392917246, 550.697854561856, 587.417097655553, 787.012012890423, 634.931737852808, 846.118844347542, 578.609811212814, 526.754221690469, 618.616237792837, 583.178213938422, 677.46839262409, 586.294927750192, 674.210503713599, 609.931100907041, 688.050026599798, 751.453351178328, 782.342779552722, 747.114860859711, 697.739178615104, 599.783453121439, 741.044102327642, 642.75054953451, 678.261118990867, 767.313623578198, 546.342710728637, 596.59219640589, 563.098821554568, 659.349421443241, 701.336341167984, 587.602874558339, 523.918403061563, 432.932490041913, 452.947736533387, 558.40548473631, 513.309499380782, 603.361877693434, 560.027085542369, 643.90077383047, 709.354344682915, 560.027686195494, 751.218524473997, 600.371875917469, 405.818662295843, 446.750025682425, 484.017990617248, 441.823569590808, 475.691772431568, 525.937225940098, 541.967355078066, 411.679083397134, 443.334425922299, 582.825995654505, 614.87764605695, 473.923630452372 ),
  `P_max_kg [W·kg⁻¹]` = c( 9.4830780154271, 7.24602440212969, 7.72917233757307, 10.3554212222424, 8.35436497174747, 11.1331426887834, 7.92616179743581, 7.21581125603382, 8.47419503825805, 7.98874265669071, 9.28038894005602, 8.03143736644098, 8.22207931358047, 7.43818415740294, 8.39085398292436, 9.1640652582723, 9.54076560430149, 9.11115683975258, 9.69082192520977, 8.33032573779776, 10.292279198995, 8.92709096575709, 9.4202933193176, 10.6571336608083, 7.18871987800839, 7.84989732113013, 7.40919502045484, 8.6756502821479, 9.22810975221031, 7.73161677050446, 8.06028312402404, 6.66049984679866, 6.96842671589827, 8.59085361132785, 7.8970692212428, 9.28249042605283, 7.00033856927961, 8.04875967288088, 8.86692930853643, 7.00034607744368, 9.39023155592496, 7.50464844896836, 8.45455546449672, 9.30729220171718, 10.0837081378593, 9.20465769980849, 9.91024525899101, 10.9570255404187, 9.0327892513011, 6.86131805661889, 7.38890709870498, 9.71376659424175, 10.2479607676158, 7.8987271742062 ),
  `Pedal_Smoothness [%]` = c( 39.710181579574, 50.8184514296743, 52.4428359792181, 40.2055948041026, 53.6791852731242, 41.0448765909455, 47.914882163269, 51.5335837768147, 49.217483982331, 51.1389458112447, 48.0336788998195, 52.8223258874823, 47.9302436519206, 51.9475600881879, 54.0606647605687, 50.6559277814877, 52.6335181401208, 54.2725782631366, 43.083675000186, 49.0637500123524, 44.6632810590617, 50.293760020264, 51.2896166830574, 46.4638901013413, 48.3291073423363, 44.2590599394396, 52.6720469537052, 47.4439436135393, 48.2471522363413, 57.9737846304978, 42.4301080469913, 50.2908406548503, 52.3570034648903, 42.7127745966365, 52.2685711057555, 44.7936090146139, 46.3565980135841, 38.3575726240913, 39.6615373251182, 49.3105354600425, 42.1880618813037, 51.4796995926358, 54.4350155934243, 49.538139286023, 51.844375965857, 57.5052389013286, 57.6775357922151, 52.6180510620694, 32.375968743603, 42.0671208740445, 44.8980312830359, 34.1636884387502, 36.5443594656413, 47.3128113809467 ),
  `P_L_percent [%]` = c( 48.33, 50.2, 50.31, 48.74, 50.1, 49.16, 48.83, 47.25, 48.87, 47.74, 48.51, 48.13, 49.1, 47.89, 48.24, 49.08, 49.15, 48.32, 50.47, 51.64, 50.42, 52.2, 52.58, 50.35, 48.94, 48.97, 48.42, 48.87, 48.36, 48.81, 46.98, 47.29, 46.58, 45.97, 46.3, 45.61, 48.33, 47.48, 47.28, 47.99, 47.43, 48.98, 46.68, 47.57, 47.92, 46.93, 47.05, 47.83, 47.46, 48.28, 48.55, 47.93, 47.89, 47.39 ),
  `P_R_percent [%]` = c( 51.67, 49.8, 49.69, 51.26, 49.9, 50.84, 51.17, 52.75, 51.13, 52.26, 51.49, 51.87, 50.9, 52.11, 51.76, 50.92, 50.85, 51.68, 49.53, 48.36, 49.58, 47.8, 47.42, 49.65, 51.06, 51.03, 51.58, 51.13, 51.64, 51.19, 53.02, 52.71, 53.42, 54.03, 53.7, 54.39, 51.67, 52.52, 52.72, 52.01, 52.57, 51.02, 53.32, 52.43, 52.08, 53.07, 52.95, 52.17, 52.54, 51.72, 51.45, 52.07, 52.11, 52.61 ),
  `P_Int_Kinematik [W]` = c( NA, NA, NA, NA, NA, NA, 14.100763652975, 24.5534028664068, 15.0963689575941, 22.1151700768599, 17.3844162192499, 25.0023011514367, NA, NA, NA, NA, NA, NA, NA, 54.1998860792695, 26.061124339902, 52.2878157580086, 47.7818881896929, 26.5079250128008, 53.3391906234455, 14.3147915747616, 54.2938342051136, 17.2828759891928, 25.244349916907, 59.5680510358891, 33.3784974506853, 29.7741187061253, 30.3315111051071, 33.950962281492, 29.3032542779672, 36.2250453566804, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA ),
  `P_Int_Modell [W]` = c( 25.0030113782592, 35.8012933947664, 35.4927795606203, 25.3110458399501, 35.4895234774056, 26.0929432321431, 11.2772822919912, 26.5114016434881, 10.908542042465, 25.8068079920113, 10.6694874822585, 22.2486486488368, 15.741500125853, 48.0615124768915, 48.1369531524429, 15.9242224196747, 15.3918115611545, 47.2864879922241, 24.1895549833046, 55.9178086672442, 24.4935707465672, 55.8860388484466, 57.2064003074772, 24.2953284415851, 49.517125323862, 17.6500541105649, 50.7297211471405, 18.0094946189141, 18.9442986410243, 53.2215873863158, 26.7383367968065, 29.5600478833988, 29.426480838279, 26.832378813769, 30.1352473609116, 26.960742100465, 38.3697440266419, 11.5918218313976, 11.8051673274201, 37.8711938502897, 11.4696955201592, 38.7913797975227, 24.5892412580504, 11.0184578439549, 10.8030749020779, 24.509648850606, 23.8894209404426, 11.1845275722562, 19.8117633448399, 31.4236817494841, 31.7929519602614, 20.2785801635611, 20.2731228878915, 32.0418426886057 ),
  `P_Int_Kinematik_Modell [W]` = c( 28.8909754387892, 35.4998857304255, 35.1913718962795, 29.1990099004802, 35.1881158130648, 29.9809072926731, 14.100763652975, 24.5534028664068, 15.0963689575941, 22.1151700768599, 17.3844162192499, 25.0023011514367, 19.629464186383, 47.7601048125507, 47.8355454881021, 19.8121864802047, 19.2797756216845, 46.9850803278833, 28.0775190438347, 54.1998860792695, 26.061124339902, 52.2878157580086, 47.7818881896929, 26.5079250128008, 53.3391906234455, 14.3147915747616, 54.2938342051136, 17.2828759891928, 25.244349916907, 59.5680510358891, 33.3784974506853, 29.7741187061253, 30.3315111051071, 33.950962281492, 29.3032542779672, 36.2250453566804, 38.0683363623011, 15.4797858919276, 15.6931313879501, 37.5697861859489, 15.3576595806892, 38.4899721331819, 24.2878335937096, 14.9064219044849, 14.6910389626079, 24.2082411862652, 23.5880132761018, 15.0724916327862, 23.6997274053699, 31.1222740851432, 31.4915442959206, 24.1665442240911, 24.1610869484215, 31.7404350242649 ),
  `P_Int_Minetti [W]` = c( 30.9809373585523, 49.9999708568148, 49.4263049800275, 31.4908886354531, 49.4202592921155, 32.7945911926717, 10.9250427921879, 34.1502690837115, 10.4513604007798, 32.9455122957744, 10.1471003487607, 27.0326566244167, 16.6543744575556, 73.767219490831, 73.9216467087448, 16.9126300356257, 16.1629198459443, 72.185435664816, 28.625533659378, 87.4950086871089, 29.1062255383483, 87.428734336969, 90.1936400656646, 28.7925493361139, 72.8402574683913, 18.4088063094599, 75.2282351623464, 18.9103517783538, 20.230298081739, 80.1951316996545, 35.2316188202468, 40.2742001193818, 40.0317444559969, 35.3969341720174, 41.3224846452969, 35.6228942945399, 57.5509437920342, 11.666381586295, 11.9535465499954, 56.5560724625932, 11.5027875753635, 58.3957020942879, 31.2492356208192, 10.715365279786, 10.4370014598679, 31.1144417567931, 30.0690743189332, 10.931239773695, 22.663940206268, 41.9225151672263, 42.5806590146702, 23.3787506423065, 23.370362246721, 43.0256941239315 ),
  `Koerperlaenge [m]` = c( 1.83, 1.83, 1.83, 1.83, 1.83, 1.83, 1.84, 1.84, 1.84, 1.84, 1.84, 1.84, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.79, 1.79, 1.79, 1.79, 1.79, 1.79, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.76, 1.86, 1.86, 1.86, 1.86, 1.86, 1.86, 1.57, 1.57, 1.57, 1.57, 1.57, 1.57, 1.63, 1.63, 1.63, 1.63, 1.63, 1.63 ),
  `Masse [kg]` = c( 76, 76, 76, 76, 76, 76, 73, 73, 73, 73, 73, 73, 82, 82, 82, 82, 82, 82, 72, 72, 72, 72, 72, 72, 76, 76, 76, 76, 76, 76, 65, 65, 65, 65, 65, 65, 80, 80, 80, 80, 80, 80, 48, 48, 48, 48, 48, 48, 60, 60, 60, 60, 60, 60 ),
  `lBein [m]` = c( 0.893, 0.893, 0.893, 0.893, 0.893, 0.893, 0.906, 0.906, 0.906, 0.906, 0.906, 0.906, 0.876, 0.876, 0.876, 0.876, 0.876, 0.876, 4.23, 4.23, 4.23, 4.23, 4.23, 4.23, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.851, 0.925, 0.925, 0.925, 0.925, 0.925, 0.925, 0.749, 0.749, 0.749, 0.749, 0.749, 0.749, 0.78, 0.78, 0.78, 0.78, 0.78, 0.78 ),
  `lOS [m]` = c( 0.439, 0.439, 0.439, 0.439, 0.439, 0.439, 0.446, 0.446, 0.446, 0.446, 0.446, 0.446, 0.427, 0.427, 0.427, 0.427, 0.427, 0.427, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.412, 0.458, 0.458, 0.458, 0.458, 0.458, 0.458, 0.359, 0.359, 0.359, 0.359, 0.359, 0.359, 0.379, 0.379, 0.379, 0.379, 0.379, 0.379 ),
  `lUS [m]` = c( 0.582305761606392, 0.582305761606392, 0.582305761606392, 0.582305761606392, 0.582305761606392, 0.582305761606392, 0.590793534155546, 0.590793534155546, 0.590793534155546, 0.590793534155546, 0.590793534155546, 0.590793534155546, 0.567571140915392, 0.567571140915392, 0.567571140915392, 0.567571140915392, 0.567571140915392, 0.567571140915392, 0.561751724518937, 0.561751724518937, 0.561751724518937, 0.561751724518937, 0.561751724518937, 0.561751724518937, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.547909664087065, 0.605978547475074, 0.605978547475074, 0.605978547475074, 0.605978547475074, 0.605978547475074, 0.605978547475074, 0.470545428200083, 0.470545428200083, 0.470545428200083, 0.470545428200083, 0.470545428200083, 0.470545428200083, 0.496883286094431, 0.496883286094431, 0.496883286094431, 0.496883286094431, 0.496883286094431, 0.496883286094431 ),
  `uOS [m]` = c( 0.586, 0.586, 0.586, 0.586, 0.586, 0.586, 0.576, 0.576, 0.576, 0.576, 0.576, 0.576, 0.617, 0.617, 0.617, 0.617, 0.617, 0.617, 0.565, 0.565, 0.565, 0.565, 0.565, 0.565, 0.586, 0.586, 0.586, 0.586, 0.586, 0.586, 0.532, 0.532, 0.532, 0.532, 0.532, 0.532, 0.602, 0.602, 0.602, 0.602, 0.602, 0.602, 0.509, 0.509, 0.509, 0.509, 0.509, 0.509, 0.579, 0.579, 0.579, 0.579, 0.579, 0.579 ),
  `uUS [m]` = c( 0.372, 0.372, 0.372, 0.372, 0.372, 0.372, 0.367, 0.367, 0.367, 0.367, 0.367, 0.367, 0.387, 0.387, 0.387, 0.387, 0.387, 0.387, 0.362, 0.362, 0.362, 0.362, 0.362, 0.362, 0.372, 0.372, 0.372, 0.372, 0.372, 0.372, 0.346, 0.346, 0.346, 0.346, 0.346, 0.346, 0.38, 0.38, 0.38, 0.38, 0.38, 0.38, 0.32, 0.32, 0.32, 0.32, 0.32, 0.32, 0.354, 0.354, 0.354, 0.354, 0.354, 0.354 ),
  `lKurbel [m]` = c( 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.175, 0.175, 0.175, 0.175, 0.175, 0.175, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.17, 0.17, 0.17, 0.17, 0.17, 0.17, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725, 0.1725 )
  , check.names = FALSE
)

# UI Definition
ui <- fluidPage(
  titlePanel("Ergometer Daten Analyse"),
  
  sidebarLayout(
    sidebarPanel(
      width = 2,
      style = "height: 90vh; overflow-y: auto;",
      radioButtons("viewType", "Datenansicht:",
                   choices = c("Einzelwerte" = "individual",
                               "Mittelwerte & BP" = "means"),
                   selected = "means"),
      checkboxGroupInput("selectedBedingung", "Bedingungen:",
                         choices = unique(Erg_data_short$Bedingung),
                         selected = unique(Erg_data_short$Bedingung)),
      checkboxGroupInput("selectedIntensität", "Intensitäten:",
                         choices = unique(Erg_data_short$Intensität),
                         selected = unique(Erg_data_short$Intensität)),
      radioButtons("selectedVariable", "Variable für Boxplot:",
                   choices = c(
                     "nD_Vorgabe [U·min⁻¹]" = "nD_Vorgabe [U·min⁻¹]",
                     "nD [U·min⁻¹]" = "nD [U·min⁻¹]",
                     "P_mech_Vorgabe [W]" = "P_mech_Vorgabe [W]",
                     "P_mech [W]" = "P_mech [W]",
                     "P_mech_kg [W·kg⁻¹]" = "P_mech_kg [W·kg⁻¹]",
                     "Torque Efficiency [%]" = "Torque Efficiency [%]",
                     "P_mech_abs [W]" = "P_mech_abs [W]",
                     "P_max [W]" = "P_max [W]",
                     "P_max_kg [W·kg⁻¹]" = "P_max_kg [W·kg⁻¹]",
                     "Pedal_Smoothness [%]" = "Pedal_Smoothness [%]",
                     "P_Int_Kinematik [W]" = "P_Int_Kinematik [W]",
                     "P_Int_Modell [W]" = "P_Int_Modell [W]",
                     "P_Int_Kinematik_Modell [W]" = "P_Int_Kinematik_Modell [W]",
                     "P_Int_Minetti [W]" = "P_Int_Minetti [W]"
                   ),
                   selected = "P_mech [W]"),
      checkboxGroupInput("selectedProband", "Probanden:",
                         choices = sort(unique(Erg_data_short$Proband)),
                         selected = sort(unique(Erg_data_short$Proband)))
    ),
    mainPanel(
      width = 10,
      conditionalPanel(
        condition = "input.viewType == 'means'",
        plotlyOutput("boxplot")
      ),
      DTOutput("ergTable")
    )
  )
)

# Server-Logik
server <- function(input, output, session) {
  
  # Gruppierte Variablen nach Dezimalstellen
  digits_0 <- c("nD_Vorgabe [U·min⁻¹]", 
                "P_mech_Vorgabe [W]", "Nr")
  
  digits_1 <- c("nD [U·min⁻¹]",
                "P_mech [W]",
                "P_Int_Minetti [W]", 
                "P_mech_abs [W]",
                "P_max [W]",
                "P_Int_Kinematik [W]", 
                "P_Int_Modell [W]", 
                "P_Int_Kinematik_Modell [W]",
                "Masse [kg]", 
                "uOS [m]",
                "Torque Efficiency [%]", 
                "Pedal_Smoothness [%]",
                "P_L_percent [%]", 
                "P_R_percent [%]")
  
  digits_2 <- c("P_mech_kg [W·kg⁻¹]", 
                "P_max_kg [W·kg⁻¹]")
  
  digits_3 <- c("lKurbel [m]", 
                "Koerperlaenge [m]", 
                "lBein [m]",
                "lOS [m]", 
                "lUS [m]",
                "uOS [m]",
                "uUS [m]")
  
  
  # Hilfsfunktion für Nachkommastellen
  get_digits_for_column <- function(col_name) {
    if(col_name %in% digits_0) {
      return(0)
    } else if(col_name %in% digits_1) {
      return(1)
    } else if(col_name %in% digits_2) {
      return(2)
    } else if(col_name %in% digits_3) {
      return(3)
    }
    return(1)
  }
  
  # Reaktive gefilterte Daten für Tabelle
  filtered_data <- reactive({
    data <- Erg_data_short
    
    if (length(input$selectedProband) > 0) {
      data <- data %>% filter(Proband %in% input$selectedProband)
    }
    
    if (length(input$selectedBedingung) > 0) {
      data <- data %>% filter(Bedingung %in% input$selectedBedingung)
    }
    
    if (length(input$selectedIntensität) > 0) {
      data <- data %>% filter(Intensität %in% input$selectedIntensität)
    }
    
    if (input$viewType == "means") {
      # Bestimme Gruppierungsvariablen basierend auf Auswahl
      group_vars <- c()
      if (length(input$selectedBedingung) > 0 && length(input$selectedIntensität) == 0) {
        group_vars <- "Bedingung"
      } else if (length(input$selectedBedingung) == 0 && length(input$selectedIntensität) > 0) {
        group_vars <- "Intensität"
      } else if (length(input$selectedBedingung) > 0 && length(input$selectedIntensität) > 0) {
        group_vars <- c("Bedingung", "Intensität")
      }
      
      if (length(group_vars) == 0) {
        grouped_data <- data %>%
          summarise(across(where(is.numeric), 
                           list(mean = ~mean(., na.rm = TRUE),
                                sd = ~sd(., na.rm = TRUE)))) %>%
          mutate(Gruppe = "Gesamt")
        group_vars <- "Gruppe"
      } else {
        grouped_data <- data %>%
          group_by(across(all_of(group_vars))) %>%
          summarise(across(where(is.numeric), 
                           list(mean = ~mean(., na.rm = TRUE),
                                sd = ~sd(., na.rm = TRUE)))) %>%
          ungroup()
      }
      
      result_data <- grouped_data %>%
        select(all_of(group_vars))
      
      numeric_cols <- names(data)[sapply(data, is.numeric)]
      for(col in numeric_cols) {
        mean_col <- paste0(col, "_mean")
        sd_col <- paste0(col, "_sd")
        
        if(mean_col %in% names(grouped_data) && sd_col %in% names(grouped_data)) {
          digits <- get_digits_for_column(col)
          result_data[[col]] <- paste0(
            format(round(grouped_data[[mean_col]], digits), nsmall = digits),
            " ± ",
            format(round(grouped_data[[sd_col]], digits), nsmall = digits)
          )
        }
      }
      
      return(result_data)
    }
    
    return(data)
  })
  
  # Reaktive gefilterte Daten für Plots
  filtered_data_plots <- reactive({
    data <- Erg_data_short %>%
      filter(Proband %in% input$selectedProband)
    
    if (length(input$selectedBedingung) > 0) {
      data <- data %>% filter(Bedingung %in% input$selectedBedingung)
    }
    
    if (length(input$selectedIntensität) > 0) {
      data <- data %>% filter(Intensität %in% input$selectedIntensität)
    }
    
    # Gruppierung basierend auf Auswahl
    if (length(input$selectedBedingung) > 0 && length(input$selectedIntensität) == 0) {
      data$Gruppe <- data$Bedingung
    } else if (length(input$selectedBedingung) == 0 && length(input$selectedIntensität) > 0) {
      data$Gruppe <- data$Intensität
    } else {
      data$Gruppe <- paste(data$Intensität, data$Bedingung, sep = "_")
    }
    
    return(data)
  })
  
  # Color Map
  color_map <- reactive({
    c(
      "leicht_sitzen" = "#42BA97", "leicht_stehen" = "#62A39F",
      "moderat_sitzen" = "#1CADE4", "moderat_stehen" = "#2683C6",
      "schwer_sitzen" = "#EF5350", "schwer_stehen" = "#C8133B"
    )
  })
  
  # Tabellen-Output
  output$ergTable <- renderDT({
    data <- filtered_data()
    
    if (input$viewType == "individual") {
      columnDefs <- lapply(seq_len(ncol(data)), function(i) {
        list(
          targets = i-1,
          width = paste0(max(
            nchar(names(data)[i]),
            max(nchar(as.character(data[[i]])))
          ) * 10, "px"),
          className = "dt-nowrap"
        )
      })
      
      datatable(data,
                options = list(
                  pageLength = 10,
                  scrollX = TRUE,
                  scrollCollapse = TRUE,
                  autoWidth = FALSE,
                  columnDefs = columnDefs
                )
      ) %>%
        formatRound(
          columns = intersect(names(data), digits_0),
          digits = 0
        ) %>%
        formatRound(
          columns = intersect(names(data), digits_1),
          digits = 1
        ) %>%
        formatRound(
          columns = intersect(names(data), digits_2),
          digits = 2
        ) %>%
        formatRound(
          columns = intersect(names(data), digits_3),
          digits = 3
        )
    } else {
      columnDefs <- lapply(seq_len(ncol(data)), function(i) {
        list(
          targets = i-1,
          width = paste0(max(
            nchar(names(data)[i]),
            max(nchar(as.character(data[[i]])))
          ) * 10, "px"),
          className = "dt-nowrap"
        )
      })
      
      datatable(data,
                options = list(
                  pageLength = 10,
                  scrollX = TRUE,
                  scrollCollapse = TRUE,
                  autoWidth = FALSE,
                  columnDefs = columnDefs
                ),
                escape = FALSE
      )
    }
  })
  
  # Boxplot
  output$boxplot <- renderPlotly({
    data <- filtered_data_plots()
    color_map_values <- color_map()
    
    # Farben anpassen basierend auf Gruppierung
    if (length(input$selectedBedingung) > 0 && length(input$selectedIntensität) == 0) {
      colors <- c("sitzen" = "#42BA97", "stehen" = "#62A39F")
    } else if (length(input$selectedBedingung) == 0 && length(input$selectedIntensität) > 0) {
      colors <- c("leicht" = "#42BA97", "moderat" = "#1CADE4", "schwer" = "#EF5350")
    } else {
      colors <- color_map_values
    }
    
    p <- plot_ly(data = data, 
                 x = ~Gruppe, 
                 y = as.formula(paste0("~`", input$selectedVariable, "`")),
                 type = "box",
                 color = ~Gruppe,
                 colors = colors[unique(data$Gruppe)],
                 opacity = 0.8,
                 line = list(color = "black", width = 0.9),
                 boxpoints = "outliers",
                 pointpos = 0,
                 marker = list(color = "black", size = 4),
                 boxmean = TRUE,
                 hoverlabel = list(bgcolor = "#F5F5F5"),
                 showlegend = FALSE
    ) %>%
      layout(title = paste('Boxplot:', input$selectedVariable),
             margin = list(t = 40),
             xaxis = list(title = "Gruppe"),
             yaxis = list(title = input$selectedVariable))
    
    return(p)
  })
}

# App starten
shinyApp(ui = ui, server = server)

```

# Deskriptive Analyse der Belastungsparameter
Die folgenden Tabellen bieten eine detaillierte deskriptive Auswertung der ergometrischen Parameter, wobei alle Werte als Mittelwert ± Standardabweichung angegeben werden. Die Daten werden in einer Gesamtübersicht mit Mittelwerten sowie minimalen und maximalen Messwerten (@tbl-Ergometer_mean) dargestellt. In den weiteren Tabellen erfolgt eine detaillierte Darstellung nach den experimentellen Bedingungen (Sitzen vs. Stehen; @tbl-Ergometer_Bedingung_mean), den Belastungsintensitäten (leicht, moderat, schwer; @tbl-Ergometer_Intensitaet_mean) sowie nach der Kombination beider Faktoren (@tbl-Ergometer_Bedingung_Intensitaet_mean).

Die analysierten Parameter umfassen die vorgegebene und gemessene Trittrate (nD~Vorgabe~, nD), die vorgegebene und gemessene mechanische Leistung (P~mech,Vorgabe~, P~mech~) sowie die gewichtsspezifische gemessene mechanische Leistung (P~mech,kg~). Weiterhin werden die Torque Efficiency als prozentualer Anteil des effektiven Antriebsmoments am Gesamtdrehmoment der Kurbel, die durchschnittliche absolute mechanische Gesamtleistung also die Summation der Beträge von positiver und negativer mechanischer Leistung (P~mech,abs~) und die durchschnittliche erreichte maximale mechanische Leistung pro Pedalzyklus (P~mech,max~) sowie deren gewichtsspezifische Ausprägung (P~mech,max,kg~) dargestellt. Ergänzend werden die Pedal Smoothness als Verhältnis von mittlerer zu maximaler Leistung während einer Pedalumdrehung sowie die prozentualen Leistungsanteile des linken und rechten Beins (P~L,percent~, P~R,percent~) präsentiert.
Die innere Leistung wurde über verschiedene Berechnungsansätze ermittelt: Die P~Int,Kinematik~ basiert auf kinematischer 3D-Bewegungsanalyse, während P~Int,Modell~ auf biomechanischer Modellsimulation beruht. P~Int,Kinematik,Modell~ stellt die modellierte innere Leistung basierend auf mittleren Differenzen zwischen kinematischer und berechneter innerer Leistung dar. Zusätzlich wurde die innere Leistung nach dem biomechanischen Berechnungsmodell von @Minetti2001 als P~Int,Minetti~ bestimmt.

::: {.panel-tabset}
### Gesamtdaten


```{r}
#| label: tbl-Ergometer_mean
#| tbl-cap-location: top
#| tbl-cap: "Gesamtdaten: Ergometrische Parameter: MW ± SD, Min & Max"

library(flextable)
ft_Ergometer_stats_mean <- readRDS("rds/ft_Ergometer_stats_mean.rds")

# Anzeigen der Tabelle
ft_Ergometer_stats_mean
```


### Bedingungen


```{r}
#| label: tbl-Ergometer_Bedingung_mean
#| tbl-cap-location: top
#| tbl-cap: "Ergometrische Parameter: MW ± SD nach Bedingungen"

ft_Ergometer_stats_Bedingung_mean <- readRDS("rds/ft_Ergometer_stats_Bedingung_mean.rds")

# Anzeigen der Tabelle
ft_Ergometer_stats_Bedingung_mean
```


### Intensitäten


```{r}
#| label: tbl-Ergometer_Intensitaet_mean
#| tbl-cap-location: top
#| tbl-cap: "Ergometrische Parameter: MW ± SD nach Intensitäten"

ft_Ergometer_stats_Intensitaet_mean <- readRDS("rds/ft_Ergometer_stats_Intensitaet_mean.rds")

# Anzeigen der Tabelle
ft_Ergometer_stats_Intensitaet_mean
```


### Bedingungen & Intensitäten


```{r}
#| label: tbl-Ergometer_Bedingung_Intensitaet_mean
#| tbl-cap-location: top
#| tbl-cap: "Ergometrische Parameter: MW ± SD nach Bedingungen und Intensitäten"

ft_Ergometer_stats_Bedingung_Intensitaet_mean <- readRDS("rds/ft_Ergometer_stats_Bedingung_Intensitaet_mean.rds")

# Anzeigen der Tabelle
ft_Ergometer_stats_Bedingung_Intensitaet_mean
```


:::

#### Drehzahl { .unlisted }
Die vorgegebene Trittrate (nD~Vorgabe~), welche aus den individuellen Stufentests im Sitzen und im Stehen bestimmt wurde, beträgt im Gesamtmittel 79 ± 12 U·min^-1^ (R: 59-100 U·min^-1^). nD~Vorgabe~ beträgt im Sitzen durchschnittlich 88 ± 6 U·min^-1^ und im Stehen durchschnittlich 69 ± 8 U·min^-1^. Die tatsächlich gemessene Trittrate (nD) liegt mit einem Gesamtmittelwert von 79.4 ± 12.2 U·min^-1^ (Range: 58.6-101.5 U·min^-1^) sehr nahe an der vorgegebenen Trittrate und weist auch innerhalb der einzelnen Bedingungen nur minimale Abweichungen von den Vorgabewerten auf. 
Beim Fahren im Sitzen zeigt sich eine durchschnittliche Trittrate von 89.1 ± 6.6 U·min^-1^, welche geringfügig über dem Vorgabewert liegt (+1.1 U·min^-1^). Ähnlich genau wurde die Zieltrittrate in stehender Position eingehalten (+0.8 U·min^-1^). Die vorgegebene sowie die realisierte Trittrate blieb dabei über alle Intensitätsstufen hinweg konstant.

#### Mechanische Leistung { .unlisted }
Die vorgegebene mechanische Leistung (P~mech,Vorgabe~), welche aus den ventilatorischen Schwellen des Stufentests im Sitzen abgeleitet wurde, beträgt im Gesamtmittel 292 ± 52 W (Range (R): 185-410 W) und wurde für beide Testbedingungen identisch festgelegt. Die tatsächlich realisierte mechanische Leistung (P~mech~) liegt mit einem Gesamtmittelwert von 286.7 ± 54.3 W (R: 173.2-411.8 W) systematisch unterhalb der Vorgabewerte. Dieser Effekt zeigt sich in beiden Testbedingungen, wobei die Abweichung in sitzender Position (284.6 ± 53.4 W) stärker ausfällt als in stehender Position (288.9 ± 56.1 W). Die systematische Unterschreitung der Vorgabewerte zeigt sich dabei konsistent über alle Intensitätsstufen hinweg, mit einer stärkeren Abweichung bei Belastungen im Sitzen.
Die gewichtsnormierte mechanische Leistung (P~mech,kg~) beträgt im Mittel 4.11 ± 0.66 W·kg^-1^ (Range: 2.89-5.77 W·kg^-1^) und zeigt zwischen den Bedingungen und über die Intensitäten hinweg die gleichen Muster wie die absolute mechanische Leistung.

#### Torque Efficiency { .unlisted }
Die Torque Efficiency liegt durchschnittlich bei 77.3 ± 10.1 % (R: 50.6-97.1 %) und zeigt zwischen den Bedingungen leichte Unterschiede (sitzend: 78.2 ± 8.8 %, stehend: 76.4 ± 11.4 %). Mit steigender Intensität ist ein deutlicher Anstieg von leichter (71.2 ± 9.2 %) über moderate (77.9 ± 9.5 %) zu schwerer Intensität (82.9 ± 8.4 %) zu beobachten. Dieser Trend zeigt sich sowohl im Sitzen (leicht: 73.1 ± 8.8 %, moderat: 78.7 ± 8.4 %, schwer: 82.7 ± 7.2 %) als auch im Stehen (leicht: 69.2 ± 9.6 %, moderat: 77.1 ± 11.0 %, schwer: 83.0 ± 9.9 %).

#### Absolute mechanische Leistung{ .unlisted }
Die absolute mechanische Gesamtleistung (P~mech,abs~), beträgt im Mittel 371.7 ± 55.9 W (Range: 269.2-480.0 W). In Übereinstimmung mit den Werten der Torque Efficiency zeigen sich Unterschiede zwischen den Bedingungen, wobei im Stehen (378.8 ± 51.8 W) höhere Werte als im Sitzen (364.6 ± 59.9 W) erreicht werden. Diese Diskrepanz deutet auf einen erhöhten Anteil negativer mechanischer Leistung während der Pedalumdrehung unter stehenden Bedingungen hin.

#### Maximale mechanische Leistung pro Pedalzyklus { .unlisted }
Die durchschnittliche maximale mechanische Leistung (P~mech,max~) pro Pedalumdrehung liegt bei 601.7 ± 106.9 W (R: 405.8-846.1 W) und zeigt deutliche Unterschiede zwischen den Bedingungen. Im Stehen werden deutlich höhere Maximalwerte (651.4 ± 101.8 W) als im Sitzen (552.0 ± 88.5 W) erreicht. Die gewichtsspezifische maximale Leistung (P~mech,max,kg~) beträgt im Mittel 8.61 ± 1.13 W·kg^-1^ (R: 6.66-11.13 W·kg^-1^) und folgt dem gleichen Muster.

#### Pedal Smoothness { .unlisted }
Die Pedal Smoothness, definiert als das Verhältnis von mittlerer zu maximaler Leistung während einer Pedalumdrehung, beträgt im Durchschnitt 47.9 ± 5.8 % (Range: 32.4-58.0 %). Aufgrund der im Stehen auftretenden höheren P~mech,max~ Werte zeigen sich systematische Unterschiede zwischen den Bedingungen. In sitzender Position werden durchgehend höhere Werte (51.4 ± 3.7 %) als in stehender Position (44.4 ± 5.5 %) erreicht. Mit zunehmender Intensität ist in beiden Bedingungen ein kontinuierlicher Anstieg zu beobachten - im Sitzen von 49.4 ± 3.6 % über 51.6 ± 3.5 % auf 53.2 ± 3.3 % und im Stehen von 42.8 ± 5.5 % über 44.5 ± 5.9 % auf 45.8 ± 5.3 % für leichte, moderate und schwere Intensität.

#### Links-Rechts-Balance { .unlisted }
Die Verteilung der Leistung zwischen linkem (P~L,percent~: 48.4 ± 1.4 %, R: 45.6-52.6 %) und rechtem Bein (P~R,percent~: 51.6 ± 1.4 %, R: 47.4-54.4 %) zeigt eine leichte Dominanz der rechten Seite. Diese Asymmetrie bleibt über beide Bedingungen (Sitzen: 48.6/51.4 %, Stehen: 48.3/51.7 %) und alle Intensitätsstufen (leicht: 48.4/51.6 %, moderat: 48.4/51.6 %, schwer: 48.4/51.6 %) nahezu konstant.

#### Innere Leistung { .unlisted }
Die modellbasierte innere Leistung (P~Int,Modell~) (@fig-PInt_Modell) beträgt im Gesamtmittel 28.0 ± 13.3 W (Range: 10.7-57.2 W) und zeigt Unterschiede zwischen den Bedingungen. Im Sitzen werden, bedingt durch die höheren Trittraten (nD: 89.1 ± 6.6 U·min^-1^ vs. 69.8 ± 8.1 U·min^-1^), systematisch höhere Werte (37.8 ± 11.2 W) als im Stehen (18.2 ± 6.1 W) erreicht. Die Werte bleiben aufgrund der fast identischen Drehzahlen zwischen den Intensitäten erwartungsgemäß über die Intensitätsstufen weitgehend konstant. Im Sitzen von 37.8 ± 11.1 W über 37.7 ± 11.4 W auf 37.8 ± 12.4 W und im Stehen von 18.1 ± 6.2 W über 18.3 ± 6.4 W auf 18.4 ± 6.5 W.

Die mittels 3D-Kinematik für ausgewählte Probanden bestimmte innere Leistung (P~Int,Kinematik~) liegt mit durchschnittlich 32.3 ± 14.4 W (Range: 14.1-59.6 W) systematisch höher und zeigt vergleichbare Unterschiede zwischen den Bedingungen. Auch hier werden im Sitzen, primär aufgrund der höheren Trittraten, deutlich höhere Werte (40.2 ± 14.4 W) als im Stehen (23.6 ± 8.4 W) erreicht. Diese Differenz bleibt über alle Intensitätsstufen bestehen, wobei im Sitzen Werte von 40.5 ± 15.5 W (leicht) über 39.8 ± 16.0 W (moderat) bis 40.4 ± 16.1 W (schwer) und im Stehen von 20.6 ± 11.1 W (leicht) über 23.1 ± 8.6 W (moderat) bis 26.3 ± 7.7 W (schwer) erreicht werden. Im Vergleich zu P~Int,Modell~ zeigen sich damit im Sitzen um durchschnittlich 2.4 W (+6.3%) und im Stehen um 5.4 W (+29.7%) höhere Werte.

Um die fehlenden P~Int,Kinematik~ Werte zu interpolieren, wurde basierend auf den mittleren Differenzen zwischen kinematischer und modellbasierter Berechnung eine kombinierte kinematisch-modellbasierte innere Leistung (P~Int,Kinematik,Modell~) bestimmt. Diese weist mit durchschnittlich 29.8 ± 12.1 W (Range: 14.1-59.6 W) erwartungsgemäß Werte zwischen den beiden ursprünglichen Berechnungsmethoden auf. Analog zu P~Int,Modell~ und P~Int,Kinematik~ zeigen sich auch hier über die Intensitätsstufen hinweg konstante Werte - im Sitzen bei 37.6 ± 11.6 W, 37.3 ± 11.8 W und 37.5 ± 11.9 W sowie im Stehen bei 21.4 ± 7.4 W, 21.8 ± 6.9 W und 23.2 ± 7.1 W für leichte, moderate und schwere Intensität.

Die theoretische Berechnung der inneren Leistung nach @Minetti2001 (P~Int,Minetti~) (@fig-PInt_Minetti) zeigt mit durchschnittlich 37.7 ± 22.9 W (Range: 10.1-90.2 W) die höchsten Werte aller Berechnungsmethoden. Die Berechnung erfolgt ohne Differenzierung zwischen dem Fahren im Stehen und Sitzen nach der Formel $W_{Int,Minetti}\,\text{[J]} = 0.153 \cdot Körpermasse\,\text{[kg]} \cdot \text{nD}^3\,\text{[Hz]}$, welche die benötigte innere Arbeit in Joule für eine Umdrehung beschreibt. Bedingt durch diese kubische Abhängigkeit von der Drehzahl führen die höheren Trittraten im Sitzen zu mehr als doppelt so hohen Werten (54.5 ± 20.0 W) wie im Stehen (20.9 ± 9.1 W). Diese ausgeprägte Differenz zwischen den Bedingungen bleibt über alle Intensitätsstufen konstant, mit Werten im Sitzen von 54.4 ± 19.8 W über 54.4 ± 20.3 W auf 54.6 ± 22.2 W und im Stehen von 20.7 ± 9.2 W über 20.9 ± 9.4 W auf 21.1 ± 9.7 W für leichte, moderate und schwere Intensität.

# Torque Efficiency & Pedal Smoothness
In dem folgenden Abschnitt werden der Verlauf der Tangentialleistung über den Pedalzyklus, die kreisförmigen Darstellungen der Leistungsanteile sowie die Zusammenhänge zwischen Torque Efficiency, Pedal Smoothness und der gewichtsbezogenen mechanischen Leistung präsentiert.

## Verlauf der Tangentialleistung aller Durchgänge über den Pedalzyklus { .unlisted }
Die folgenden Abbildungen visualisieren die mittlere gewichtsbezogene Tangentialleistung über eine Kurbelumdrehung (360°) für beide Beine, wobei die Hauptkurven (gepunktet) sowie deren Streuung (gestrichelt) dargestellt sind. Die horizontale graue Linie kennzeichnet die mittlere mechanische Leistung. Die vertikalen schwarzen Linien markieren die Zeitpunkte der positiven und negativen Leistungsmaxima, die im Sitzen bei etwa 90° (positiv) und 270° (negativ) auftreten. Im Stehen verschieben sich diese Maxima um circa 30° nach hinten. Im Vergleich der Fahrbedingungen zeigen sich im Stehen höhere Maximalwerte sowie eine zeitlich verzögerte Kraftentfaltung. Mit zunehmender Intensität bleiben die Kurvencharakteristika weitgehend stabil, lediglich die Maximalwerte und die Streuung steigen an. Die Symmetrie zwischen linkem und rechtem Bein bleibt in allen Bedingungen mit den erwarteten ca. 180° versetzten Leistungsmaxima erhalten.

::: panel-tabset
### Gesamt
![Verlauf der gewichtsbezogenen Tangentialleistung aller Durchgänge über den Drehwinkel für beide Beine](images/P_komplett.png){#fig-Tangentialleistung_Alle}

### Leicht_Sitzen
![Verlauf der gewichtsbezogenen Tangentialleistung der leicht_sitzen-Bedingung über den Drehwinkel für beide Beine](images/P_leicht_sitzen.png){#fig-Tangentialleistung_Leicht_Sitzen}

### Leicht_Stehen
![Verlauf der gewichtsbezogenen Tangentialleistung der leicht_stehen-Bedingung über den Drehwinkel für beide Beine](images/P_leicht_stehen.png){#fig-Tangentialleistung_Leicht_Stehen}

### Moderat_Sitzen
![Verlauf der gewichtsbezogenen Tangentialleistung der moderat_sitzen-Bedingung über den Drehwinkel für beide Beine](images/P_moderat_sitzen.png){#fig-Tangentialleistung_Moderat_Sitzen}

### Moderat_Stehen
![Verlauf der gewichtsbezogenen Tangentialleistung der moderat_stehen-Bedingung über den Drehwinkel für beide Beine](images/P_moderat_stehen.png){#fig-Tangentialleistung_Moderat_Stehen}

### Schwer_Sitzen
![Verlauf der gewichtsbezogenen Tangentialleistung der schwer_sitzen-Bedingung über den Drehwinkel für beide Beine](images/P_schwer_sitzen.png){#fig-Tangentialleistung_Schwer_Sitzen}

### Schwer_Stehen
![Verlauf der gewichtsbezogenen Tangentialleistung der schwer_stehen-Bedingung über den Drehwinkel für beide Beine](images/P_schwer_stehen.png){#fig-Tangentialleistung_Schwer_Stehen}
:::

## Kreisförmige Darstellung der positiven und negativen Leistungsanteile der Pedalzyklen { .unlisted }
Die dargestellten Abbildungen stellen die mittlere Torque Efficiency sowie die positiven (P+) und negativen (P-) Leistungsanteile während der Pedalzyklen kreisförmig dar. Im Vergleich der Fahrbedingungen zeigt sich im Sitzen eine leicht höhere durchschnittliche Torque Efficiency (78.17%) als im Stehen (76.43%) (@fig-Eff_KD_Bedingung). Mit steigender Intensität steigt die Torque Efficiency von 71.17% (leicht) über 77.86% (moderat) auf 82.87% (schwer) (@fig-Eff_KD_Intensität). Diese Steigerung ist in beiden Fahrbedingungen zu beobachten, wobei im Stehen bei leichter Intensität die geringste (69.19%) und bei schwerer Intensität die höchste Torque Efficiency (83.04%) erreicht wird (@fig-Eff_KD_Bedingung_Intensität). Die positiven Leistungsanteile (grün) und negativen Leistungsanteile (rot) bleiben innerhalb den Bedingungen über die Kurbelumdrehung weitgehend konstant.

::: panel-tabset
### Bedingungen


```{r}
P_R_list <- readRDS("rds/P_R_list.rds") 
P_L_list <- readRDS("rds/P_L_list.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")

# Proband 2 und 3 entfernen
Efficiency_Daten_df <- Efficiency_Daten_df %>%
  filter(!Proband %in% c(2, 3))

# Einträge die mit 02 oder 03 beginnen entfernen
P_L_list <- P_L_list[!grepl("^(02|03)_", names(P_L_list))]
P_R_list <- P_R_list[!grepl("^(02|03)_", names(P_R_list))]

# Gruppieren und Durchschnitt berechnen, Einträge mit Intensität = "niedrig" ignorieren
Efficiency_Bed_df <- Efficiency_Daten_df %>%
  group_by(Bedingung) %>%
  summarise(Efficiency = round(mean(Efficiency, na.rm = TRUE), 2)) %>%
  mutate(condition = paste(Bedingung))

# Leere Liste für die Durchschnittswerte erstellen
Bedingung_list_L <- list()
Bedingung_list_R <- list()

# Initialisiere die Durchschnittswerte für "stehen" und "sitzen"
mean_stehen_L <- numeric(180)
mean_sitzen_L <- numeric(180)
mean_stehen_R <- numeric(180)
mean_sitzen_R <- numeric(180)

# Iteriere über die Namen in P_L_list
for (name in names(P_L_list)) {
  # Prüfe, ob "stehen" im Namen vorkommt
  if (grepl("stehen", name)) {
    # Addiere den Eintrag zu mean_stehen_L
    mean_stehen_L <- mean_stehen_L + P_L_list[[name]]
  }
  # Prüfe, ob "sitzen" im Namen vorkommt
  if (grepl("sitzen", name)) {
    # Addiere den Eintrag zu mean_sitzen_L
    mean_sitzen_L <- mean_sitzen_L + P_L_list[[name]]
  }
}

# Iteriere über die Namen in P_R_list
for (name in names(P_R_list)) {
  # Prüfe, ob "stehen" im Namen vorkommt
  if (grepl("stehen", name)) {
    # Addiere den Eintrag zu mean_stehen_R
    mean_stehen_R <- mean_stehen_R + P_R_list[[name]]
  }
  # Prüfe, ob "sitzen" im Namen vorkommt
  if (grepl("sitzen", name)) {
    # Addiere den Eintrag zu mean_sitzen_R
    mean_sitzen_R <- mean_sitzen_R + P_R_list[[name]]
  }
}

# Berechne den Durchschnitt für "stehen" und "sitzen" über alle Datenpunkte
Bedingung_list_L[["stehen"]] <- mean_stehen_L / sum(grepl("stehen", names(P_L_list)))
Bedingung_list_L[["sitzen"]] <- mean_sitzen_L / sum(grepl("sitzen", names(P_L_list)))

Bedingung_list_R[["stehen"]] <- mean_stehen_R / sum(grepl("stehen", names(P_R_list)))
Bedingung_list_R[["sitzen"]] <- mean_sitzen_R / sum(grepl("sitzen", names(P_R_list)))

# Winkeldaten definieren
Winkeldaten <- seq(0, 358, by = 2)
efficiency_values <- Efficiency_Bed_df$Efficiency
names(efficiency_values) <- Efficiency_Bed_df$condition

# Schleife über die Bedingungen ("stehen" und "sitzen")
plots <- list()
for (condition in c("stehen", "sitzen")) {
  values_L <- Bedingung_list_L[[condition]]
  values_R <- Bedingung_list_R[[condition]]
  values_avg <- rowMeans(data.frame(P_R = values_R, P_L = values_L))
  adjusted_Winkeldaten <- (Winkeldaten + 180) %% 360
  
  # Vorbereitung der Datenrahmen für das Plotten
  data_L <- data.frame(theta = adjusted_Winkeldaten, r = values_L)
  data_R <- data.frame(theta = Winkeldaten, r = values_R)
  merged_data <- merge(data_L[c("theta", "r")], data_R[c("theta", "r")], by = "theta", all = FALSE)
  
  # Berechnung und Anpassung der Daten für das Plotten
  merged_data$r_avg <- rowMeans(merged_data[c("r.x", "r.y")])
  merged_data$r_avg <- ifelse(merged_data$r_avg >= 0, merged_data$r_avg + 1200, merged_data$r_avg - 1200)
  merged_data$color <- ifelse(merged_data$r_avg > 0, "#42BA97", "#EF5350")
  
  data_avg <- data.frame(theta = Winkeldaten, r = abs(merged_data$r_avg), color = merged_data$color)
  data_avg$Baseline <- 1200
  
  # Erstellung des Plots für die aktuelle Bedingung
  plot <- ggplot(data_avg, aes(x = theta, y = r, fill = color)) +
    geom_ribbon(aes(ymin = Baseline, ymax = r), alpha = 0.5) +
    geom_line(aes(color = color), size = 0.8) +
    geom_hline(yintercept = 1200, linetype = "solid", color = "black", size = 0.8) +
    scale_colour_manual(values = c("black", "black")) +
    scale_fill_manual(values = c("#42BA97", "#EF5350")) +
    coord_polar(start = 0) +
    scale_x_continuous(breaks = c(0, 90, 180, 270), labels = c("0", "90", "180", "270")) +
    theme(axis.text = element_text(color = "black", hjust = 0.2), axis.text.y = element_blank(), axis.ticks.y = element_blank(), 
          panel.grid = element_blank(), axis.title = element_blank(), panel.background = element_blank(), 
          legend.position = "none") +
    scale_y_continuous(limits = c(0, 2500))
  
  # Füge Text ein
  efficiency_value <- efficiency_values[condition]
  plot <- plot + annotate("text", x = 180, y = 1800 * 1.1, label = paste("Eff:", efficiency_value,"%"), size = 4, color = "black")
  plot <- plot + annotate("text", x = 0, y = 1800 * 1.1, label = condition, size = 4, color = "black", vjust = 0.5, hjust = 0.5)
  plot <- plot + annotate("text", x = 270, y = 1800 * 1.2, label = "P-", size = 4, color = "black")
  plot <- plot + annotate("text", x = 90, y = 1800 * 1.2, label = "P+", size = 4, color = "black")
  
  # Entferne den automatischen Titel
  plot <- plot + labs(title = NULL)
  
  # Füge den aktuellen Plot zur Liste der Plots hinzu
  plots[[condition]] <- plot
}

# Erstellen Sie die finale Abbildung, indem Sie die Plots nebeneinander anordnen
final_plot <- wrap_plots(plots, ncol = 2)
p_Eff_KD_Bedingung <- final_plot
```

```{r}
#| label: fig-Eff_KD_Bedingung
#| fig-cap: "Kreisförmige Darstellung der mittleren positiven (P+) und negativen (P-) Leistungsanteile mit resultierender Torque Efficiency während der Pedalzyklen in stehender und sitzender Position"
#| fig-cap-location: bottom

p_Eff_KD_Bedingung
```




### Intensitäten


```{r}
P_R_list <- readRDS("rds/P_R_list.rds") 
P_L_list <- readRDS("rds/P_L_list.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")

# Proband 2 und 3 entfernen
Efficiency_Daten_df <- Efficiency_Daten_df %>%
  filter(!Proband %in% c(2, 3))

# Einträge die mit 02 oder 03 beginnen entfernen
P_L_list <- P_L_list[!grepl("^(02|03)_", names(P_L_list))]
P_R_list <- P_R_list[!grepl("^(02|03)_", names(P_R_list))]

# Gruppieren und Durchschnitt berechnen, Einträge mit Intensität = "niedrig" ignorieren
Efficiency_Int_df <- Efficiency_Daten_df %>%
  filter(Intensität != "niedrig") %>%
  group_by(Intensität) %>%
  summarise(Efficiency = round(mean(Efficiency, na.rm = TRUE), 2)) %>%
  mutate(intensity = paste(Intensität))

# Leere Listen für die Durchschnittswerte erstellen
Intensität_list_L <- list()
Intensität_list_R <- list()

# Initialisiere die Durchschnittswerte für "leicht", "moderat" und "schwer"
mean_leicht_L <- numeric(180)
mean_moderat_L <- numeric(180)
mean_schwer_L <- numeric(180)
mean_leicht_R <- numeric(180)
mean_moderat_R <- numeric(180)
mean_schwer_R <- numeric(180)

# Iteriere über die Namen in P_L_list
for (name in names(P_L_list)) {
  # Prüfe, ob "leicht" im Namen vorkommt
  if (grepl("leicht", name)) {
    # Addiere den Eintrag zu mean_leicht_L
    mean_leicht_L <- mean_leicht_L + P_L_list[[name]]
  }
  # Prüfe, ob "moderat" im Namen vorkommt
  if (grepl("moderat", name)) {
    # Addiere den Eintrag zu mean_moderat_L
    mean_moderat_L <- mean_moderat_L + P_L_list[[name]]
  }
  # Prüfe, ob "schwer" im Namen vorkommt
  if (grepl("schwer", name)) {
    # Addiere den Eintrag zu mean_schwer_L
    mean_schwer_L <- mean_schwer_L + P_L_list[[name]]
  }
}

# Iteriere über die Namen in P_R_list
for (name in names(P_R_list)) {
  # Prüfe, ob "leicht" im Namen vorkommt
  if (grepl("leicht", name)) {
    # Addiere den Eintrag zu mean_leicht_R
    mean_leicht_R <- mean_leicht_R + P_R_list[[name]]
  }
  # Prüfe, ob "moderat" im Namen vorkommt
  if (grepl("moderat", name)) {
    # Addiere den Eintrag zu mean_moderat_R
    mean_moderat_R <- mean_moderat_R + P_R_list[[name]]
  }
  # Prüfe, ob "schwer" im Namen vorkommt
  if (grepl("schwer", name)) {
    # Addiere den Eintrag zu mean_schwer_R
    mean_schwer_R <- mean_schwer_R + P_R_list[[name]]
  }
}

# Berechne den Durchschnitt für "leicht", "moderat" und "schwer" über alle Datenpunkte
Intensität_list_L[["leicht"]] <- mean_leicht_L / sum(grepl("leicht", names(P_L_list)))
Intensität_list_L[["moderat"]] <- mean_moderat_L / sum(grepl("moderat", names(P_L_list)))
Intensität_list_L[["schwer"]] <- mean_schwer_L / sum(grepl("schwer", names(P_L_list)))

Intensität_list_R[["leicht"]] <- mean_leicht_R / sum(grepl("leicht", names(P_R_list)))
Intensität_list_R[["moderat"]] <- mean_moderat_R / sum(grepl("moderat", names(P_R_list)))
Intensität_list_R[["schwer"]] <- mean_schwer_R / sum(grepl("schwer", names(P_R_list)))

# Winkeldaten definieren
Winkeldaten <- seq(0, 358, by = 2)

efficiency_values <- Efficiency_Int_df$Efficiency
names(efficiency_values) <- Efficiency_Int_df$intensity

# Leere Liste für die ggplot-Plots erstellen
ggplot_plots <- list()

# Schleife über die Intensitäten ("leicht", "moderat" und "schwer")
for (intensity in c("leicht", "moderat", "schwer")) {
  values_L <- Intensität_list_L[[intensity]]
  values_R <- Intensität_list_R[[intensity]]
  values_avg <- rowMeans(data.frame(P_R = values_R, P_L = values_L))
  adjusted_Winkeldaten <- (Winkeldaten + 180) %% 360
  
  # Vorbereitung der Datenrahmen für das Plotten
  data_L <- data.frame(theta = adjusted_Winkeldaten, r = values_L)
  data_R <- data.frame(theta = Winkeldaten, r = values_R)
  merged_data <- merge(data_L[c("theta", "r")], data_R[c("theta", "r")], by = "theta", all = FALSE)
  
  # Berechnung und Anpassung der Daten für das Plotten
  merged_data$r_avg <- rowMeans(merged_data[c("r.x", "r.y")])
  merged_data$r_avg <- ifelse(merged_data$r_avg >= 0, merged_data$r_avg + 1200, merged_data$r_avg - 1200)
  merged_data$color <- ifelse(merged_data$r_avg > 0, "#42BA97", "#EF5350")
  
  data_avg <- data.frame(theta = Winkeldaten, r = abs(merged_data$r_avg), color = merged_data$color)
  data_avg$Baseline <- 1200
  
  # Erstellung des ggplot-Plots für die aktuelle Intensität
  plot <- ggplot(data_avg, aes(x = theta, y = r, fill = color)) +
    geom_ribbon(aes(ymin = Baseline, ymax = r), alpha = 0.5) +
    geom_line(aes(color = color), size = 0.8) +
    geom_hline(yintercept = 1200, linetype = "solid", color = "black", size = 0.8) +
    scale_colour_manual(values = c("black", "black")) +
    scale_fill_manual(values = c("#42BA97", "#EF5350")) +
    coord_polar(start = 0) +
    scale_x_continuous(breaks = c(0, 90, 180, 270), labels = c("0", "90", "180", "270")) +
    theme(axis.text = element_text(color = "black", hjust = 0.2), axis.text.y = element_blank(), axis.ticks.y = element_blank(), 
          panel.grid = element_blank(), axis.title = element_blank(), panel.background = element_blank(), 
          legend.position = "none") +
    scale_y_continuous(limits = c(0, 2500))
  
  # Füge Text ein
  efficiency_value <- efficiency_values[intensity]
  plot <- plot + annotate("text", x = 180, y = 1800 * 1.1, label = paste("Eff:", efficiency_value,"%"), size = 4, color = "black")
  plot <- plot + annotate("text", x = 0, y = 1800 * 1.1, label = intensity, size = 4, color = "black", vjust = 0.5, hjust = 0.5)
  plot <- plot + annotate("text", x = 270, y = 1800 * 1.2, label = "P-", size = 4, color = "black")
  plot <- plot + annotate("text", x = 90, y = 1800 * 1.2, label = "P+", size = 4, color = "black")
  
  # Entferne den automatischen Titel
  plot <- plot + labs(title = NULL)
  
  # Füge den ggplot-Plot zur Liste der ggplot-Plots hinzu
  ggplot_plots[[intensity]] <- plot
}

# Erstellen Sie die finale Abbildung, indem Sie die ggplot-Plots nebeneinander anordnen
final_plot <- ggplot_plots[[1]] + ggplot_plots[[2]] + ggplot_plots[[3]]
p_Eff_Intensität <- final_plot
```

```{r}
#| label: fig-Eff_KD_Intensität
#| fig-cap: "Kreisförmige Darstellung der mittleren positiven (P+) und negativen (P-) Leistungsanteile mit resultierender Torque Efficiency während der Pedalzyklen in den drei Intensitätsstufen"
#| fig-cap-location: bottom

p_Eff_Intensität
```



### Bedingungen_Intensitäten


```{r}
P_R_list <- readRDS("rds/P_R_list.rds") 
P_L_list <- readRDS("rds/P_L_list.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")

# Proband 2 und 3 entfernen
Efficiency_Daten_df <- Efficiency_Daten_df %>%
  filter(!Proband %in% c(2, 3))

# Einträge die mit 02 oder 03 beginnen entfernen
P_L_list <- P_L_list[!grepl("^(02|03)_", names(P_L_list))]
P_R_list <- P_R_list[!grepl("^(02|03)_", names(P_R_list))]

# Gruppieren und Durchschnitt berechnen
Efficiency_Bed_Int_df <- Efficiency_Daten_df %>%
  group_by(Intensität, Bedingung) %>%
  summarise(Efficiency = round(mean(Efficiency, na.rm = TRUE), 2)) %>%
  mutate(intensity_condition = paste(Intensität, Bedingung, sep = "_")) 

# Leere Listen für die Durchschnittswerte erstellen
Bed_Int_list_L <- list()
Bed_Int_list_R <- list()

# Initialisiere die Durchschnittswerte für die verschiedenen Kombinationen von Intensität und Bedingung
mean_leicht_sitzen_L <- numeric(180)
mean_leicht_stehen_L <- numeric(180)
mean_moderat_sitzen_L <- numeric(180)
mean_moderat_stehen_L <- numeric(180)
mean_schwer_sitzen_L <- numeric(180)
mean_schwer_stehen_L <- numeric(180)

mean_leicht_sitzen_R <- numeric(180)
mean_leicht_stehen_R <- numeric(180)
mean_moderat_sitzen_R <- numeric(180)
mean_moderat_stehen_R <- numeric(180)
mean_schwer_sitzen_R <- numeric(180)
mean_schwer_stehen_R <- numeric(180)

# Iteriere über die Namen in P_L_list
for (name in names(P_L_list)) {
  # Prüfe, welche Kombination von Intensität und Bedingung im Namen vorkommt
  if (grepl("leicht_sitzen", name)) {
    mean_leicht_sitzen_L <- mean_leicht_sitzen_L + P_L_list[[name]]
  }
  if (grepl("leicht_stehen", name)) {
    mean_leicht_stehen_L <- mean_leicht_stehen_L + P_L_list[[name]]
  }
  if (grepl("moderat_sitzen", name)) {
    mean_moderat_sitzen_L <- mean_moderat_sitzen_L + P_L_list[[name]]
  }
  if (grepl("moderat_stehen", name)) {
    mean_moderat_stehen_L <- mean_moderat_stehen_L + P_L_list[[name]]
  }
  if (grepl("schwer_sitzen", name)) {
    mean_schwer_sitzen_L <- mean_schwer_sitzen_L + P_L_list[[name]]
  }
  if (grepl("schwer_stehen", name)) {
    mean_schwer_stehen_L <- mean_schwer_stehen_L + P_L_list[[name]]
  }
}

# Iteriere über die Namen in P_R_list
for (name in names(P_R_list)) {
  # Prüfe, welche Kombination von Intensität und Bedingung im Namen vorkommt
  if (grepl("leicht_sitzen", name)) {
    mean_leicht_sitzen_R <- mean_leicht_sitzen_R + P_R_list[[name]]
  }
  if (grepl("leicht_stehen", name)) {
    mean_leicht_stehen_R <- mean_leicht_stehen_R + P_R_list[[name]]
  }
  if (grepl("moderat_sitzen", name)) {
    mean_moderat_sitzen_R <- mean_moderat_sitzen_R + P_R_list[[name]]
  }
  if (grepl("moderat_stehen", name)) {
    mean_moderat_stehen_R <- mean_moderat_stehen_R + P_R_list[[name]]
  }
  if (grepl("schwer_sitzen", name)) {
    mean_schwer_sitzen_R <- mean_schwer_sitzen_R + P_R_list[[name]]
  }
  if (grepl("schwer_stehen", name)) {
    mean_schwer_stehen_R <- mean_schwer_stehen_R + P_R_list[[name]]
  }
}

# Berechne den Durchschnitt für die verschiedenen Kombinationen von Intensität und Bedingung über alle Datenpunkte
Bed_Int_list_L[["leicht_sitzen"]] <- mean_leicht_sitzen_L / sum(grepl("leicht_sitzen", names(P_L_list)))
Bed_Int_list_L[["leicht_stehen"]] <- mean_leicht_stehen_L / sum(grepl("leicht_stehen", names(P_L_list)))
Bed_Int_list_L[["moderat_sitzen"]] <- mean_moderat_sitzen_L / sum(grepl("moderat_sitzen", names(P_L_list)))
Bed_Int_list_L[["moderat_stehen"]] <- mean_moderat_stehen_L / sum(grepl("moderat_stehen", names(P_L_list)))
Bed_Int_list_L[["schwer_sitzen"]] <- mean_schwer_sitzen_L / sum(grepl("schwer_sitzen", names(P_L_list)))
Bed_Int_list_L[["schwer_stehen"]] <- mean_schwer_stehen_L / sum(grepl("schwer_stehen", names(P_L_list)))

Bed_Int_list_R[["leicht_sitzen"]] <- mean_leicht_sitzen_R / sum(grepl("leicht_sitzen", names(P_R_list)))
Bed_Int_list_R[["leicht_stehen"]] <- mean_leicht_stehen_R / sum(grepl("leicht_stehen", names(P_R_list)))
Bed_Int_list_R[["moderat_sitzen"]] <- mean_moderat_sitzen_R / sum(grepl("moderat_sitzen", names(P_R_list)))
Bed_Int_list_R[["moderat_stehen"]] <- mean_moderat_stehen_R / sum(grepl("moderat_stehen", names(P_R_list)))
Bed_Int_list_R[["schwer_sitzen"]] <- mean_schwer_sitzen_R / sum(grepl("schwer_sitzen", names(P_R_list)))
Bed_Int_list_R[["schwer_stehen"]] <- mean_schwer_stehen_R / sum(grepl("schwer_stehen", names(P_R_list)))

# Winkeldaten definieren
Winkeldaten <- seq(0, 358, by = 2)

# Liste der Intensitäts- und Bedingungskombinationen erstellen
intensity_conditions <- c("leicht_sitzen", "leicht_stehen", "moderat_sitzen", "moderat_stehen", "schwer_sitzen", "schwer_stehen")

efficiency_values <- Efficiency_Bed_Int_df$Efficiency
names(efficiency_values) <- Efficiency_Bed_Int_df$intensity_condition

# Filtern der Daten, um nur Werte über der Baseline zu behalten
data_avg <- data_avg[data_avg$r > data_avg$Baseline, ]
# Sortieren der Daten, sodass grüne Werte zuletzt geplottet werden
data_avg <- data_avg[order(data_avg$color == "#42BA97", decreasing = TRUE), ]

# Leere Liste für die ggplot-Plots erstellen
ggplot_plots <- list()

# Liste der Intensitäts- und Bedingungskombinationen erstellen
intensity_conditions <- c("leicht_sitzen", "leicht_stehen", "moderat_sitzen", "moderat_stehen", "schwer_sitzen", "schwer_stehen")

# Schleife über die Intensitäts- und Bedingungskombinationen
for (intensity_condition in intensity_conditions) {
  values_L <- Bed_Int_list_L[[intensity_condition]]
  values_R <- Bed_Int_list_R[[intensity_condition]]
  values_avg <- rowMeans(data.frame(P_R = values_R, P_L = values_L))
  adjusted_Winkeldaten <- (Winkeldaten + 180) %% 360
  
  # Vorbereitung der Datenrahmen für das Plotten
  data_L <- data.frame(theta = adjusted_Winkeldaten, r = values_L)
  data_R <- data.frame(theta = Winkeldaten, r = values_R)
  merged_data <- merge(data_L[c("theta", "r")], data_R[c("theta", "r")], by = "theta", all = FALSE)
  
  # Berechnung und Anpassung der Daten für das Plotten
  merged_data$r_avg <- rowMeans(merged_data[c("r.x", "r.y")])
  merged_data$r_avg <- ifelse(merged_data$r_avg >= 0, merged_data$r_avg + 800, merged_data$r_avg - 800)
  merged_data$color <- ifelse(merged_data$r_avg > 0, "#42BA97", "#EF5350")
  
  data_avg <- data.frame(theta = Winkeldaten, r = abs(merged_data$r_avg), color = merged_data$color)
  data_avg$Baseline <- 800
  
  # Erstellung des ggplot-Plots für die aktuelle Intensität und Bedingung
  plot <- ggplot(data_avg, aes(x = theta, y = r, fill = color)) +
    geom_ribbon(aes(ymin = Baseline, ymax = r), alpha = 0.65) +
    geom_point(aes(color = color), size = 0.3) +
    geom_hline(yintercept = 800, linetype = "solid", color = "black", size = 0.5) +
    geom_hline(yintercept = 800, linetype = "solid", color = "black", size = 0.5) +
    scale_colour_manual(values = c("black", "black")) +
    scale_fill_manual(values = c("#42BA97", "#EF5350")) +
    coord_polar(start = 0) +
    scale_x_continuous(breaks = c(0, 90, 180, 270), labels = c("0", "90", "180", "270")) +
    theme(axis.text = element_text(color = "black", hjust = 0.2), axis.text.y = element_blank(), axis.ticks.y = element_blank(), 
          panel.grid = element_blank(), axis.title = element_blank(), panel.background = element_blank(), 
          legend.position = "none") +
    scale_y_continuous(limits = c(0, 1800))
  
  # Füge Text ein
  efficiency_value <- efficiency_values[intensity_condition]
  plot <- plot + annotate("text", x = 178, y = 1300 * 1.1, label = paste("Eff:", efficiency_value,"%"), size = 4, color = "black")
  plot <- plot + annotate("text", x = 0, y = 1300 * 1.1, label = intensity_condition, size = 4, color = "black", vjust = 0.5, hjust = 0.5)
  plot <- plot + annotate("text", x = 270, y = 1300 * 1.2, label = "P-", size = 4, color = "black")
  plot <- plot + annotate("text", x = 90, y = 1300 * 1.2, label = "P+", size = 4, color = "black")
  
  # Entferne den automatischen Titel
  plot <- plot + labs(title = NULL)
  
  # Füge den ggplot-Plot zur Liste der ggplot-Plots hinzu
  ggplot_plots[[intensity_condition]] <- plot
}

# Erstellen Sie die finale Abbildung, indem Sie die ggplot-Plots nebeneinander anordnen
final_plot <- ggplot_plots[[1]] + ggplot_plots[[3]] + ggplot_plots[[5]] + ggplot_plots[[2]]  + ggplot_plots[[4]]  + ggplot_plots[[6]]
p_Eff_Bedingung_Intensität <- final_plot
```

```{r}
#| label: fig-Eff_KD_Bedingung_Intensität
#| fig-cap: "Kreisförmige Darstellung der mittleren positiven (P+) und negativen (P-) Leistungsanteile mit resultierender Torque Efficiency während der Pedalzyklen in den Bedingungen sowie drei Intensitätsstufen"
#| fig-cap-location: bottom

p_Eff_Bedingung_Intensität 
```


:::

## Zusammenhänge von Effizienzparametern der Tretbewegung und mechanischer Leistung { .unlisted }
Die nachstehenden Abbildungen zeigen die Zusammenhänge zwischen verschiedenen biomechanischen Parametern der Tretbewegung beim Radfahren. 
Die erste Analyse untersucht die Beziehung zwischen P~mech,kg~ und der Torque Efficiency und zeigt einen starken, signifikanten Zusammenhang (F~(1,52)~ = 112.80, p < .001, R² = 0.68). Dies deutet darauf hin, dass Probanden mit höheren P~mech,kg~ Werten in der letzten Stufe des Stufentests tendenziell auch höhere Torque Efficiency Werte aufweisen.<br>
Für die Pedal Smoothness zeigt sich ebenfalls ein signifikanter, wenn auch moderaterer Zusammenhang mit P~mech,kg~ (F~(1,52)~ = 28.56, p < .001, R² = 0.35). Die Daten legen nahe, dass leistungsstärkere Probanden möglicherweise eine gleichmäßigere Trittbewegung mit geringeren relativen Leistungsspitzen im Pedalzyklus aufweisen könnten.<br>
Der hochsignifikante positive Zusammenhang zwischen Pedal Smoothness und Torque Efficiency (F~(1,52)~ = 67.24, p < .001, R² = 0.56) könnte auf eine Verbindung dieser Parameter hinweisen. Die Daten deuten an, dass eine höhere Effizienz der Kraftübertragung mit einer gleichmäßigeren Tretbewegung einhergehen könnte. 

::: panel-tabset

### Torque Efficiency und P~mech~ { .unlisted }


```{r}
# Proband 2 und 3 entfernen
P_Ges_df <- P_Ges_df %>%
  filter(!Proband %in% c(2, 3))
# Lineare Regression und Modellzusammenfassung
lin_reg <- lm(Efficiency ~ W_kg, data = P_Ges_df)
summary_lin_reg <- summary(lin_reg)
f_stat <- summary_lin_reg$fstatistic
p_value <- format.pval(pf(f_stat["value"], f_stat["numdf"], f_stat["dendf"], lower.tail = FALSE), digits = 4)
equation_text <- sprintf("Torque Efficiency(P<sub>mech</sub>) = %.2f · P<sub>mech</sub> + %.2f", 
                         coef(lin_reg)["W_kg"], 
                         coef(lin_reg)["(Intercept)"])
r_squared_text <- sprintf("R² = %.2f", summary_lin_reg$r.squared)
f_stat_text <- sprintf("F (%d, %d) = %.2f, p = %s", f_stat["numdf"], f_stat["dendf"], f_stat["value"], p_value)
# Berechnung der Regressionsgeraden
w_kg_seq <- seq(min(P_Ges_df$W_kg), max(P_Ges_df$W_kg), length.out = 100)
regression_values <- predict(lin_reg, newdata = data.frame(W_kg = w_kg_seq))
# Erstellen des Plotly-Diagramms
p_TE_P_mech <- plot_ly() %>%
  add_markers(data = P_Ges_df, x = ~W_kg, y = ~Efficiency, type = 'scatter', mode = 'markers',
              color = ~factor(Proband), colors = colorRampPalette(brewer.pal(10,"Spectral"))(20),
              marker = list(size = 9, opacity = 0.8)) %>%
  layout(title = "Zusammenhang der Torque Efficiency [%] und P<sub>mech</sub> [W·kg<sup>-1</sup>]",
         margin = list(t = 40), 
         xaxis = list(title = "P<sub>mech</sub> [W·kg<sup>-1</sup>]"),
         yaxis = list(title = "Torque Efficiency [%]")) %>%
  add_lines(x = ~w_kg_seq, y = ~regression_values, name = "Regressionslinie", line = list(color = 'darkgrey', width = 2)) %>%
  add_annotations(text = equation_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Efficiency), 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = r_squared_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Efficiency) * 0.98, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = f_stat_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Efficiency) * 0.96, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom')
```

```{r}
#| label: fig-TE_P_mech
#| fig-cap: "Zusammenhang der Torque Efficiency [%] und P<sub>mech</sub> [W·kg<sup>-1</sup>]"
#| fig-cap-location: bottom

p_TE_P_mech
```



### Pedal Smoothness und P~mech~ { .unlisted }


```{r}
# Proband 2 und 3 entfernen
P_Ges_df <- P_Ges_df %>%
  filter(!Proband %in% c(2, 3))
# Lineare Regression
lin_reg <- lm(Pedal_Smoothness ~ W_kg, data = P_Ges_df)
reg_coefficients <- coef(lin_reg)
r_squared <- summary(lin_reg)$r.squared
equation_text <- sprintf("Pedal Smoothness(P<sub>mech</sub>) = %.2f · P<sub>mech</sub> + %.2f", 
                         coef(lin_reg)["W_kg"], 
                         coef(lin_reg)["(Intercept)"])
r_squared_text <- sprintf("R² = %.2f", r_squared)
summary_lin_reg <- summary(lin_reg)
f_stat <- summary_lin_reg$fstatistic
p_value <- format.pval(pf(f_stat["value"], f_stat["numdf"], f_stat["dendf"], lower.tail = FALSE), digits = 4)
f_stat_text <- sprintf("F (%d, %d) = %.2f, p = %s", f_stat["numdf"], f_stat["dendf"], f_stat["value"], p_value)

# Berechnung der Regressionsgeraden für eine Sequenz von W_kg
w_kg_seq <- seq(min(P_Ges_df$W_kg), max(P_Ges_df$W_kg), length.out = 100)
regression_values <- predict(lin_reg, newdata = data.frame(W_kg = w_kg_seq))

# Erstellen des Plotly-Diagramms mit Regressionsgerade und statistischen Informationen + ColorBrewer
p_PS_P_mech <- plot_ly() %>%
  add_markers(data = P_Ges_df, x = ~W_kg, y = ~Pedal_Smoothness, type = 'scatter', mode = 'markers',
              color = ~factor(Proband), colors = colorRampPalette(brewer.pal(10,"Spectral"))(20),
              marker = list(size = 9, opacity = 0.8)) %>%
  layout(title = "Zusammenhang der Pedal Smoothness [%] und P<sub>mech</sub> [W·kg<sup>-1</sup>]",
         margin = list(t = 40), 
         xaxis = list(title = "P<sub>mech</sub> [W·kg<sup>-1</sup>]"),
         yaxis = list(title = "Pedal Smoothness [%]")) %>%
  add_lines(x = ~w_kg_seq, y = ~regression_values, name = "Regressionslinie", line = list(color = 'darkgrey', width = 2)) %>%
  add_annotations(text = equation_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Pedal_Smoothness), 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = r_squared_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Pedal_Smoothness) * 0.98, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = f_stat_text, x = min(P_Ges_df$W_kg), y = max(P_Ges_df$Pedal_Smoothness) * 0.96, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom')
```

```{r}
#| label: fig-PS_P_mech
#| fig-cap: "Zusammenhang der Pedal Smoothness [%] und P<sub>mech</sub> [W·kg<sup>-1</sup>]"
#| fig-cap-location: bottom

p_PS_P_mech
```



### Pedal Smoothness und Torque Efficiency { .unlisted }


```{r}
# Proband 2 und 3 entfernen
P_Ges_df <- P_Ges_df %>%
  filter(!Proband %in% c(2, 3))

# Lineare Regression
lin_reg <- lm(Pedal_Smoothness ~ Efficiency, data = P_Ges_df)
reg_coefficients <- coef(lin_reg)
r_squared <- summary(lin_reg)$r.squared
equation_text <- sprintf("Pedal Smoothness(Efficiency) = %.2f · Efficiency + %.2f", 
                         reg_coefficients["Efficiency"], 
                         reg_coefficients["(Intercept)"])
r_squared_text <- sprintf("R² = %.2f", r_squared)
summary_lin_reg <- summary(lin_reg)
f_stat <- summary_lin_reg$fstatistic
p_value <- format.pval(pf(f_stat["value"], f_stat["numdf"], f_stat["dendf"], lower.tail = FALSE), digits = 4)
f_stat_text <- sprintf("F (%d, %d) = %.2f, p = %s", f_stat["numdf"], f_stat["dendf"], f_stat["value"], p_value)

# Berechnung der Regressionsgeraden für eine Sequenz von Efficiency
Efficiency_seq <- seq(min(P_Ges_df$Efficiency), max(P_Ges_df$Efficiency), length.out = 100)
regression_values <- predict(lin_reg, newdata = data.frame(Efficiency = Efficiency_seq))

# Erstellen des Plotly-Diagramms mit Regressionsgerade und statistischen Informationen + ColorBrewer
p_TE_PS <- plot_ly() %>%
  add_markers(data = P_Ges_df, x = ~Efficiency, y = ~Pedal_Smoothness, type = 'scatter', mode = 'markers',
              color = ~factor(Proband), colors = colorRampPalette(brewer.pal(10,"Spectral"))(20),
              marker = list(size = 9, opacity = 0.8)) %>%
  layout(title = "Zusammenhang der Pedal Smoothness und der Torque Efficiency",
         margin = list(t = 40), 
         xaxis = list(title = "Torque Efficiency [%]"),
         yaxis = list(title = "Pedal Smoothness [%]")) %>%
  add_lines(x = ~Efficiency_seq, y = ~regression_values, name = "Regressionslinie", line = list(color = 'darkgrey', width = 2)) %>%
  add_annotations(text = equation_text, x = min(P_Ges_df$Efficiency), y = max(P_Ges_df$Pedal_Smoothness), 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = r_squared_text, x = min(P_Ges_df$Efficiency), y = max(P_Ges_df$Pedal_Smoothness) * 0.98, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom') %>%
  add_annotations(text = f_stat_text, x = min(P_Ges_df$Efficiency), y = max(P_Ges_df$Pedal_Smoothness) * 0.96, 
                  showarrow = FALSE, xanchor = 'left', yanchor = 'bottom')
```

```{r}
#| label: fig-TE_PS
#| fig-cap: "Zusammenhang der Pedal Smoothness und der Torque Efficiency"
#| fig-cap-location: bottom

p_TE_PS
```


:::

## Interaktive Analyse der Zusammenhänge ausgewählter verschiedener Leistungsparameter mittels linearer Regression
Die folgende Shiny-App bietet die Möglichkeit zur Analyse von weiteren Zusammenhängen ausgewählter Leistungsparameter. In der Seitenleiste können die ausgewählten Daten nach Probanden, Intensitäten und Bedingungen gefiltert werden. Die Auswahl der x- und y-Achse definiert die Variablen für die Regressionsanalyse. Es wird ein interaktives Streudiagramm mit Regressionslinie erstellt, das den linearen Zusammenhang der gewählten Parameter darstellt. Die Anwendung analysiert verschiedene anthropometrische sowie physiologische und ergometrische Leistungsparameter. Für jede Parameterkombination erfolgt eine lineare Regressionsanalyse mit Regressionsgleichung, Bestimmtheitsmaß (R^2^) und statistischer Signifikanz.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 750
library(shiny)
library(plotly)
library(dplyr)
library(broom)
library(RColorBrewer)
library(DT)

# Spalten umbenennen
names(Bedingungen_data)[names(Bedingungen_data) == "W*Aerob [kJ]"] <- "W_Aerob"
names(Bedingungen_data)[names(Bedingungen_data) == "WPCR [kJ]"] <- "W_PCR"
names(Bedingungen_data)[names(Bedingungen_data) == "WBLC [kJ]"] <- "W_BLC"
names(Bedingungen_data)[names(Bedingungen_data) == "WTOT [kJ]"] <- "W_TOT"
names(Bedingungen_data)[names(Bedingungen_data) == "Efficiency"] <- "Torque_Efficiency"

Bedingungen_data$P_mech_kg <- Bedingungen_data$P_mech / Bedingungen_data$Masse
Bedingungen_data$VO2_max <- Bedingungen_data$VO2_kg_max * Bedingungen_data$Masse

# Auswahl der gewünschten Variablen
Bedingungen_data_Shiny_Regression_vars <- c("Proband", "Nr", "Bedingung", "Intensität", 
                                             "Torque_Efficiency", "Pedal_Smoothness", 
                                             "Wirk_Brutto", "Wirk_Netto", "Wirk_Total", "Wirk_Muskulär",
                                             "Masse", "P_mech", "nD", "VO2_kg_max", "HR_percent", "VO2_percent", 
                                             "VO2_avg", "VO2_net_SS", "W_Aerob", "W_PCR", "W_TOT", "W_BLC")

# Erstellen des Datensatzes für Shiny-Regression
Bedingungen_data_Shiny_Regression <- Bedingungen_data[, Bedingungen_data_Shiny_Regression_vars]

# Bedingungen_data_Shiny_Regression manuell erstellen
Bedingungen_data_Shiny_Regression <- data.frame(
  `Proband` = c( "01", "01", "01", "01", "01", "01", "06", "06", "06", "06", "06", "06", "10", "10", "10", "10", "10", "10", "13", "13", "13", "13", "13", "13", "15", "15", "15", "15", "15", "15", "19", "19", "19", "19", "19", "19", "20", "20", "20", "20", "20", "20", "22", "22", "22", "22", "22", "22", "23", "23", "23", "23", "23", "23" ),
  `Nr` = c( 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6 ),
  `Bedingung` = c( "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "sitzen", "stehen", "sitzen", "stehen", "stehen", "sitzen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen", "sitzen", "stehen", "stehen", "sitzen" ),
  `Intensität` = c( "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer", "leicht", "leicht", "moderat", "moderat", "schwer", "schwer" ),
  `Torque_Efficiency` = c( 66.42, 80.67, 85.6, 72.95, 87.65, 78.67, 80.04, 86.41, 86.78, 88.63, 88.24, 92.41, 73.99, 73.77, 81.11, 85.39, 91.79, 84.47, 72.05, 72.34, 79.17, 76.95, 79.78, 85.17, 66.52, 69.93, 72.41, 82.58, 87.01, 79.53, 65.43, 72.54, 77.02, 70.47, 80.77, 78.76, 64.47, 62.05, 68.4, 71.35, 77.44, 75.1, 81.99, 82.22, 91.47, 89.76, 92.56, 97.11, 50.58, 59.59, 65.12, 56.31, 63.19, 72.06 ),
  `Pedal_Smoothness` = c( 39.710181579574, 50.8184514296743, 52.4428359792181, 40.2055948041026, 53.6791852731242, 41.0448765909455, 47.914882163269, 51.5335837768147, 49.217483982331, 51.1389458112447, 48.0336788998195, 52.8223258874823, 47.9302436519206, 51.9475600881879, 54.0606647605687, 50.6559277814877, 52.6335181401208, 54.2725782631366, 43.083675000186, 49.0637500123524, 44.6632810590617, 50.293760020264, 51.2896166830574, 46.4638901013413, 48.3291073423363, 44.2590599394396, 52.6720469537052, 47.4439436135393, 48.2471522363413, 57.9737846304978, 42.4301080469913, 50.2908406548503, 52.3570034648903, 42.7127745966365, 52.2685711057555, 44.7936090146139, 46.3565980135841, 38.3575726240913, 39.6615373251182, 49.3105354600425, 42.1880618813037, 51.4796995926358, 54.4350155934243, 49.538139286023, 51.844375965857, 57.5052389013286, 57.6775357922151, 52.6180510620694, 32.375968743603, 42.0671208740445, 44.8980312830359, 34.1636884387502, 36.5443594656413, 47.3128113809467 ),
  `Wirk_Brutto` = c( 0.21091819774276, 0.218687083170556, 0.218760618322075, 0.215611035633622, 0.214547147778117, 0.218930425263281, 0.227778316752638, 0.221045746532832, 0.241032841135073, 0.231877904887968, 0.241135116972538, 0.237391436703597, 0.231766180410934, 0.235455654830026, 0.225781269887199, 0.237080456805955, 0.238940307096781, 0.22236502148504, 0.223093734025061, 0.221665349290325, 0.225584494767251, 0.224321087908687, 0.226863452429123, 0.228356628526559, 0.210066541077549, 0.215613658605269, 0.214257766456576, 0.225374565032104, 0.226632861157903, 0.225342311634305, 0.202757163964259, 0.220274153111015, 0.221156816095123, 0.2037476019667, 0.219912947132494, 0.211113698805482, 0.231505614168667, 0.234285612923503, 0.235567631959634, 0.222650724211751, 0.231727760126706, 0.219734608022672, 0.225208598362406, 0.23752066449308, 0.24609162628488, 0.235239077451739, 0.23507782711413, 0.257565789353377, 0.196493707208499, 0.20725848437317, 0.212413076069613, 0.205403057940064, 0.218886073914972, 0.222063328733195 ),
  `Wirk_Netto` = c( 0.235366208704023, 0.24575401991436, 0.243091404958539, 0.238518403096868, 0.235435907276559, 0.240279695180822, 0.255934451435372, 0.248097421797994, 0.269612985904083, 0.258824217026203, 0.267696887307786, 0.264544459494061, 0.259459192084525, 0.264732681287629, 0.248201900922679, 0.261299577904801, 0.261524156177508, 0.242125397562104, 0.251321138621137, 0.250186487127734, 0.251530175390694, 0.250643819041199, 0.251705746605124, 0.25286873845261, 0.235236336194875, 0.242214059349332, 0.23731394539996, 0.249555183341606, 0.249068360041437, 0.247347607416278, 0.221558994244514, 0.243163021575891, 0.242168848169494, 0.221339658358084, 0.238068303279725, 0.227659204021592, 0.25865339661502, 0.263730596001978, 0.261320891591058, 0.245994762806019, 0.253547895823224, 0.239800952281731, 0.248645123409885, 0.263685769900833, 0.270630156183426, 0.257261586154533, 0.255302073344076, 0.281816507813529, 0.229914263078336, 0.245377374830505, 0.246568081428814, 0.237160085395944, 0.250569512513164, 0.254821599878365 ),
  `Wirk_Total` = c( 0.215050980096665, 0.218361213965118, 0.21743918934395, 0.210231759369089, 0.210052326032456, 0.220565206870156, 0.224120419796381, 0.220781351398079, 0.236416282347832, 0.222476343746092, 0.227738869937329, 0.224836096783589, 0.238697915485563, 0.233601219961414, 0.217999410562797, 0.230984992520443, 0.227076019064188, 0.214502300481599, 0.225555773878964, 0.219352301338166, 0.219846792958958, 0.220428214984546, 0.218092136279684, 0.220946373711054, 0.213005949212925, 0.218400909748379, 0.213344733685403, 0.225400741075485, 0.219843269599878, 0.218616391702131, 0.199460121420396, 0.220446212520149, 0.212466511624337, 0.197689880977766, 0.207646479631449, 0.198013299225654, 0.233318299679759, 0.239375318086974, 0.234519392583452, 0.220198847250673, 0.227970762256012, 0.214722135551155, 0.227447147538819, 0.239548486250032, 0.247162950474793, 0.234763503071659, 0.2229381955183, 0.24282867143177, 0.207891012768686, 0.228081605080525, 0.224262888819237, 0.211157426124462, 0.219182082639067, 0.227004603734556 ),
  `Wirk_Muskulär` = c( 0.236759931308537, 0.246060440608401, 0.242278598743508, 0.229631619431488, 0.231738880422805, 0.239606281503452, 0.235519448379419, 0.240751242958341, 0.248138483274488, 0.238973954766177, 0.239905278154682, 0.242987590176426, 0.253197378567756, 0.268813524126113, 0.246034674712508, 0.243007190386035, 0.237707989694929, 0.239357891786449, 0.246622974378944, 0.259752672010051, 0.237157651346767, 0.256082449948023, 0.248047661517146, 0.237373974289561, 0.25603524395526, 0.230241128289079, 0.252398922767891, 0.237853768450825, 0.236244609842595, 0.256844301131177, 0.229409310695982, 0.250592406029218, 0.239641017649487, 0.225830203382915, 0.230325301880732, 0.22455381609002, 0.2675313748833, 0.254378184934767, 0.247600833815352, 0.250156276904196, 0.239017863265009, 0.241462546103667, 0.252453992795637, 0.255683248260526, 0.261633090232167, 0.257132037314701, 0.242104726162168, 0.256054300732916, 0.235970111612527, 0.269069913213186, 0.259743624458201, 0.236785575354483, 0.242749525282335, 0.259138280507211 ),
  `Masse` = c( 76, 76, 76, 76, 76, 76, 73, 73, 73, 73, 73, 73, 82, 82, 82, 82, 82, 82, 72, 72, 72, 72, 72, 72, 76, 76, 76, 76, 76, 76, 65, 65, 65, 65, 65, 65, 80, 80, 80, 80, 80, 80, 48, 48, 48, 48, 48, 48, 60, 60, 60, 60, 60, 60 ),
  `P_mech` = c( 286.196809943666, 279.856121744776, 308.058185037385, 316.422860962335, 340.826183919876, 347.288435475183, 277.240209227733, 271.455328132766, 304.467347747788, 298.231190808954, 325.412992360824, 309.694617397985, 323.150737156769, 316.844325140231, 371.96441826512, 380.655666884463, 411.774528793808, 405.478497575611, 300.611680063499, 294.276254054958, 330.974610194196, 323.263418911815, 347.877528040632, 356.523758791993, 264.042555125073, 264.046097801302, 296.595675684983, 312.821367725728, 338.374812212103, 340.655624979066, 222.299144497093, 217.725388710054, 237.149862110928, 238.510476030676, 268.299540676442, 270.26756043723, 259.609504812067, 246.984706949108, 281.340838183762, 276.152650787485, 316.924535968906, 309.069638160985, 220.907452101768, 221.311649982903, 250.936106797992, 254.071699215572, 274.36729230484, 276.737918099592, 175.467181480606, 173.18153762583, 199.048429239061, 199.114857295449, 224.703097248925, 224.226593365666 ),
  `nD` = c( 76.6564376505317, 86.4007340902643, 86.151834718222, 76.9699534010204, 86.1492001342774, 77.7545030427186, 59.6696464126312, 79.340733311971, 59.0120747230942, 78.6315332132975, 58.5778147794659, 74.8376014062797, 64.4031353722102, 93.4309539387749, 93.4798136132308, 64.6513676939208, 63.9226666971842, 92.926017486389, 76.1787191980119, 100.725884150632, 76.4965310227163, 100.706804663599, 101.493737868195, 76.2895930915614, 94.9222147345463, 67.3025317640006, 95.6908060743521, 67.7563334376017, 68.9089393183102, 97.2326216948995, 82.3157999725342, 85.1151334584554, 84.9867423386037, 82.4121919818754, 85.6636667989095, 82.5434000701904, 88.3525337219238, 59.2843333028158, 59.6458305272363, 87.9682001902262, 59.0753999888102, 88.6749836398094, 86.1743334757487, 65.9431711942811, 65.5106667200724, 86.0812543343512, 85.3489333648682, 66.2728181161696, 75.2098000386556, 87.7106668141683, 88.0529021962314, 75.7959332733154, 75.7891333821615, 88.2820788795832 ),
  `VO2_kg_max` = c( 74.4, 74.4, 74.4, 74.4, 74.4, 74.4, 67.8, 67.8, 67.8, 67.8, 67.8, 67.8, 75.4, 75.4, 75.4, 75.4, 75.4, 75.4, 72, 72, 72, 72, 72, 72, 70.1, 70.1, 70.1, 70.1, 70.1, 70.1, 72.2, 72.2, 72.2, 72.2, 72.2, 72.2, 69.4, 69.4, 69.4, 69.4, 69.4, 69.4, 81.2, 81.2, 81.2, 81.2, 81.2, 81.2, 67.9, 67.9, 67.9, 67.9, 67.9, 67.9 ),
  `HR_percent` = c( 87.37, 85.07, 88.4, 90.93, 93.12, 93.78, 88.05, 88.16, 92.21, 91.97, 95.39, 93.58, 84.41, 84.65, 88.64, 89.98, 91.12, 94.04, 89.19, 89.26, 92.25, 92.32, 93.98, 94.9, 86.65, 87.88, 89.95, 91.14, 93.96, 94.27, 90.9, 86.55, 87.59, 91.62, 91.13, 95.12, 86.77, 87.49, 90.8, 89.74, 93.35, 94.18, 80.64, 81.03, 84.87, 88.21, 91.54, 92.47, 91.92, 88.36, 90.08, 92.49, 93.58, 93.31 ),
  `VO2_percent` = c( 71.27, 66.6, 72.84, 76.05, 83.97, 83.1, 73.17, 73.36, 75.13, 76.76, 82.17, 80.02, 65.96, 64.11, 76.98, 75.53, 81.19, 87.7, 77.06, 75.21, 82.91, 81.14, 86.2, 88.05, 69.58, 67.18, 76.09, 77.01, 83.24, 82.99, 68.97, 61.94, 67.21, 72.61, 75.89, 79.96, 59.98, 55.95, 63.85, 65.63, 72.7, 75.69, 74.64, 71.07, 77.24, 82.44, 89.64, 82.88, 64.16, 59.83, 66.38, 68.75, 72.98, 72.62 ),
  `VO2_avg` = c( 4.032, 3.768, 4.124, 4.28, 4.716, 4.705, 3.609, 3.626, 3.699, 3.783, 4.06, 3.944, 4.176, 3.944, 4.733, 4.652, 4.961, 5.401, 3.965, 3.902, 4.327, 4.195, 4.45, 4.554, 3.728, 3.61, 4.073, 4.095, 4.41, 4.485, 3.232, 2.946, 3.158, 3.407, 3.566, 3.743, 3.324, 3.125, 3.542, 3.637, 4.053, 4.185, 2.929, 2.802, 3.074, 3.208, 3.505, 3.222, 2.637, 2.436, 2.702, 2.802, 2.968, 2.96 ),
  `VO2_net_SS` = c( 4.004, 3.712, 4.167, 4.276, 4.986, 4.818, 3.509, 3.494, 3.652, 3.705, 4.014, 4.092, 4.042, 4.027, 4.776, 4.634, 5.108, 5.576, 3.858, 3.746, 4.22, 4.065, 4.479, 4.536, 3.587, 3.466, 3.964, 4.101, 4.406, 4.572, 3.182, 2.837, 3.145, 3.397, 3.596, 3.779, 3.279, 2.99, 3.517, 3.643, 4.162, 4.323, 2.776, 2.645, 2.962, 3.143, 3.468, 3.188, 2.384, 2.211, 2.493, 2.591, 2.812, 2.784 ),
  `W_Aerob` = c( 364.789166022847, 341.629555246705, 380.175743058369, 397.985468023398, 434.291677759482, 433.605222297912, 324.974079503018, 328.244436599334, 338.782659218172, 345.676143718918, 364.680735327353, 257.547695226202, 373.643424879889, 359.053884392895, 449.590938122183, 437.033618580678, 472.355442968317, 502.398965566933, 358.837718601139, 352.868283295468, 394.753364696823, 386.919677670582, 414.624059322391, 422.974893188083, 336.736950672026, 327.040591917684, 374.940893404024, 376.054742927363, 407.568603441812, 413.170309433097, 301.002193914676, 268.616569204091, 293.782454560316, 323.273033581013, 338.095668739063, 356.147551686419, 301.108945263692, 280.951141839367, 322.983175747043, 336.778695169108, 374.987772949063, 386.657728278586, 266.533422098459, 251.790208549518, 278.168675291213, 296.280182766526, 322.403130586883, 294.593727223427, 228.955584309471, 211.732892340367, 242.182720592561, 251.873990890611, 269.030850954527, 263.980675271676 ),
  `W_PCR` = c( 24.1291998261524, 31.245535169392, 29.1930235666251, 40.7334747429318, 32.1503897341314, 31.0960321619306, 35.5542282425247, 29.8757643229022, 32.3919515398355, 37.4564805468453, 39.181054527315, 28.0856376372225, 25.6241011760421, 42.2362045296838, 43.8865576245131, 46.7522391886717, 55.8553450423781, 41.2539914795555, 33.5030632789753, 39.5610791298099, 47.0313952643199, 43.4984491855838, 48.5683623835727, 47.4643724094369, 28.7114346014479, 27.082865453765, 33.5487723155105, 28.4952050444725, 46.7129326531457, 36.4259657605345, 26.4583220374129, 20.1814127976726, 29.9859705398912, 25.6937955351603, 32.5159707007087, 35.3146550491163, 26.041151647366, 18.4426421779503, 25.8050373268292, 31.1359690227005, 24.1696808725351, 31.9239901224492, 18.2312728474559, 19.2851143909574, 15.5481731391339, 15.0049470739965, 26.5074844823288, 32.024059076605, 19.4890043814307, 11.8721280138382, 16.7847021024629, 20.5569026538069, 25.1374379120318, 20.8232926492238 ),
  `W_TOT` = c( 399.249717181043, 384.486031190706, 425.026674308594, 451.534337978137, 486.77325839355, 472.361584680434, 371.104350259043, 368.856327421404, 386.353272360279, 402.152227675927, 428.665944180332, 303.033262017248, 406.141884187901, 406.904114446707, 511.87902385356, 494.390128203813, 544.013230226759, 567.096711781505, 399.827955933609, 402.470708891198, 451.643536491319, 439.95740599879, 478.52829630846, 484.086368294384, 371.880535873387, 362.699172964313, 417.065381312399, 416.353601456395, 461.749153605597, 467.47037904168, 334.351262168179, 296.297295681804, 334.852575539387, 361.946410485473, 387.629312790631, 409.468800571675, 333.805156091563, 309.536558225317, 359.894550831632, 376.231739042368, 417.059450298718, 431.818038742475, 291.374221869366, 277.160987465275, 304.579759607115, 324.673591795083, 369.20630625942, 341.89280425728, 253.210342011047, 227.788914715005, 266.270220124784, 282.890629446418, 307.556750821119, 296.32869511474 ),
  `W_BLC` = c( 10.3313513320441, 11.610940774608, 15.6579076836, 12.815395211808, 20.331190899936, 7.660330220592, 10.5760425135007, 10.736126499168, 15.178661602272, 19.019603410164, 24.804154325664, 17.399929153824, 6.87435813197033, 5.614025524128, 18.401528106864, 10.604270434464, 15.802442216064, 23.443754735016, 7.48717405349485, 10.04134646592, 9.858776530176, 9.539279142624, 15.335874602496, 13.647102696864, 6.43215059991284, 8.575715592864, 8.575715592864, 11.80365348456, 7.46761751064, 17.874103848048, 6.89074621609046, 7.49931368004, 11.08415043918, 12.9795813693, 17.01767335086, 18.00659383614, 6.65505918050507, 10.142774208, 11.10633775776, 8.31707485056, 17.90199647712, 13.23632034144, 6.60952692345146, 6.0856645248, 10.862911176768, 13.38846195456, 20.295691190208, 15.275017957248, 4.76575332014558, 4.1838943608, 7.30279742976, 10.459735902, 13.38846195456, 11.52472719384 )
  , check.names = FALSE
)

# Auswahl der gewünschten Variablen
selected_vars <- c("Torque_Efficiency", "Pedal_Smoothness", 
                   "Wirk_Brutto", "Wirk_Netto", "Wirk_Total", "Wirk_Muskulär",
                   "W_Aerob", "W_PCR", "W_TOT", "W_BLC",
                   "Masse", "nD", 
                   "P_mech", "P_mech_kg", "VO2_max", "VO2_kg_max", "VO2_avg", "VO2_net_SS", "HR_percent", "VO2_percent")

# Datenbereinigung
Bedingungen_data_Shiny_Regression<- Bedingungen_data_Shiny_Regression%>%
  # Konvertiere Proband zu Faktor
  mutate(Proband = as.factor(Proband),
         Bedingung = as.factor(Bedingung),
         Intensität = as.factor(Intensität))

# UI
ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .well {
        max-height: 70vh;  /* Begrenzen Sie die Höhe auf 70% der Viewporthöhe */
        overflow-y: auto;  /* Ermöglichen Sie vertikales Scrollen */
        overflow-x: hidden; /* Verstecken Sie horizontales Scrollen */
      }
    "))
  ),
  
  titlePanel("Interaktive Regressionsanalyse"),
  
  fluidRow(
    column(3,
           wellPanel(
             selectInput("x_variable", "X-Achse:", 
                         choices = selected_vars,
                         selected = "Torque_Efficiency"),  # Standard X-Achse
             selectInput("y_variable", "Y-Achse:", 
                         choices = selected_vars,
                         selected = "Wirk_Total"),  # Standard Y-Achse
             
             checkboxGroupInput("selectedBedingung", "Bedingungen:",
                                choices = levels(Bedingungen_data_Shiny_Regression$Bedingung),
                                selected = levels(Bedingungen_data_Shiny_Regression$Bedingung)),
             
             checkboxGroupInput("selectedIntensität", "Intensitäten:",
                                choices = levels(Bedingungen_data_Shiny_Regression$Intensität),
                                selected = levels(Bedingungen_data_Shiny_Regression$Intensität)),
             
             checkboxGroupInput("selectedProband", "Probanden:",
                                choices = levels(Bedingungen_data_Shiny_Regression$Proband),
                                selected = levels(Bedingungen_data_Shiny_Regression$Proband))
           )
    ),
    column(9,
           plotlyOutput("regressionPlot", height = "calc(65vh - 150px)")
    )
  ),
  
  fluidRow(
    column(12,
           DTOutput("summaryTable"),
           br(), br()
    )
  )
)

server <- function(input, output, session) {
  
  filtered_data <- reactive({
    req(input$x_variable, input$y_variable)
    
    Bedingungen_data_Shiny_Regression%>%
      filter(Proband %in% input$selectedProband,
             Bedingung %in% input$selectedBedingung,
             Intensität %in% input$selectedIntensität)
  })
  
  # Regression Modell
  regression_model <- reactive({
    data <- filtered_data()
    
    # Sicherstellen, dass Variablen numerisch sind
    x_var <- input$x_variable
    y_var <- input$y_variable
    
    formula <- as.formula(paste(y_var, "~", x_var))
    
    # Fehlerbehandlung für Regression
    tryCatch({
      lm(formula, data = data)
    }, error = function(e) {
      message("Fehler bei der Regressionsberechnung: ", e$message)
      NULL
    })
  })
  
  output$regressionPlot <- renderPlotly({
    req(input$x_variable, input$y_variable)
    
    data <- filtered_data()
    
    # Prüfe, ob genug Datenpunkte vorhanden sind
    req(nrow(data) > 2)
    
    # Lineare Regression
    lin_reg <- regression_model()
    
    req(!is.null(lin_reg))
    
    # Regressionsstatistiken
    reg_summary <- summary(lin_reg)
    reg_coefficients <- coef(lin_reg)
    
    # Formatierte Regressionsergebnisse
    equation_text <- sprintf("%s(%s) = %.4f · %s + %.4f", 
                             input$y_variable,
                             input$x_variable,
                             reg_coefficients[input$x_variable], 
                             input$x_variable,
                             reg_coefficients["(Intercept)"])
    r_squared_text <- sprintf("R² = %.4f", reg_summary$r.squared)
    
    # F-Statistik und p-Wert
    f_stat <- reg_summary$fstatistic
    p_value <- pf(f_stat["value"], f_stat["numdf"], f_stat["dendf"], lower.tail = FALSE)
    f_stat_text <- sprintf("F (%d, %d) = %.4f, p = %.4f", 
                           f_stat["numdf"], f_stat["dendf"], 
                           f_stat["value"], p_value)
    
    # Sequenz für Regressionslinie
    x_seq <- seq(min(data[[input$x_variable]], na.rm = TRUE), 
                 max(data[[input$x_variable]], na.rm = TRUE), 
                 length.out = 100)
    regression_data <- data.frame(x = x_seq)
    names(regression_data) <- input$x_variable
    regression_values <- predict(lin_reg, newdata = regression_data)
    
    # Plotly-Diagramm
    plot_ly() %>%
      add_markers(data = data, 
                  x = as.formula(paste0("~", input$x_variable)), 
                  y = as.formula(paste0("~", input$y_variable)), 
                  type = 'scatter', 
                  mode = 'markers',
                  color = ~Proband, 
                  colors = colorRampPalette(brewer.pal(10,"Spectral"))(length(unique(data$Proband))),
                  marker = list(size = 9, opacity = 0.8)) %>%
      layout(
        title = paste(input$y_variable, "vs.", input$x_variable),
        margin = list(t = 40), 
        xaxis = list(title = input$x_variable),
        yaxis = list(title = input$y_variable)
      ) %>%
      add_lines(x = ~x_seq, y = ~regression_values, 
                name = "Regressionslinie", 
                line = list(color = 'darkgrey', width = 2)) %>%
      add_annotations(
        text = equation_text, 
        x = min(data[[input$x_variable]], na.rm = TRUE), 
        y = max(data[[input$y_variable]], na.rm = TRUE), 
        showarrow = FALSE, 
        xanchor = 'left', 
        yanchor = 'bottom'
      ) %>%
      add_annotations(
        text = r_squared_text, 
        x = min(data[[input$x_variable]], na.rm = TRUE), 
        y = min(data[[input$y_variable]], na.rm = TRUE) + 
          (max(data[[input$y_variable]], na.rm = TRUE) - 
             min(data[[input$y_variable]], na.rm = TRUE)) * 0.94, 
        showarrow = FALSE, 
        xanchor = 'left', 
        yanchor = 'bottom'
      ) %>%
      add_annotations(
        text = f_stat_text, 
        x = min(data[[input$x_variable]], na.rm = TRUE), 
        y = min(data[[input$y_variable]], na.rm = TRUE) + 
          (max(data[[input$y_variable]], na.rm = TRUE) - 
             min(data[[input$y_variable]], na.rm = TRUE)) * 0.88, 
        showarrow = FALSE, 
        xanchor = 'left', 
        yanchor = 'bottom'
      )
  })
  
  # Platzhalter für summaryTable
  output$summaryTable <- renderDT({
    # Hier können Sie später die Tabelle implementieren
    NULL
  })
}

shinyApp(ui, server)
```

# Innere Arbeit
In diesem Kapitel wird die innere Leistung (P~Int~) während der Tretbewegung anhand verschiedener methodischer Ansätze analysiert und verglichen. Zunächst wird der Verlauf der modellierten inneren Leistung über den Pedalzyklus betrachtet, gefolgt von Berechnungen basierend auf 3D-Kinematik-Daten. Zudem wird der Einfluss von Körpermasse und Trittrate auf die innere Leistung systematisch untersucht.



```{r}
# Library und dfs laden
library(plotly)
library(ggplot2)
library(dplyr)
library(tidyr)
library(htmltools)
library(htmlwidgets)
library(shiny)
library(DT)
library(RColorBrewer)
library(patchwork)
library(minpack.lm)
library(zoo)
library(purrr)
library(readxl)
library(minpack.lm) 

EPOC_data_df <- readRDS("rds/EPOC_data_df.rds")
Erg_data_df <- readRDS("rds/Erg_data_df.rds")
Erg_data_komplett <- readRDS("rds/Erg_data_komplett.rds")
Messwerte_Bedingungen_df <- readRDS("rds/Messwerte_Bedingungen_df.rds")
Messwerte_Intensitäten_df <- readRDS("rds/Messwerte_Intensitäten_df.rds")
Messwerte_Bedingung_Intensität_df <- readRDS("rds/Messwerte_Bedingung_Intensität_df.rds")
Bedingungen_data <- readRDS("rds/Bedingungen_data.rds")
P_Ges_df <- readRDS("rds/Efficiency_Daten_df.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_Int_Drehzahl_Masse <- readRDS("rds/P_Int_Drehzahl_Masse.rds")
Simulation_df <- readRDS("rds/Simulation_df.rds")
ΔBLC_list <- readRDS("rds/BLC_list.rds")
proband_data <- readRDS("rds/proband_data.rds")
ΔBLC_data_df <- readRDS("rds/BLC_data_df.rds")
BLC_Modell_list <- readRDS("rds/BLC_Modell_list.rds")
Efficiency_Daten_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_R_list <- readRDS("rds/P_R_list.rds")
P_L_list <- readRDS("rds/P_L_list.rds")
start_vals_list <- readRDS("rds/start_vals_list.rds")
VO2_list <- readRDS("rds/VO2_list.rds")
df_anthropometrisch_female <- readRDS("rds/df_anthropometrisch_female.rds")
df_anthropometrisch_male <- readRDS("rds/df_anthropometrisch_male.rds")
Kinematik_list <- readRDS("rds/Kinematik_list.rds")
```




## Verlauf der modellierten inneren Leistung im Pedalzyklus { .unlisted }


```{r echo=FALSE, output=FALSE}

# Neue Spalten für die berechnete Leistung und den verwendeten Faktor 
Erg_data_df$Faktor_Used <- NA  
Erg_data_df$PInt_Modell <- NA

# ------------ Berechnungen_P_Int ----------
# Initialisiere die Liste für Dataframes
PInt_list <- list()

# ------------ Eingabeparameter ------------ 
# Schleife über alle Zeilen in Erg_data_df
for(i in 1:nrow(Erg_data_df)) {
  # Übernahme der Werte aus der aktuellen Zeile...
  Masse <- as.numeric(Erg_data_df[i, 'Masse'])
  lOS <- as.numeric(Erg_data_df[i, 'lOS'])
  lUS <- as.numeric(Erg_data_df[i, 'lUS'])
  lBein <- as.numeric(Erg_data_df[i, 'lBein'])
  lKurbel <- as.numeric(Erg_data_df[i, 'lKurbel'])
  uOS <- as.numeric(Erg_data_df[i, 'uOS'])
  uUS <- as.numeric(Erg_data_df[i, 'uUS'])
  nD <- as.numeric(Erg_data_df[i, 'nD'])
  Umdrehungen_ges <- as.numeric(Erg_data_df[i, 'Umdrehungen_ges'])
  nD_HZ <- as.numeric(Erg_data_df[i, 'nD_Hz'])
  Testdauer <- 300

  # Konstanten und weitere Berechnungen
  Faktor <- 1.00 # Faktor zur Anpassung des Abstandes vom Hüftgelenk zur Kurbelachse
  S <- lBein * 0.883 * Faktor # Abstand vom Hüftgelenk zur Kurbelachse - Lemond Methode
  P3x <- -0.150 # x-Koordinate von P3 (Oberflächenrepräsentant der Hüfte) [m]
  P3y <- sqrt((S^2)-(P3x^2)) # y-Koordinate von P3 (Oberflächenrepräsentant der Hüfte) [m]
  P3 <- c(P3x,P3y) # kartesische Koordinaten P3 (Oberflächenrepräsentant der Hüfte) [m]
  rRelOS <- 0.1416 # relative Segmentmasse OS
  rRelUS <- 0.0433 # relative Segmentmasse US
  lambdaOS <- 0.4095 # Abstand zw. dem proximalen Punkt des Oberschenkelsegments und dessen Schwerpunkt
  lambdaUS <- 0.4459 # Abstand proximaler Segmentpunkt - Schwerpunkt
  thetaKurbel <- 0.002 # Trägheitsmoment der Fahrradkurbel [kg m^2]
  n <- 360 # Anzahl Messwerte pro Umdrehung
  delta_t <- 60 / (n * nD) # Zeitintervalle
  T <- 60 / nD # Periodendauer einer Umdrehung
  omega <- 2 * pi * nD / 60 # mittlere Winkelgeschwindigkeit
  
  # Segmentmasse OS und US [kg]
  mOS <- Masse * rRelOS 
  mUS <- Masse * rRelUS 
  
  # Trägheitsmoment des Segments [kg m^2]
  thetaOS <- (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS^2
  thetaUS <- (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS^2
  
  # Winkel und Geschwindigkeiten berechnen
  delta_phi1 <- 2 * pi / n # Winkelintervalle
  phi1 <- seq(0, 2 * pi, by=delta_phi1) # Erstellung von Winkelintervallen für eine komplette Umdrehung
  phi1 <- phi1[-length(phi1)]  # Entfernt das letzte Element
  grad <- phi1 * 180 / pi # Umrechnung von Bogenmaß in Grad
  time <- seq(0, T, by=delta_t) # Erstellung von Zeitintervallen für eine komplette Umdrehung
  time <- time[-length(time)]  # Entfernt das letzte Element
  
  # Berechnung der kartesischen Koordinaten von Punkt P1 in Abhängigkeit von der Zeit
  P1 <- list(lKurbel * sin(phi1), lKurbel * cos(phi1))
  
  # Abstand vom Hüftgelenk zur Kurbelachse (0,0) berechnen
  G4 <- sqrt(sum(P3^2))
  
  # Berechnung des Winkels des Gestänges
  delta <- acos(P3[2] / S)
  
  # Berechnung der Länge des Verbindungssegments zw. Kurbel und Hüftgelenk > 'c' kann nicht kürzer als die Summe der Längen der Beinsegmente sein
  c <- sqrt(lKurbel^2 + S^2 - 2 * S * lKurbel * cos(phi1 + delta))
  
  # Schleife zur Anpassung des Faktors, falls c größer als die Summe der Segmentlängen ist
  while (any(lUS + lOS < c)) {
    Faktor <- Faktor - 0.01  # Verringere den Faktor um 0.01
    S <- lBein * 0.883 * Faktor  # Neuberechnung von S
    P3y <- sqrt((S^2) - (P3x^2))  # Neuberechnung von P3y
    P3 <- c(P3x, P3y)  # Neuberechnung von P3
    delta <- acos(P3[2] / S)  # Neuberechnung von delta
    c <- sqrt(lKurbel^2 + S^2 - 2 * S * lKurbel * cos(phi1 + delta))  # Neuberechnung von c
  }
  
  # Überprüfung, ob die Segmentlängen zusammen größer sind als die berechnete Länge c
  control <- sum(ifelse(lUS + lOS <= c, 1, 0))
  
  # Ausgabe, ob control bzw. die Segmentlängen größer sind als c
  if (control > 0) {
    print("Mindestens eine Segmentlänge ist größer als c.")
  } else {
    print("Alle Segmentlängen sind kleiner oder gleich c.")
  }
  
  # Speichere den verwendeten Faktor in der Spalte 'Faktor_Used'
  Erg_data_df$Faktor_Used[i] <- Faktor
  
  # Winkelberechnungen für das Beinsegment    
  alpha <- asin(lKurbel * sin(phi1 + delta) / c) # Winkel zwischen Gestell und c (Verbindungsseg. zwischen Kurbel und Hüftgelenk )               
  beta <- acos((lOS^2 + c^2 - lUS^2) / (2 * lOS * c)) # Winkel zwischen Oberschenkel und L       
  
  # Berechnung der kartesischen Koordinaten von Punkt P2 in Abhängigkeit von der Zeit
  P2 <- list(P3[1] + lOS * cos(pi/2 - (alpha + beta + delta)),
             P3[2] - lOS * sin(pi/2 - (alpha + beta + delta)))
  
  # Winkelberechnungen zwischen den Segmentpunkten
  phi2 <- acos((P2[[1]] - P1[[1]]) / lUS)
  phi3 <- acos((P3[2] - P2[[2]]) / lOS)
  
  # Berechnung der kartesischen Koordinaten der Schwerpunkte der Oberschenkel- und Unterschenkelsegmente
  SpOS <- list(P3[1] - lambdaOS * (P3[1] - P2[[1]]), 
               P3[2] - lambdaOS * (P3[2] - P2[[2]]))
  SpUS <- list(P2[[1]] - lambdaUS * (P2[[1]] - P1[[1]]), 
               P2[[2]] - lambdaUS * (P2[[2]] - P1[[2]]))
  
  # Funktion zur Berechnung der Geschwindigkeit
  berechneGeschwindigkeit <- function(Sp, delta_t) {
    diff_x <- c(diff(Sp[[1]]), Sp[[1]][1] - Sp[[1]][length(Sp[[1]])])
    diff_y <- c(diff(Sp[[2]]), Sp[[2]][1] - Sp[[2]][length(Sp[[2]])])
    return(sqrt(diff_x^2 + diff_y^2) / delta_t)
  }
  
  # Anwenden der Funktion
  vOS <- berechneGeschwindigkeit(SpOS, delta_t)
  vUS <- berechneGeschwindigkeit(SpUS, delta_t)
  
  # Berechnung der translatorischen kinetischen Energie
  Ekin_trans <- 0.5 * (mOS * vOS^2 + mUS * vUS^2)
  
  # Delta der Winkelgeschwindigkeiten für zyklische Bewegung
  delta_phi2 <- c(diff(phi2), phi2[1] - phi2[length(phi2)])
  delta_phi3 <- c(diff(phi3), phi3[1] - phi3[length(phi3)])
  
  # Berechnung der Winkelgeschwindigkeiten der Schwerpunkte von Oberschenkel- und Unterschenkel
  omega_SpOS <- delta_phi2 / delta_t
  omega_SpUS <- delta_phi3 / delta_t
  omega_Kurbel <- delta_phi1 / delta_t
  
  # Trägheitsmoment des Segments (Vollzylinder, der um eine Querachse (zweizählige Symmetrieachse) rotiert) [kg m^2]
  thetaOS <- (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS^2
  thetaUS <- (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS^2
  
  # Berechnung der rotatorischen kinetischen Energie
  Ekin_rot <- 0.5 * (thetaOS * omega_SpOS^2 + thetaUS * omega_SpUS^2 + thetaKurbel * omega_Kurbel^2)
  
  # Delta der kinetischen Energie (translatorisch) für zyklische Bewegung
  delta_Ekin_trans <- c(diff(Ekin_trans), Ekin_trans[1] - Ekin_trans[length(Ekin_trans)])
  
  # Delta der kinetischen Energie (rotatorisch) für zyklische Bewegung
  delta_Ekin_rot <- c(diff(Ekin_rot), Ekin_rot[1] - Ekin_rot[length(Ekin_rot)])
  
  # Delta Gesamt für zyklische Bewegung
  delta_Ekin_ges <- delta_Ekin_rot + delta_Ekin_trans 
  
  # Berechnung der internen Leistung für die aktuelle Drehzahl und Masse
  PInt_Zyklus_Rechts <- delta_Ekin_ges / delta_t
  PInt_Zyklus_Rechts_Positiv <- ifelse(PInt_Zyklus_Rechts < 0, 0, PInt_Zyklus_Rechts)
  
  # Verschiebe die Werte von PInt_Zyklus_Rechts um 180 Positionen, um PInt_Zyklus_Links zu erhalten
  verschieben <- 180 # Die Anzahl der Zeilen, die verschoben werden sollen
  PInt_Zyklus_Links <- c(PInt_Zyklus_Rechts[(verschieben + 1):length(PInt_Zyklus_Rechts)], 
                          PInt_Zyklus_Rechts[1:verschieben])
  PInt_Zyklus_Links_Positiv <- ifelse(PInt_Zyklus_Links < 0, 0, PInt_Zyklus_Links)

  # Durchschnittliche PInt alle Positiven Werte, Negative Werte = 0
  PInt_Zyklus_mean <- mean(PInt_Zyklus_Rechts_Positiv) + mean(PInt_Zyklus_Links_Positiv)
  #PInt_Zyklus_mean_0 <- mean(PInt_Zyklus_Rechts_Positiv[PInt_Zyklus_Rechts_Positiv != 0]) + mean(PInt_Zyklus_Links_Positiv[PInt_Zyklus_Links_Positiv != 0])
  
  # Geben Sie das berechnete _PInt_mean zurück
  print(PInt_Zyklus_mean)
  
  # Berechnen Sie _PInt_mean für die aktuelle Zeile und speichern Sie es im DataFrame
  #Erg_data_df$_PInt_mean[i] <- _PInt_mean
  #Erg_data_df$PInt_Ges_Watt2[i] <- PInt_Ges_Watt2
  
  current_df <- data.frame(
    Time = time,
    Phi1 = phi1,
    Grad = grad,
    P1x = P1[[1]],
    P1y = P1[[2]],
    P2x = P2[[1]],
    P2y = P2[[2]],
    P3x = rep(P3[1], n),
    P3y = rep(P3[2], n),
    SpOS_X = SpOS[[1]],
    SpOS_Y = SpOS[[2]],
    SpUS_X = SpUS[[1]],
    SpUS_Y = SpUS[[2]],
    VOS = vOS,
    VUS = vUS,
    EkinTrans = Ekin_trans,
    EkinRot = Ekin_rot,
    DeltaEkinTrans = delta_Ekin_trans,
    DeltaEkinRot = delta_Ekin_rot,
    DeltaEkinGes = delta_Ekin_ges,
    PIntMittelZyklusRechts = PInt_Zyklus_Rechts,
    PIntMittelZyklusRechtsPositiv = PInt_Zyklus_Rechts_Positiv,
    PIntMittelZyklusLinks = PInt_Zyklus_Links,
    PIntMittelZyklusLinksPositiv = PInt_Zyklus_Links_Positiv,
    PInt_Modell = PInt_Zyklus_mean
  )
  
  # Füge den neuen Dataframe zur Liste hinzu
  PInt_list[[i]] <- current_df
  
  # Benenne das i-te Element der Liste basierend auf den Werten der ersten beiden Spalten in Erg_data_df
  name <- paste(Erg_data_df[i, 1], Erg_data_df[i, 2], sep = "_")
  # Überprüfe, ob die Länge des Namens weniger als 4 ist
  if(nchar(name) < 4) {
    name <- paste0("0", name)  # Füge eine "0" vor dem Namen hinzu, falls notwendig
  }
  names(PInt_list)[i] <- name
  
  # Berechnen Sie PInt_mean für die aktuelle Zeile und speichern Sie es im DataFrame
  Erg_data_df$PInt_Modell[i] <- mean(current_df$PInt_Modell)
}

df <- PInt_list[["15_5"]]

# Für Website einheitliche Achsen setzen
range_x <- c(-0.5, 0.5)
range_y <- c(-0.4, 1)

df$P0x <- 0
df$P0y <- 0

Modell_Simulation <- plot_ly(data = df[0000:0360,], frames = ~Grad) %>%
  
  # Verlauf von P1
  add_trace(
    x = ~P1x,
    y = ~P1y,
    type = 'scatter',
    mode = 'lines',
    name = "P1 Path",
    line = list(color = 'lightgrey', dash = 'dot'), 
    showlegend = FALSE
  ) %>%
  
  # Trace für P1
  add_trace(
    x = ~P1x,
    y = ~P1y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P1",
    showlegend = FALSE
  ) %>%

  
  # Trace für P3
  add_trace(
    x = ~P3x,
    y = ~P3y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P3",
    showlegend = FALSE
  ) %>%
  
  # Trace für P2
  add_trace(
    x = ~P2x,
    y = ~P2y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P2",
    showlegend = FALSE
  ) %>%
  
  # Trace für P0
  add_trace(
    x = ~P0x,
    y = ~P0y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Trace für SPOS
  add_trace(
    x = ~SpOS_X,
    y = ~SpOS_Y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Trace für SPUS
  add_trace(
    x = ~SpUS_X,
    y = ~SpUS_Y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Segmente hinzufügen
  add_segments(
    x = ~P0x, xend = ~P1x,
    y = ~P0y, yend = ~P1y,
    frame = ~Grad,
    line = list(color = 'black'),
    showlegend = FALSE
  ) %>%
  
  add_segments(
    x = ~P2x, xend = ~P3x,
    y = ~P2y, yend = ~P3y,
    frame = ~Grad,
    line = list(color = 'darkgrey'),
    showlegend = FALSE
  ) %>%
  
  add_segments(
    x = ~P2x, xend = ~P1x,
    y = ~P2y, yend = ~P1y,
    frame = ~Grad,
    line = list(color = 'darkgrey'),
    showlegend = FALSE
  ) %>%
  
  # Layout und weitere Einstellungen, inklusive der festgelegten Achsenbereiche
  layout(
    title = 'Kinematik-Modell',
    margin = list(t = 40),
    xaxis = list(title = 'X-Koordinate', range = range_x),
    yaxis = list(title = 'Y-Koordinate', range = range_y),
    showlegend = TRUE,
    legend = list(x = 1, y = 1)
  ) %>%
  
  # Animationsoptionen
  animation_opts(
    frame = 100,  # Dauer jedes Frames in Millisekunden
    redraw = TRUE
  ) %>%
  
  # Animation-Steuerelemente
  animation_button(
    label = "Play",
    method = "animate",
    args = list(NULL, list(frame = list(duration = 50, redraw = TRUE), fromcurrent = TRUE, mode = "immediate"))
  ) %>%
  
  animation_slider(
    currentvalue = list(prefix = "Grad: ")
  )

```

```{r}
PInt_df <- PInt_list[["13_5"]]

p_Int_Modell_Zyklus <- plot_ly(PInt_df, x = ~Grad, y = ~PIntMittelZyklusRechts, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
  add_trace(y = ~PIntMittelZyklusLinks, name = "Links", mode = "lines",
            line = list(color = "#F4737A")) %>%
  layout(yaxis = list(title = "P<sub>Int,modell</sub> [Watt]"),
         margin = list(b = 40)) %>%
  layout(xaxis = list(title = "Drehwinkel [ °]"))


```


@fig-PInt_Modell_Zyklus zeigt die modellierte innere Leistung (P~Int,Modell~) über einen vollständigen Pedalzyklus. Die Kurven stellen den Verlauf für das rechte (grün) und linke (rot) Bein dar, wobei sowohl positive als auch negative Leistungsanteile abgebildet sind.


```{r}
#| label: fig-PInt_Modell_Zyklus
#| fig-cap: "Beispielhafter Verlauf der modellierten inneren Leistung (P<sub>Int,Modell</sub>) über einen kompletten Pedalzyklus (360°), dargestellt mit positiven und negativen Leistungsanteilen für das rechte (grün) und linke Bein (rot)."   
#| fig-cap-location: bottom

p_Int_Modell_Zyklus
```

```{r}
PInt_df <- PInt_list[["13_5"]]

p_Int_Modell_Zyklus_positiv <- plot_ly(PInt_df, x = ~Grad, y = ~PIntMittelZyklusRechtsPositiv, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
  add_trace(y = ~PIntMittelZyklusLinksPositiv, name = "Links", mode = "lines",
            line = list(color = "#F4737A")) %>%
  add_trace(y = ~PInt_Modell, name = "PInt_Modell", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
  layout(yaxis = list(title = "P<sub>Int,modell</sub> [Watt]"),
         margin = list(b = 40),
         annotations = list(
           list(
             x = 170,  # x-Position der Annotation
             y = PInt_df$PInt_Modell[1] + 3.0,  # y-Position etwas über der grauen Linie
             text = paste("avg(P<sub>Int,modell,positiv</sub>) =", sprintf("%.1f", PInt_df$PInt_Modell[1])),
             showarrow = FALSE,
             textposition = "top center"
           )
         )) %>%
  layout(xaxis = list(title = "Drehwinkel [ °]"))
```



@fig-PInt_Modell_Zyklus_positiv visualisiert im Unterschied zu @fig-PInt_Modell_Zyklus ausschließlich die positiven Leistungsanteile der P~Int,Modell~. Zusätzlich ist der in deisem Beispiel berechnete Mittelwert der positiven P~int,modell~ Werte als horizontale Linie (grau gestrichelt) eingezeichnet. 



```{r}
#| label: fig-PInt_Modell_Zyklus_positiv
#| fig-cap: "Beispielhafte Darstellung der positiven Anteile der modellierten inneren Leistung beider Beine mit berechneter P~int_modell~ als mittlerer Wert der positiven P~int~ Werte über einen vollständigen Kurbelzyklus."
#| fig-cap-location: bottom

p_Int_Modell_Zyklus_positiv
```



## Zeitlicher Verlauf der aus der 3D-Kinematik modellierten inneren Leistung während der Pedalbewegung { .unlisted }



```{r echo=FALSE, output=FALSE}

# Initialisiere die Listen für die Ergebnisse
PInt_Kinematik_list <- list()
plotly_Pint_list <- list()

# Schleife durch alle Einträge in Kinematik_list
for (name in names(Kinematik_list)) {
  # Lese die Daten ein
  df <- Kinematik_list[[name]]

  # Definiere die ausgewählten Spalten und deren neue Namen direkt
  selected_columns <- c(Frame = "Frame",
                        P0x = "Kurbelachse_X", P0y = "Kurbelachse_Y",
                        P3x = "LHJC_X", P3y = "LHJC_Y",
                        P2x = "LKJC_X", P2y = "LKJC_Y",
                        P1x = "LToe_X", P1y = "LToe_Y",
                        LAJC_X = "LAJC_X", LAJC_Y = "LAJC_Y")
  
  # Entferne die erste und letzte Zeile, wähle und benenne die Spalten + Masse-Spalte
  df <- df[-c(1, nrow(df)), ] %>% 
    select(all_of(selected_columns)) %>%
    mutate(Masse = Erg_data_df[Erg_data_df$Name == name, "Masse"]) 
  
  # Funktion, um korrekten Winkelunterschied für zyklische Bewegungen zu berechnen
  corrected_delta_phi1 <- function(phi1) {
    # Berechnet die Winkeldifferenz zwischen aufeinanderfolgenden Werten. Fügt 'NA' für den letzten Wert ein.
    delta_phi1 = diff(phi1)
    
    # Korrigiert die Winkeldifferenzen, die die Grenzen einer zyklischen Bewegung überschreiten.
    # Für Übergänge nahe der Grenzen (0 und 360 Grad oder 0 und 2*pi), passen wir die Differenz an,
    # um korrekte kleine Werte zu erhalten statt großer Sprünge.
    delta_phi1 = ifelse(delta_phi1 > pi, delta_phi1 - 2*pi, delta_phi1)
    delta_phi1 = ifelse(delta_phi1 < -pi, delta_phi1 + 2*pi, delta_phi1)
    
    # Nimmt die letzten 3 Änderungen oder alle vorhandenen, falls weniger als 3
    num_values = min(length(delta_phi1), 3)
    last_values = tail(delta_phi1, num_values)
    
    # Berechnet die durchschnittliche Differenz der letzten Werte
    avg_difference = mean(last_values, na.rm = TRUE)
    
    # Fügt die durchschnittliche Differenz zum letzten verfügbaren Wert hinzu, um den nächsten Wert zu schätzen
    extrapolated_value = last(phi1) + avg_difference  # Der neue Wert basiert auf dem letzten phi1-Wert
    
    # Fügt den extrapolierten Wert zum Vektor hinzu
    delta_phi1 = c(delta_phi1, extrapolated_value - last(phi1))  # Differenz zum letzten phi1
    
    return(delta_phi1)
  }
  
  # Konstanten und Parameter
  # Suche den Wert für 'Masse' basierend auf 'Name' in Erg_data_df
  Masse <- Erg_data_df[Erg_data_df$Name == name, "Masse"]
  uOS <- Erg_data_df[Erg_data_df$Name == name, "uOS"]
  uUS <- Erg_data_df[Erg_data_df$Name == name, "uUS"]
  lBein <- Erg_data_df[Erg_data_df$Name == name, "lBein"]
  Faktor <- 1.0
  S <- lBein * 0.883 * Faktor # Abstand vom Hüftgelenk zur Kurbelachse - Lemond Methode
  rRelOS <- 0.1416 # relative Segmentmasse OS
  rRelUS <- 0.0433 # relative Segmentmasse US
  lambdaOS <- 0.4095 # Abstand zw. dem proximalen Punkt des Oberschenkelsegments und dessen Schwerpunkt
  lambdaUS <- 0.4459 # Abstand proximaler Segmentpunkt - Schwerpunkt
  mOS <- Masse * rRelOS # Segmentmasse OS
  mUS <- Masse * rRelUS # Segmentmasse US
  thetaKurbel <- 0.002  # Trägheitsmoment der Fahrradkurbel [kg m^2]                                                 
  
  # df Berechnen
  df <- df %>%
    mutate(
           phi1 = ifelse(atan2(P1y, P1x) < 0, atan2(P1y, P1x) + 2 * pi, atan2(P1y, P1x)),
           Grad = phi1 * (180 / pi),
           delta_t = 1 / 100,
           delta_phi1 = corrected_delta_phi1(phi1),
           omega = delta_phi1 / delta_t,
           nD = omega / (2 * pi) * 60,
           nD_avg = mean(omega, na.rm = TRUE) / (2 * pi) * 60,
           T = 60 / nD,
           lOS = sqrt((P3x-P2x)^2+(P3y-P2y)^2),                                     # Gerade zwischen Hüfte und Knie
           lUS = sqrt((P2x-LAJC_X)^2+(P2y-LAJC_Y)^2),                               # Gerade zwischen Knie und Ankle
           lOS_avg = mean(lOS),
           lUS_avg = mean(lUS),
           thetaOS = (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS_avg^2,   # Trägheitsmoment des OS [kg m^2]
           thetaUS = (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS_avg^2,   # Trägheitsmoment des OS [kg m^2]
           SpOS_X = P3x - lambdaOS * (P3x-P2x),
           SpOS_Y  = P3y - lambdaOS * (P3y-P2y),
           SpUS_X  = P2x - lambdaOS * (P2x-LAJC_X),
           SpUS_Y  = P2y - lambdaOS * (P2y-LAJC_Y),
           d_SpOS = sqrt((lead(SpOS_X) - SpOS_X)^2 + (lead(SpOS_Y) - SpOS_Y)^2),    # Abstand zwischen aufeinanderfolgenden SpOS-Punkten
           d_SpUS = sqrt((lead(SpUS_X) - SpUS_X)^2 + (lead(SpUS_Y) - SpUS_Y)^2),    # Abstand zwischen aufeinanderfolgenden SpUS-Punkten
           v_SpOS = ifelse(is.na(d_SpOS), NA, d_SpOS / delta_t),                    # Geschwindigkeit von SpOS
           v_SpUS = ifelse(is.na(d_SpUS), NA, d_SpUS / delta_t),                    # Geschwindigkeit von SpOS
           phi2 = acos((P2x-P1x) / lUS),                                            # Winkeln zwischen x-Achse und Verbindung Pedale-Knie
           phi3 = acos((P3x-P2x) / lOS),                                            # Winkel zwischen OS und Gestell
           omega_SpOS = (lead(phi2) - phi2) / delta_t,
           omega_SpUS = (lead(phi3) - phi3) / delta_t,
           omega_Kurbel = (lead(phi2) - phi2) / delta_t,
           Ekin_rot = 0.5 * (thetaOS * omega_SpOS^2 + thetaUS * omega_SpUS^2 + thetaKurbel * omega_Kurbel^2),
           Ekin_trans = 0.5 * (mOS * v_SpOS^2 + mUS * v_SpUS^2),
           delta_Ekin_rot = lead(Ekin_rot) - Ekin_rot,
           delta_Ekin_trans = lead(Ekin_trans) - Ekin_trans,
           delta_Ekin_ges = delta_Ekin_rot + delta_Ekin_trans,
           PInt_Rechts = delta_Ekin_ges / delta_t
    ) %>%
    slice(1:(n() - 2)) %>%
    select(Frame, Grad, phi1, delta_phi1, omega, T, nD, nD_avg, Masse, everything())
  
  # Ausreißer
  # Erkennung und Behandlung von Ausreißern in PInt_Rechts
  Q1 <- quantile(df$PInt_Rechts, 0.25, na.rm = TRUE)
  Q3 <- quantile(df$PInt_Rechts, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  # Ausreißer sind Werte, die unter Q1 - 1.5*IQR oder über Q3 + 1.5*IQR liegen
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  
  # Ersetze Ausreißer mit NA
  df$PInt_Rechts <- ifelse(df$PInt_Rechts < lower_bound | df$PInt_Rechts > upper_bound, NA, df$PInt_Rechts)
  
  # Ersetzen der NA-Werte durch gleitende Mittelwerte
  # Für jeden NA-Wert berechne den Durchschnitt der zwei oberen und unteren gültigen Werte
  df$PInt_Rechts_imputed <- df$PInt_Rechts
  
  for (i in 1:length(df$PInt_Rechts_imputed)) {
    if (is.na(df$PInt_Rechts_imputed[i])) {
      # Finde die Indizes der nächsten drei gültigen Werte sowohl oberhalb als auch unterhalb des NA-Wertes
      valid_indices_above <- which(!is.na(df$PInt_Rechts_imputed[i:min(i+2, nrow(df))]))
      valid_indices_below <- which(!is.na(df$PInt_Rechts_imputed[max(i-2, 1):i]))
      
      # Berechne die Mittelwerte der gültigen Werte, falls vorhanden
      if (length(valid_indices_above) > 0 && length(valid_indices_below) > 0) {
        upper_mean <- mean(df$PInt_Rechts_imputed[i + valid_indices_above], na.rm = TRUE)
        lower_mean <- mean(df$PInt_Rechts_imputed[i - valid_indices_below], na.rm = TRUE)
        df$PInt_Rechts_imputed[i] <- mean(c(upper_mean, lower_mean), na.rm = TRUE)
      } else if (length(valid_indices_above) > 0) {
        df$PInt_Rechts_imputed[i] <- mean(df$PInt_Rechts_imputed[i + valid_indices_above], na.rm = TRUE)
      } else if (length(valid_indices_below) > 0) {
        df$PInt_Rechts_imputed[i] <- mean(df$PInt_Rechts_imputed[i - valid_indices_below], na.rm = TRUE)
      }
    }
  }
  # Übertragen der imputierten Werte zurück in die ursprüngliche Spalte
  df$PInt_Rechts <- df$PInt_Rechts_imputed
  # Löschen der Hilfsspalte
  df$PInt_Rechts_imputed <- NULL
  
  # Zyklusfindung
  ## Variablen
  Startwert_Grad <- df$Grad[1]
  Toleranz <- 3
  ## Endpunkte und Anzahl
  Ende_Zyklus_Indizes <- which(abs(df$Grad - Startwert_Grad) <= Toleranz)
  diff_Ende_Zyklus_Indizes <- c(diff(Ende_Zyklus_Indizes), Toleranz + 1)  # Hinzufügen eines hohen Werts am Ende für den letzten Index
  gefilterte_Indizes <- Ende_Zyklus_Indizes[diff_Ende_Zyklus_Indizes > 1] # Bereinigen der Indizes
  Anzahl_Zyklen <- length(gefilterte_Indizes)-1
  Werte_Indizes <- df$Grad[gefilterte_Indizes]
  Ende_Zyklen <- gefilterte_Indizes[length(gefilterte_Indizes)]
  df$Grad[Ende_Zyklen]
  
  # Beschränkung des DataFrames bis zum letzten gefundenen Zyklusende
  df <- df[1:Ende_Zyklen, ]
  
  # Berechnung der durchschnittlichen Zykluslänge
  Laenge_Zyklus <- round(length(df$Grad) / Anzahl_Zyklen, 0)
  
  # Einstellen der Verschiebung basierend auf Zykluslänge für Spaltenanpassungen
  verschieben <- round(Laenge_Zyklus * 0.5)
  
  # Initialisierung und Berechnung verschobener Werte für PInt_Links
  verschobene_Werte <- numeric(nrow(df))
  for (i in 1:nrow(df)) {
    index_in_PInt_Rechts <- ((i + verschieben - 1) %% nrow(df)) + 1
    verschobene_Werte[i] <- df$PInt_Rechts[index_in_PInt_Rechts]
  }
  
  # Zuweisung der verschobenen Werte und Anpassung negativer Werte
  df$PInt_Links <- verschobene_Werte
  df$PInt_Links_Positiv <- ifelse(df$PInt_Links < 0, 0, df$PInt_Links)
  
  # Definition der Breite des gleitenden Fensters für Glättung
  fensterbreite <- 15
  
  # Aktualisierung der Daten mit geglätteten Werten und Durchschnittsbildung
  df <- df %>%
    mutate(
      PInt_Rechts_Positiv = ifelse(PInt_Rechts < 0, 0, PInt_Rechts),
      PInt_Kinematik = mean(PInt_Rechts_Positiv, na.rm = TRUE) + mean(PInt_Links_Positiv, na.rm = TRUE),
      PInt_Rechts_smooth = rollmean(PInt_Rechts, fensterbreite, fill = NA, align = "right"),
      PInt_Rechts_Positiv_smooth = ifelse(PInt_Rechts_smooth < 0, 0, PInt_Rechts_smooth),
      PInt_Links_smooth = rollmean(PInt_Links, fensterbreite, fill = NA, align = "right"),
      PInt_Links_Positiv_smooth = ifelse(PInt_Links_smooth < 0, 0, PInt_Links_smooth)
    )
  
  # Speichere das bearbeitete DataFrame in PInt_Kinematik_list
  PInt_Kinematik_list[[name]] <- df
  
  # Berechne den Mittelwert von nD_avg
  mean_nD_avg <- mean(df$nD_avg, na.rm = TRUE)
  
  # Erstelle die Plotly-Plots und speichere sie in plotly_Pint_list
  plot1 <- plot_ly(df[1:(Laenge_Zyklus*1.5), ], x = ~Frame, y = ~PInt_Rechts_smooth, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(yaxis = list(title = "PInt-Positiv für einen Zyklus")) %>%
    layout(xaxis = list(title = "Frame"))
  
  plot2 <- plot_ly(df[1:(Laenge_Zyklus*4), ], x = ~Frame, y = ~PInt_Rechts_Positiv_smooth, type = "scatter", mode = "lines", name = "Rechts",line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_Positiv_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(yaxis = list(title = "PInt-Positiv für einen Zyklus")) %>%
    layout(xaxis = list(title = "Frame"))
  
plot3 <- plot_ly(df, x = ~Frame, y = ~PInt_Rechts_Positiv_smooth, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_Positiv_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "P<sub>Int,Kinematik</sub> [Watt]", range = c(0, 80), dtick = 10), 
           xaxis = list(title = "Frame", dtick = 100, range = c(0, max(df$Frame))),
           annotations = list(
             list(
               x = 0.02, y = 0.95, xref = 'paper', yref = 'paper',
               text = paste("Drehzahl =", round(mean_nD_avg, 2)),
               showarrow = FALSE,
               font = list(size = 12)
             ),
             list(
               x = 0.02, y = 0.90, xref = 'paper', yref = 'paper',
               text = paste("avg(P<sub>Int,Kinematik,positiv</sub>) =", sprintf("%.1f", df$PInt_Kinematik[1])),
               showarrow = FALSE,
               font = list(size = 12)
             )
           ))
  
  plot4 <- plot_ly(df, x = ~Grad, y = ifelse(df$PInt_Rechts_Positiv_smooth == 0, NA, df$PInt_Rechts_Positiv_smooth), type = "scatter", mode = "markers", name = "Rechts", marker = list(color = "#42BA97")) %>%
    add_trace(y = ifelse(df$PInt_Links_Positiv_smooth == 0, NA, df$PInt_Links_Positiv_smooth), name = "Links", mode = "markers", marker = list(color = "#F4737A")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "PInt-Positiv über alle Zyklen"), 
           xaxis = list(title = "Grad"))
  
  plot5 <- plot_ly(df, x = ~Frame, y = ~PInt_Links_Positiv_smooth, name = "Links", type = "scatter", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "PInt-Positiv für Links"), 
           xaxis = list(title = "Frame"))
  
  # Speichere die Plots
  plotly_Pint_list[[name]] <- list(plot1, plot2, plot3, plot4, plot5)
}

```



Die folgenden Abbildungen zeigen den zeitlichen Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~Int,Kinematik~) für den jeweiligen Messzeitraum. Dargestellt sind die Leistungsverläufe des rechten (grün) und linken (rot) Beins sowie der gemittelte P~Int,Kinematik~-Wert (grau gestrichelt). Die interaktive Darstellung ermöglicht die Auswahl verschiedener Probanden und deren jeweiliger Testdurchgänge.

::: {.panel-tabset}
### Proband 1

::: panel-tabset
#### Test 1


```{r}
#| label: fig-PInt_Kinematik_01_1
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_1."
#| fig-cap-location: bottom

plotly_Pint_list[["01_1"]][[3]]
```



#### Test 2


```{r}
#| label: fig-PInt_Kinematik_01_2
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_2."
#| fig-cap-location: bottom

plotly_Pint_list[["01_2"]][[3]]
```



#### Test 3


```{r}
#| label: fig-PInt_Kinematik_01_3
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_3."
#| fig-cap-location: bottom

plotly_Pint_list[["01_3"]][[3]]
```



#### Test 4


```{r}
#| label: fig-PInt_Kinematik_01_4
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_4."
#| fig-cap-location: bottom

plotly_Pint_list[["01_4"]][[3]]
```



#### Test 5


```{r}
#| label: fig-PInt_Kinematik_01_5
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_5."
#| fig-cap-location: bottom

plotly_Pint_list[["01_5"]][[3]]
```



#### Test 6


```{r}
#| label: fig-PInt_Kinematik_01_6
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 01_6."
#| fig-cap-location: bottom

plotly_Pint_list[["01_6"]][[3]]
```


:::

### Proband 6

::: panel-tabset


```{r}
#### Test 1
#| label: fig-PInt_Kinematik_06_1
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_1."
#| fig-cap-location: bottom

plotly_Pint_list[["06_1"]][[3]]
```



#### Test 2


```{r}
#| label: fig-PInt_Kinematik_06_2
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_2."
#| fig-cap-location: bottom

plotly_Pint_list[["06_2"]][[3]]
```



#### Test 3


```{r}
#| label: fig-PInt_Kinematik_06_3
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_3."
#| fig-cap-location: bottom

plotly_Pint_list[["06_3"]][[3]]
```



#### Test 4


```{r}
#| label: fig-PInt_Kinematik_06_4
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_4."
#| fig-cap-location: bottom

plotly_Pint_list[["06_4"]][[3]]
```



#### Test 5


```{r}
#| label: fig-PInt_Kinematik_06_5
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_5."
#| fig-cap-location: bottom

plotly_Pint_list[["06_5"]][[3]]
```



#### Test 6


```{r}
#| label: fig-PInt_Kinematik_06_6
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 06_6."
#| fig-cap-location: bottom

plotly_Pint_list[["06_6"]][[3]]
```


:::

### Proband 13

::: panel-tabset


```{r}
#### Test 2
#| label: fig-PInt_Kinematik_13_2
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 13_2."
#| fig-cap-location: bottom

plotly_Pint_list[["13_2"]][[3]]
```



#### Test 3


```{r}
#| label: fig-PInt_Kinematik_13_3
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 13_3."
#| fig-cap-location: bottom

plotly_Pint_list[["13_3"]][[3]]
```



#### Test 4


```{r}
#| label: fig-PInt_Kinematik_13_4
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 13_4."
#| fig-cap-location: bottom

plotly_Pint_list[["13_4"]][[3]]
```



#### Test 5


```{r}
#| label: fig-PInt_Kinematik_13_5
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 13_5."
#| fig-cap-location: bottom

plotly_Pint_list[["13_5"]][[3]]
```



#### Test 6


```{r}
#| label: fig-PInt_Kinematik_13_6
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 13_6."
#| fig-cap-location: bottom

plotly_Pint_list[["13_6"]][[3]]
```


:::

### Proband 15

::: panel-tabset
#### Test 1


```{r}
#| label: fig-PInt_Kinematik_15_1
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_1."
#| fig-cap-location: bottom

plotly_Pint_list[["15_1"]][[3]]
```



#### Test 2


```{r}
#| label: fig-PInt_Kinematik_15_2
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_2."
#| fig-cap-location: bottom

plotly_Pint_list[["15_2"]][[3]]
```



#### Test 3


```{r}
#| label: fig-PInt_Kinematik_15_3
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_3."
#| fig-cap-location: bottom

plotly_Pint_list[["15_3"]][[3]]
```



#### Test 4


```{r}
#| label: fig-PInt_Kinematik_15_4
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_4."
#| fig-cap-location: bottom

plotly_Pint_list[["15_4"]][[3]]
```



#### Test 5


```{r}
#| label: fig-PInt_Kinematik_15_5
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_5."
#| fig-cap-location: bottom

plotly_Pint_list[["15_5"]][[3]]
```



#### Test 6


```{r}
#| label: fig-PInt_Kinematik_15_6
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 15_6."
#| fig-cap-location: bottom

plotly_Pint_list[["15_6"]][[3]]
```


:::

### Proband 19

::: panel-tabset
#### Test 1


```{r}
#| label: fig-PInt_Kinematik_19_1
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_1."
#| fig-cap-location: bottom

plotly_Pint_list[["19_1"]][[3]]
```



#### Test 2


```{r}
#| label: fig-PInt_Kinematik_19_2
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_2."
#| fig-cap-location: bottom

plotly_Pint_list[["19_2"]][[3]]
```



#### Test 3


```{r}
#| label: fig-PInt_Kinematik_19_3
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_3."
#| fig-cap-location: bottom

plotly_Pint_list[["19_3"]][[3]]
```



#### Test 4


```{r}
#| label: fig-PInt_Kinematik_19_4
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_4."
#| fig-cap-location: bottom
#| 
plotly_Pint_list[["19_4"]][[3]]
```



#### Test 5


```{r}
#| label: fig-PInt_Kinematik_19_5
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_5."
#| fig-cap-location: bottom

plotly_Pint_list[["19_5"]][[3]]
```



#### Test 6


```{r}
#| label: fig-PInt_Kinematik_19_6
#| fig-cap: "Zeitlicher Verlauf der aus der 3D-Kinematik berechneten positiven Anteile der inneren Leistung (P~int~) beider Beine mit gemitteltem P~int~-Wert (grau gestrichelt) für 19_6."
#| fig-cap-location: bottom

plotly_Pint_list[["19_6"]][[3]]
```


:::
:::

### Vergleich der berechneten inneren Leistungen: Biomechanisches Modell, 3D-Kinematik und Minetti-Berechnung { .unlisted }
@fig-Vergleich_PInt_Kin_Mod zeigt einen direkten Vergleich der inneren Leistung (P~Int~), die mittels drei verschiedener Methoden (Biomechanisches Modell, 3D-Kinematik und Minetti-Berechnung) für verschiedene Probanden ermittelt wurde. 
Im niedrigen Drehzahlbereich (60-70 min^-1^) zeigen alle drei Berechnungsmethoden noch relativ ähnliche Werte mit P~Int~ zwischen 10 und 25 Watt. Mit steigender Drehzahl wird eine zunehmende Abweichung zwischen den Methoden erkennbar. Die Minetti-Berechnung (Dreiecke) tendiert dabei zu den höchsten Werten, während das biomechanische Modell (Kreise) meist die niedrigsten Werte liefert. Die aus der 3D-Kinematik ermittelten Werte (Quadrate) positionieren sich in der Regel zwischen diesen beiden Extremen. Bei Drehzahlen oberhalb von 85 min^-1^ zeigt sich sich eine progressive Abweichung zwischen der Minetti-Berechnung und den anderen beiden Methoden.



```{r}
### PInt_Kinematik vs PInt_Modell vs PInt_Minetti ###

# Farbpalette vorbereiten
num_probanden <- length(unique(Erg_data_df$Proband))
farbpalette <- colorRampPalette(brewer.pal(8, "Spectral"))(num_probanden)
farben <- setNames(farbpalette, unique(Erg_data_df$Proband))

# Berechne den maximalen y-Wert
y_max <- max(c(Erg_data_df$PInt_Kinematik, Erg_data_df$PInt_Modell, Erg_data_df$P_Int_Min), na.rm = TRUE)

# Diagramm erstellen
p_Vergleich_PInt_Kin_Mod <- plot_ly() %>% layout(
  margin = list(t = 40),
  xaxis = list(
    title = "Drehzahl [min<sup>-1</sup>]"
  ),
  yaxis = list(
    title = "P<sub>Int</sub> [Watt]",
    range = c(0, y_max * 1.1)  # Beginnt bei 0, endet etwas über dem maximalen Wert
  ),
  showlegend = TRUE,
  legend = list(
    font = list(size = 10.5)  # Hier wird die Legendenbeschriftungsgröße auf 10 Pixel gesetzt
  )
)

# Daten und Marker für jeden Probanden hinzufügen
for (proband_id in unique(Erg_data_df$Proband)) {
  # Daten für den aktuellen Probanden extrahieren und nach nD sortieren
  current_data <- subset(Erg_data_df, Proband == proband_id)
  current_data <- current_data[order(current_data$nD), ]
  
  # Marker für PInt_Kinematik als Vierecke hinzufügen
  p_Vergleich_PInt_Kin_Mod <- p_Vergleich_PInt_Kin_Mod %>%
    add_markers(
      data = current_data,
      x = ~nD,
      y = ~PInt_Kinematik,
      marker = list(size = 9, color = farben[[as.character(proband_id)]], symbol = 'square'),
      name = paste("Proband", proband_id, "- Kinematik"),
      showlegend = TRUE,
      legendgroup = paste("Proband", proband_id)
    )
  
  # Marker für PInt_Modell als normale Punkte hinzufügen
  p_Vergleich_PInt_Kin_Mod <- p_Vergleich_PInt_Kin_Mod %>%
    add_markers(
      data = current_data,
      x = ~nD,
      y = ~PInt_Modell,
      marker = list(size = 9, color = farben[[as.character(proband_id)]]),
      name = paste("Proband", proband_id, "- Modell"),
      showlegend = TRUE,
      legendgroup = paste("Proband", proband_id)
    )
  
  # Marker für P_Int_Min als Dreiecke hinzufügen
  p_Vergleich_PInt_Kin_Mod <- p_Vergleich_PInt_Kin_Mod %>%
    add_markers(
      data = current_data,
      x = ~nD,
      y = ~P_Int_Min,
      marker = list(size = 9, color = farben[[as.character(proband_id)]], symbol = 'triangle-up'),
      name = paste("Proband", proband_id, "- Minetti"),
      showlegend = TRUE,
      legendgroup = paste("Proband", proband_id)
    )
  
  # Verbindungslinien zwischen vorhandenen Werten für jeden nD-Wert hinzufügen
  for (i in 1:nrow(current_data)) {
    values <- c(current_data$PInt_Kinematik[i], current_data$PInt_Modell[i], current_data$P_Int_Min[i])
    valid_indices <- which(!is.na(values))
    
    if (length(valid_indices) >= 2) {
      for (j in 1:(length(valid_indices)-1)) {
        p_Vergleich_PInt_Kin_Mod <- p_Vergleich_PInt_Kin_Mod %>%
          add_segments(
            x = current_data$nD[i],
            xend = current_data$nD[i],
            y = values[valid_indices[j]],
            yend = values[valid_indices[j+1]],
            line = list(
              color = farben[[as.character(proband_id)]],
              width = 1,  # Dünnere Linie
              dash = 'dot'  # Gestrichelte Linie im Muster 4-2
            ),
            showlegend = FALSE,
            legendgroup = paste("Proband", proband_id)
          )
      }
    }
  }
}

```

```{r}
#| label: fig-Vergleich_PInt_Kin_Mod
#| fig-cap: "Vergleich der berechneten inneren Leistungen: Biomechanisches Modell, 3D-Kinematik und Minetti-Berechnung"
#| fig-cap-location: bottom

# Diagramm anzeigen
p_Vergleich_PInt_Kin_Mod
```



### Individuelle Darstellung und kubische Modellierung der inneren Leistung aus dem biomechanischen Modell, der 3D-Kinematik und der kombinierten Berechnung { .unlisted }
Die Abbildungen @fig-PInt_Mod, @fig-PInt_Kin und @fig-PInt_Kin_Mod illustrieren die körpergewichtsbezogene innere Leistung in Relation zur Trittrate, wobei jeweils eine kubische Modellfunktion den Verlauf der jeweiligen P~Int~-Berechnung für die steigenden Drehzahlen beschreibt. Das biomechanische Modell (@fig-PInt_Mod) liefert dabei eine vollständige Datenbasis für alle Probanden und Belastungen mit einer sehr guten Modellanpassung (R² = 0.999, y = 0.00000075x³). Die kinematikbasierte Analyse (@fig-PInt_Kin) beschränkt sich auf die Belastungsintensitäten mit verfügbaren 3D-Kinematik Daten, zeigt jedoch einen vergleichbaren Funktionsverlauf (R² = 0.983, y = 0.00000077x³). Die Kombination beider Methoden (@fig-PInt_Kin_Mod) ermöglicht durch Einbeziehung der mittleren Differenzen zwischen kinematischer und modellierter innerer Leistung eine Approximation für Belastungsintensitäten ohne Kinematikdaten. Die konsistente Charakteristik der kubischen Modellfunktionen über alle drei Berechnungsansätze unterstützt die gewählte mathematische Beschreibung des Zusammenhangs zwischen Trittrate und innerer Leistung.

::: panel-tabset
#### P~Int,Modell~ { .unlisted }


```{r}
Erg_data_df$PInt_Kinematik_Modell_kg <- Erg_data_df$PInt_Kinematik_Modell/ Erg_data_df$Masse 
Erg_data_df$PInt_Modell_kg <- Erg_data_df$PInt_Modell/ Erg_data_df$Masse 
Erg_data_df$PInt_Kinematik_kg <- Erg_data_df$PInt_Kinematik/ Erg_data_df$Masse 

### Plot der Berechneten inneren Arbeit im Bezug zur Drehzahl ###
# Berechne die Grenzen für x- und y-Achsen
x_min <- 0
x_max <- 120

# Kubische Regression nur mit x³, ohne Intercept
cubic_model <- lm(PInt_Modell_kg ~ 0 + I(nD^3), data = Erg_data_df)
summary_cubic <- summary(cubic_model)
coef_cubic <- coef(cubic_model)

# Berechne y_max basierend auf der kubischen Funktion bei x = 120
y_max <- coef_cubic[1] * x_max^3

equation_text_cubic <- sprintf("P<sub>Int,Modell</sub>(nD) = %.8f ⋅ nD³", coef_cubic[1])
r_squared_cubic <- summary_cubic$r.squared
r_squared_text_cubic <- sprintf("R² = %.3f", r_squared_cubic)

# Berechnung der kubischen Regressionskurve
nD_seq <- seq(x_min, x_max, length.out = 100)
cubic_values <- predict(cubic_model, newdata = data.frame(nD = nD_seq))

# Diagramm erstellen
plot_PInt_Mod <- plot_ly() %>%
  add_markers(data = Erg_data_df, x = ~nD, y = ~PInt_Modell_kg, 
              color = ~factor(Proband), 
              colors = colorRampPalette(brewer.pal(10,"Spectral"))(20), 
              legendgroup = ~Proband,
              showlegend = FALSE,
              marker = list(size = 9)) %>%
  add_lines(x = nD_seq, y = cubic_values, 
            name = "Kubische Modellfunktion", 
            line = list(color = 'rgba(128, 128, 128, 0.5)', width = 2, dash = 'dash')) %>%
  layout(
    margin = list(t = 40), 
    xaxis = list(
      title = "Drehzahl [min<sup>-1</sup>]",
      range = c(x_min, x_max),
      zeroline = FALSE
    ),
    yaxis = list(
      title = "P<sub>Int,Modell</sub>  [Watt ⋅ kg<sup>-1</sup>]",
      range = c(0, 1.3)
    ),
    showlegend = TRUE,
    annotations = list(
      list(x = x_min + 10, y = 1.3 * 0.95, text = equation_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top'),
      list(x = x_min + 10, y = 1.3 * 0.90, text = r_squared_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top')
    )
  )

# Legende für die Farben der Probanden hinzufügen
for (proband_id in unique(Erg_data_df$Proband)) {
  plot_PInt_Mod <- plot_PInt_Mod %>% add_trace(
    data = subset(Erg_data_df, Proband == proband_id),
    x = ~nD,
    y = ~PInt_Modell_kg,
    type = "scatter",
    mode = "markers",
    marker = list(size = 9),
    name = paste("Proband", proband_id),
    showlegend = TRUE,
    legendgroup = ~Proband,
    color = ~factor(Proband)
  )
}

```

```{r}
#| label: fig-PInt_Mod
#| fig-cap: "Körpergewichtsbezogene innere Leistung von P~Int,Modell~ in Abhängigkeit von der Trittrate mit kubischer Modellfunktion (y = 0.00000075x³, R² = 0.999)."
#| fig-cap-location: bottom

# Diagramm anzeigen
plot_PInt_Mod
```



#### P~Int,Kinematik~ { .unlisted }


```{r}
Erg_data_df$PInt_Kinematik_Modell_kg <- Erg_data_df$PInt_Kinematik_Modell/ Erg_data_df$Masse 
Erg_data_df$PInt_Modell_kg <- Erg_data_df$PInt_Modell/ Erg_data_df$Masse 
Erg_data_df$PInt_Kinematik_kg <- Erg_data_df$PInt_Kinematik/ Erg_data_df$Masse 

### Plot der Berechneten inneren Arbeit im Bezug zur Drehzahl ###
# Berechne die Grenzen für x- und y-Achsen
x_min <- 0
x_max <- 120

# Kubische Regression nur mit x³, ohne Intercept
cubic_model <- lm(PInt_Kinematik_kg ~ 0 + I(nD^3), data = Erg_data_df)
summary_cubic <- summary(cubic_model)
coef_cubic <- coef(cubic_model)

# Berechne y_max basierend auf der kubischen Funktion bei x = 120
y_max <- coef_cubic[1] * x_max^3

equation_text_cubic <- sprintf("P<sub>Int,Kinematik</sub>(nD) = %.8f ⋅ nD³", coef_cubic[1])
r_squared_cubic <- summary_cubic$r.squared
r_squared_text_cubic <- sprintf("R² = %.3f", r_squared_cubic)

# Berechnung der kubischen Regressionskurve
nD_seq <- seq(x_min, x_max, length.out = 100)
cubic_values <- predict(cubic_model, newdata = data.frame(nD = nD_seq))

# Diagramm erstellen
plot_PInt_Kin <- plot_ly() %>%
  add_markers(data = Erg_data_df, x = ~nD, y = ~PInt_Kinematik_kg, 
              color = ~factor(Proband), 
              colors = colorRampPalette(brewer.pal(10,"Spectral"))(20), 
              legendgroup = ~Proband,
              showlegend = FALSE,
              marker = list(size = 9)) %>%
  add_lines(x = nD_seq, y = cubic_values, 
            name = "Kubische Modellfunktion", 
            line = list(color = 'rgba(128, 128, 128, 0.5)', width = 2, dash = 'dash')) %>%
  layout(
    margin = list(t = 40), 
    xaxis = list(
      title = "Drehzahl [min<sup>-1</sup>]",
      range = c(x_min, x_max),
      zeroline = FALSE
    ),
    yaxis = list(
      title = "P<sub>Int,Kinematik</sub> [Watt ⋅ kg<sup>-1</sup>]",
      range = c(0, 1.3)
    ),
    showlegend = TRUE,
    annotations = list(
      list(x = x_min + 10, y = 1.3 * 0.95, text = equation_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top'),
      list(x = x_min + 10, y = 1.3 * 0.90, text = r_squared_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top')
    )
  )

# Legende für die Farben der Probanden hinzufügen
for (proband_id in unique(Erg_data_df$Proband)) {
  plot_PInt_Kin <- plot_PInt_Kin %>% add_trace(
    data = subset(Erg_data_df, Proband == proband_id),
    x = ~nD,
    y = ~PInt_Kinematik_kg,
    type = "scatter",
    mode = "markers",
    marker = list(size = 9),
    name = paste("Proband", proband_id),
    showlegend = TRUE,
    legendgroup = ~Proband,
    color = ~factor(Proband)
  )
}


```

```{r}
#| label: fig-PInt_Kin
#| fig-cap: "Körpergewichtsbezogene innere Leistung von P~Int,Kinematik~ in Abhängigkeit von der Trittrate mit kubischer Modellfunktion (y = 0.00000077x³, R² = 0.983)."
#| fig-cap-location: bottom

# Diagramm anzeigen
plot_PInt_Kin
```



#### P~Int,Kinematik,Modell~ { .unlisted }


```{r}
Erg_data_df$PInt_Kinematik_Modell_kg <- Erg_data_df$PInt_Kinematik_Modell/ Erg_data_df$Masse 

### Plot der Berechneten inneren Arbeit im Bezug zur Drehzahl ###
# Berechne die Grenzen für x- und y-Achsen
x_min <- 0
x_max <- 120

# Kubische Regression nur mit x³, ohne Intercept
cubic_model <- lm(PInt_Kinematik_Modell_kg ~ 0 + I(nD^3), data = Erg_data_df)
summary_cubic <- summary(cubic_model)
coef_cubic <- coef(cubic_model)

# Berechne y_max basierend auf der kubischen Funktion bei x = 120
y_max <- coef_cubic[1] * x_max^3

equation_text_cubic <- sprintf("P<sub>Int,Kinematik,Modell</sub>(nD) = %.8f ⋅ nD³", coef_cubic[1])
r_squared_cubic <- summary_cubic$r.squared
r_squared_text_cubic <- sprintf("R² = %.3f", r_squared_cubic)

# Berechnung der kubischen Regressionskurve
nD_seq <- seq(x_min, x_max, length.out = 100)
cubic_values <- predict(cubic_model, newdata = data.frame(nD = nD_seq))

# Diagramm erstellen
plot_PInt_Kin_Mod <- plot_ly() %>%
  add_markers(data = Erg_data_df, x = ~nD, y = ~PInt_Kinematik_Modell_kg, 
              color = ~factor(Proband), 
              colors = colorRampPalette(brewer.pal(10,"Spectral"))(20), 
              legendgroup = ~Proband,
              showlegend = FALSE,
              marker = list(size = 9)) %>%
  add_lines(x = nD_seq, y = cubic_values, 
            name = "Kubische Modellfunktion", 
            line = list(color = 'rgba(128, 128, 128, 0.5)', width = 2, dash = 'dash')) %>%
  layout(
    margin = list(t = 40), 
    xaxis = list(
      title = "Drehzahl [min<sup>-1</sup>]",
      range = c(x_min, x_max),
      zeroline = FALSE
    ),
    yaxis = list(
      title = "P<sub>Int,Kinematik,Modell</sub> [Watt ⋅ kg<sup>-1</sup>]",
      range = c(0, 1.3)
    ),
    showlegend = TRUE,
    annotations = list(
      list(x = x_min + 10, y = 1.3 * 0.95, text = equation_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top'),
      list(x = x_min + 10, y = 1.3 * 0.90, text = r_squared_text_cubic, showarrow = FALSE, xanchor = 'left', yanchor = 'top')
    )
  )

# Legende für die Farben der Probanden hinzufügen
for (proband_id in unique(Erg_data_df$Proband)) {
  plot_PInt_Kin_Mod <- plot_PInt_Kin_Mod %>% add_trace(
    data = subset(Erg_data_df, Proband == proband_id),
    x = ~nD,
    y = ~PInt_Kinematik_Modell_kg,
    type = "scatter",
    mode = "markers",
    marker = list(size = 9),
    name = paste("Proband", proband_id),
    showlegend = TRUE,
    legendgroup = ~Proband,
    color = ~factor(Proband)
  )
}

```

```{r}
#| label: fig-PInt_Kin_Mod
#| fig-cap: "Körpergewichtsbezogene innere Leistung von P~Int,Kinematik,Modell~ in Abhängigkeit von der Trittrate mit kubischer Modellfunktion (y = 0.00000077x³, R² = 0.985)."
#| fig-cap-location: bottom

# Diagramm anzeigen
plot_PInt_Kin_Mod
```



:::

### Modellvergleich: Einfluss von Körpermasse und Drehzahl auf die innere Leistung { .unlisted }
::: columns
::: {.column width="56%"}
Die nachfolgenden Abbildungen zeigen die berechnete innere Leistung (P~Int~) in Abhängigkeit von Drehzahl und Körpermasse auf Basis des biomechanischen Modells (@fig-PInt_Modell) und die Berechnung nach @Minetti2001 (@fig-PInt_Minetti). Beide Berechnungsmethoden weisen eine nicht-lineare Charakteristik der P~Int~ auf, die sowohl mit steigender Drehzahl als auch mit zunehmender Körpermasse progressiv ansteigt. Diese Systematik manifestiert sich in einer systematisch gestaffelten Verteilung der Kurvenverläufe entsprechend der verschiedenen Körpermassen.
Für einen exemplarischen Vergleich bei 70 kg Körpermasse ergeben sich die P~Int~-Werte der @tbl-PInt_Vergleich.

Während das biomechanische Modell initial einen vergleichbaren Anstieg aufweist, zeigt die Minetti-Berechnung insbesondere bei Trittraten oberhalb von 150 U ⋅ min^-1^ einen deutlich stärkeren Anstieg. Diese abweichenden Charakteristika in den Anstiegen resultieren speziell im hohen Drehzahlbereich in deutlichen Differenzen der absoluten Leistungswerte, wobei die Minetti-Berechnung bei einer Trittrate von 200 U ⋅ min^-1^ nahezu das Dreifache der modellierten Werte erreicht.
:::

::: {.column width="2%"}
:::

::: {.column width="42%"}
| Drehzahl [U·min^-1^] | P~Int,Modell~ [W] | P~Int,Minetti~ [W] |
|----------------------|------------|-------------|
| 60                   | 13.4       | 10.71       |
| 80                   | 31.7       | 33.8        |
| 100                  | 62.0       | 82.6        |
| 120                  | 107.1      | 171.4       |
| 150                  | 209.1      | 418.4       |
| 200                  | 495.6      | 1322.2      |

: Vergleich der P~Int,Modell~ und P~Int,Minetti~ für ausgewählte Drehzahlen. {#tbl-PInt_Vergleich .striped .hover}

:::
:::



::: panel-tabset

### P~Int,Modell~  {.unlisted }


```{r}
# Plotly-Diagramm erstellen
p_PInt_Modell <- plot_ly(P_Int_Drehzahl_Masse, x = ~Drehzahl, y = ~PInt_Ges_Watt, color = ~factor(Masse),
             colors = colorRampPalette(brewer.pal(10,"Spectral"))(20), 
             type = 'scatter', mode = 'lines+markers',
             line = list(dash = 'dash'), marker = list(size = 7)) %>%
  layout(margin = list(t = 50),  # Oberen Rand etwas vergrößern für die kleinere Schrift
          xaxis = list(title = "Drehzahl [min<sup>-1</sup>]",
                     tickvals = seq(0, 200, by = 20)),
         yaxis = list(title = "P<sub>Int,Modell</sub> [Watt]",
                     tickvals = seq(0, 1000, by = 100)),
         legend = list(title = list(text = "Körpermasse [kg]")))

```

```{r}
#| label: fig-PInt_Modell
#| fig-cap: "P<sub>Int,Modell</sub> für verschiedene Körpermassen und Drehzahlen bei den mittleren anthropometrischen Modellparametern aller Probanden (Oberschenkellänge: 41,7 cm, Unterschenkellänge: 55,2 cm, Beinlänge: 122,9 cm, Oberschenkelumfang: 57,2 cm, Unterschenkelumfang: 36,2 cm) und einer theoretischen Kurbellänge von 17,3 cm."
#| fig-cap-location: bottom

p_PInt_Modell
```



### P~Int,Minetti~ { .unlisted }



```{r}
# Daten für verschiedene Massewerte erstellen
masse_values <- seq(40, 120, by = 10)
full_data <- expand.grid(Masse = masse_values, Drehzahl = seq(0, 200, by = 5))
full_data$q <- 0.153
full_data$Testdauer <- 300

# Berechnungen durchführen
full_data <- full_data %>%
  mutate(
    Drehzahl_Hz = Drehzahl / 60,
    Umdrehungen_ges = Drehzahl_Hz * Testdauer,
    Wint_Umdrehung = q * Masse * (Drehzahl_Hz^3),
    Wint_ges_kJ = Wint_Umdrehung * Umdrehungen_ges / 1000,
    P_int_Watt = Wint_ges_kJ * 1000 / Testdauer
  )

# Plotly-Diagramm erstellen
p_PInt_Minetti <- plot_ly(full_data, x = ~Drehzahl, y = ~P_int_Watt, color = ~factor(Masse),
             colors = colorRampPalette(brewer.pal(10,"Spectral"))(20), 
             type = 'scatter', mode = 'lines+markers',
             line = list(dash = 'dash'), marker = list(size = 7)) %>%
  layout(margin = list(t = 50),
         xaxis = list(title = "Drehzahl [min<sup>-1</sup>]",
                     tickvals = seq(0, 200, by = 20)),  # Hier wird tickvals gesetzt
         yaxis = list(title = "P<sub>Int,Minetti</sub> [Watt]",
                     tickvals = seq(0, 2400, by = 200)),
         legend = list(title = list(text = "Körpermasse [kg]")))

```

```{r}
#| label: fig-PInt_Minetti
#| fig-cap: "P<sub>Int,Minetti</sub> für verschiedene Körpermassen und Drehzahlen"
#| fig-cap-location: bottom

p_PInt_Minetti
```


:::


# Quellenverzeichnis
::: {#refs}

:::


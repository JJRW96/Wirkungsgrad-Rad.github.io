---
title: "Aerobe Energiekomponente (W~Aerob~)"

format:
  html:
    resources: 
      - shinylive-sw.js
      
filters:
  - shinylive

execute:
  message: false
  engine: knitr
  echo: false
  warning: false
  error: false
bibliography: references.bib
lang: de
number-sections: false
editor: 
  markdown: 
    wrap: 72
    
---

```{css}
#| echo: false
p {
  text-align: justify
}
caption, .figure-caption {
  text-align: left;
}
figure.quarto-float-tbl figcaption {
  text-align: left !important;
}
figure figcaption {
  text-align: justify;
}
```

```{r}
library(dplyr)
library(tidyr)
library(readxl)
library(ggplot2)
library(DT)
library(extrafont)
library(DT)
library(flextable)
```

```{r echo=FALSE, output=FALSE}
# Stegemann - Zusammenhang zw. dem RQ und dem kalorischen Äquivalent
stegemann <- data.frame(
  RQ = c(0.700, 0.710, 0.720, 0.730, 0.740, 0.750, 0.760, 0.770, 0.780, 0.790, 
         0.800, 0.810, 0.820, 0.830, 0.840, 0.850, 0.860, 0.870, 0.880, 0.890, 
         0.900, 0.910, 0.920, 0.930, 0.940, 0.950, 0.960, 0.970, 0.980, 0.990, 1.000),
  kÄ_O2_kJ_lO2 = c(19.619, 19.636, 19.686, 19.737, 19.791, 19.841, 19.887, 19.946, 20.009, 20.046, 
                   20.101, 20.151, 20.201, 20.256, 20.306, 20.356, 20.411, 20.461, 20.515, 20.561, 
                   20.616, 20.666, 20.716, 20.771, 20.821, 20.871, 20.926, 20.976, 21.026, 21.081, 21.131),
  kÄ_O2_kcal_lO2 = c(4.686, 4.690, 4.702, 4.714, 4.727, 4.739, 4.750, 4.764, 4.779, 4.788, 
                     4.801, 4.813, 4.825, 4.838, 4.850, 4.862, 4.875, 4.887, 4.900, 4.911, 
                     4.924, 4.936, 4.948, 4.961, 4.973, 4.985, 4.998, 5.010, 5.022, 5.035, 5.047)
)

DT_stegemann <- datatable(stegemann, options = list(
  dom = 'tp',  # Tabelle und Paging-Elemente anzeigen
  pageLength = 8,  # 8 Zeilen pro Seite anzeigen
  autoWidth = TRUE,
  columnDefs = list(
    list(title = "RQ", targets = 0),
    list(title = "kÄ<sub>Bel</sub> [kcal &middot; l<sup>-1</sup>]", targets = 2),
    list(title = "kÄ<sub>Bel</sub> [kJ &middot; l<sup>-1</sup>]", targets = 1)
  )
), rownames = FALSE, escape = FALSE) %>%
  formatRound(columns = 1, digits = 2) %>%  # Spalte 1 auf 2 Nachkommastellen runden
  formatRound(columns = 2:3, digits = 3)  # Spalten 2 und 3 auf 3 Nachkommastellen runden
```

Um den aeroben Energieanteil am physiologischen Gesamtenergieumsatz (W~Aerob~) zu bestimmen, muss zu jedem Zeitpunkt t der Sauerstoffvolumenstrom über den Belastungszeitraum ($\dot{V}O_{2,Belastung}(t)$) sowie der Ruheumsatz bekannt sein, welcher dem Sauerstoffvolumenstrom in Ruhe ($\dot{V}O_{2, Ruhe}(t)$) entspricht.

## Bestimmung des Ruheumsatzes

Der Ruheumsatz bezeichnet die Energiemenge für die Aufrechterhaltung der physiologischen Grundfunktionen wie Atmung, Kreislauf, Verdauung und unwillkürlichem Muskeltonus in einem normalen Ruhezustand. Im Gegensatz zum Grundumsatz, der unter streng standardisierten Bedingungen (morgens, nüchtern, liegend) gemessen wird, beschreibt der Ruheumsatz den Energieumsatz in einem alltäglichen Ruhezustand. Die Höhe des Ruheumsatzes wird maßgeblich von individuellen Faktoren wie Körpermasse, Geschlecht, Alter und besonders dem Anteil der stoffwechselaktiven Muskulatur beeinflusst. Für präzise Berechnungen des Energieumsatzes während körperlicher Aktivität dient der Ruheumsatz als Bezugsgröße [@Ciba-Geigy1977, 225].

Für die praktische Bestimmung des Grundumsatzes stehen zwei verschiedene Methoden zur Verfügung: Der Sauerstoffvolumenstrom in Ruhe $\dot{V}O_{2, Ruhe}(t)$ lässt sich entweder durch direkte Messung mittels Spirometrie oder durch Berechnung mittels etablierter Formeln bestimmen. In dieser Arbeit wurden dafür @eq-H und @eq-RMR verwendet. @eq-H ermöglicht die Berechnung des täglichen Grundumsatzes (h) in kcal in Abhängigkeit von Geschlecht, Körpermasse, Körperlänge und Alter [@Harris1918]:

$$
h_{f, m}\,[kcal] = 
\begin{cases} 
h_{f} = 655.1 + (9.563 \cdot \text{Körpermasse [kg]}) + (1.850 \cdot \text{Körperlänge [cm]}) - (4.676 \cdot \text{Alter [Jahre]}) \rightarrow \text{Frauen}\\    
h_{m} = 66.5\; + (13.75 \cdot \text{Körpermasse [kg]}) + (5.003 \cdot \text{Körperlänge [cm]}) - (6.775 \cdot \text{Alter [Jahre]}) \rightarrow \text{Männer}
\end{cases}
$$ {#eq-H}

Nach der Berechnung des Grundumsatzes erfolgte die Bestimmung des kalorischen Äquivalents (kÄ) anhand des individuell gemessenen RQ (t) und @tbl-stegemann, woraus sich der Ruheumsatz (RMR, Englisch für "resting metabolic rate") im Liegen in Liter pro Minute berechnen ließ. Um vom Ruheumsatz im Liegen auf den Ruheumsatz im Stehen zu kommen, wurde der berechnete Ruheumsatz mit dem Faktor $\frac{1.39}{1.08} = 1.287$ für Männer und $\frac{1.15}{0.90} = 1.278$ für Frauen, basierend auf @fig-CIBA_GEIGY, multipliziert [@Ciba-Geigy1977, 225]. Der mit folgender Gleichung berechnete RMR entspricht $\dot{V}O_{2, Ruhe}$:

$$
RMR_{f, m}\,[l \cdot min^{-1}] = 
\begin{cases} 
RMR_{f} = \;\left( \frac{h_{f}}{24\, \cdot\, 60\, \cdot\, kÄ} \right) \cdot 4.1868 \cdot 1.278 \rightarrow \text{Frauen} \\
RMR_{m} = \left( \frac{h_{m}}{24\, \cdot\, 60\, \cdot\, kÄ} \right) \cdot 4.1868 \cdot 1.287 \rightarrow \text{Männer}
\end{cases}
$$ {#eq-RMR}

::: {.callout-note collapse="true"}
#### Abbildung 1: Energieumsatz bei verschiedenen Tätigkeiten (Ciba Geigy, 1977, S.225)
::: columns
::: {.column width="85%"}
![Energieumsatz bei verschiedenen Tätigkeiten (Ciba Geigy, 1977, S.225).](images/Ciba_Geigy_Ruheumsatz.png){#fig-CIBA_GEIGY .caption}
:::

:::

::: {.column width="15%"}
:::

:::

::: columns
::: {.column width="66.0%"}

::: {.callout-note icon="false"}
## RMR-Beispielrechnung

**Parameter:**

-   Körpermasse = 75 kg
-   Körperlänge = 180 cm
-   Alter = 25 Jahre
-   RQ = 0.77 entspricht kÄ von 19.946 [kJ • l^-1^] (siehe @tbl-stegemann)

$h_{m} = 66.5 + (13.75 \cdot \text{75}) + (5.003 \cdot \text{180}) - (6.775 \cdot \text{25}) = 1828.9\, [\text{kcal}]$<br><br>
$RMR_{m} = \left( \frac{1828.9}{24 \cdot 60 \cdot 19.946} \right) \cdot 4.1868 \cdot 1.287 = 0.344\, [l \cdot min^{-1}]$
:::
In der vorliegenden Studie wurde der durchschnittliche $\dot{V}O_{2, Ruhe}$ über einen mehrminütigen Messzeitraum etwa 10 Minuten vor Beginn der ersten Belastung auf dem Fahrradergometer in sitzender Position ermittelt. Zusätzlich erfolgte eine Bestimmung durch die oben beschriebene Berechnungsmethode.<br>
Da aufgrund verschiedener Faktoren, wie beispielsweise Stress, Nahrungsaufnahme oder unterschiedliche Umgebungsbedingungen, die Werte der gemessenen durchschnittlichen $\dot{V}O_{2, Ruhe}$ im Vergleich zu den Normwerten unnatürlich hoch sein können, wurde der gemessene  $\dot{V}O_{2,Ruhe}$-Durchschnittswert nur verwendet, wenn er maximal 20% größer war als der berechnete. Andernfalls wurde der berechnete Wert verwendet.
:::

::: {.column width="2.0%"}
:::

::: {.column width="32.0%"}
```{r}
#| label: tbl-stegemann
#| tbl-cap-location: bottom
#| tbl-cap: "Zusammenhang zwischen dem respiratorischen Koeffizienten und dem kalorischen Äquivalent in [kcal &middot; l<sup>-1</sup>] und [kJ &middot; l<sup>-1</sup>]  (Zuntz, 1901, S.260; Stegemann, 1991, S.59)"

DT_stegemann
```
:::
:::

## Berechnung der aeroben Energiekomponente W~Aerob~

Zur Bestimmung des aeroben Arbeitsumsatzes (W~Aerob~) während eines Belastungszeitraums wurde zunächst der Netto-Sauerstoffvolumenstrom $\dot{V}O_{2,Netto}(t)$ nach @eq-VO2_NET berechnet:

$$
\dot{V}O_{2,Netto}(t)\;[l \cdot min^{-1}] = \dot{V}O_{2,Belastung}(t) - \dot{V}O_{2,Ruhe} (t)
$$ {#eq-VO2_NET}

Der aerobe Anteil am physiologischen Gesamtenergieumsatz (W~Aerob~) konnte durch Multiplikation des mittleren Netto-Sauerstoffvolumenstroms ($\overline{\dot{V}O_{2,Netto}}$) mit der Belastungsdauer t und dem mittleren kalorischen Äquivalent ($\overline{kÄ}_{Bel}$) aus @tbl-stegemann bestimmt werden [@Stegemann1991, 59]:

$$
W_{Aerob}\;[kJ] = \overline{\dot{V}O_{2,Netto}} \cdot \overline{kÄ}_{Bel} \cdot  t
$$ {#eq-WAER}

Die mittlere aerobe Leistung ($\overline{P}_{Aerob}$) wurde durch Division der W~Aerob~ in kJ durch die Belastungsdauer in Sekunden berechnet:

$$
\overline{P}_{Aerob}\;[W] = \frac{W_{Aerob}}{t} \cdot 1000
$$ {#eq-PAER}


## Sauerstoffvolumenstrom-Kinetik

Während die in @eq-WAER beschriebenen Berechnungen der W~Aerob~ auf Durchschnittswerten des $\dot{V}O_{2,Belastung}(t)$ basieren, ermöglicht die Analyse der Kinetik des Sauerstoffvolumenstroms zu Belastungsbeginn und während der Belastung weitere Einblicke in die Charakteristik der aeroben Energiebereitstellung. Von besonderem Interesse sind dabei die Geschwindigkeit der initialen Anpassung sowie das Erreichen oder Ausbleiben eines Fließgleichgewichts und dessen absolute Höhe. Diese Aspekte lassen sich durch die mathematische Modellierung des Sauerstoffvolumenstroms quantifizieren.

Der Anstieg des Sauerstoffvolumenstroms $\dot{V}O_{2,Belastung}(t)$ zu
Beginn einer leichten bis moderaten körperlichen Belastung auf dem
Fahrradergometer unterhalb der Laktatschwelle (LT[^1]) wurde
traditionell in der Literatur als monoexponentiell beschrieben, mit
einer Amplitude von ungefähr 9–10 ml O~2~·W^-1^·min^-1^ [@Barstow1991;
@Bearden2000]. Die Zeitkonstante $\tau_{\text{Start}}$ beschreibt die
Geschwindigkeit, mit der der Sauerstoffvolumenstrom den
Gleichgewichtszustand $\dot{V}O_{2,\text{Brutto, SS}}$ erreicht. Dieser Gleichgewichtszustand, auch Steady-State genannt, zeichnet sich durch ein Gleichgewicht zwischen Energiebedarf und aerober Energiebereitstellung aus, was sich in einem Plateauwert des $\dot{V}O_{2,Belastung}(t)$ widerspiegelt. Dies
lässt sich mit der folgenden Formel darstellen [@Hill1924; @Henry1956;
@Margaria1965; @Whipp1971; @Oezyener2001; @Francescato2003; @Clark2014]:

[^1]: Die LT beschreibt den Punkt, an dem das Blutlaktat bei zunehmender
    Belastungsintensität über das Ruheniveau hinaus zu akkumulieren
    beginnt [@Sietsema2020].

$$
\dot{V}O_{2,\text{Belastung}}\,(t) = \dot{V}O_{2,\text{Amplitude}} \cdot \left(1 - e^{-\frac{t - TD}{\tau_{\text{Start}}}}\right) + \dot{V}O_{2,\text{Start}}
$$ {#eq-VO2_Start}

Dabei beschreibt $\dot{V}O_{2,\text{Start}}$ den Sauerstoffvolumenstrom zu Beginn der Belastung und $\dot{V}O_{2,\text{Amplitude}}$ die Differenz zwischen Start- und Brutto-Steady-State-Wert. Der Brutto-Steady-State-Wert $\dot{V}O_{2,\text{Brutto, SS}}$ ergibt sich aus der Summe von $\dot{V}O_{2,\text{Amplitude}}$ und $\dot{V}O_{2,\text{Start}}$ und wurde in der vorliegenden Untersuchung zum Zeitpunkt 4$\tau$ bestimmt. Durch Subtraktion des Ruhe-Sauerstoffvolumenstroms $\dot{V}O_{2, \text{Ruhe}}$ von diesem Brutto-Steady-State-Wert wurde der Netto-Sauerstoffvolumenstrom $\dot{V}O_{2,\text{Netto, SS}}$ berechnet. Die Wahl des Zeitpunkts 4$\tau$ basiert darauf, dass zu diesem Zeitpunkt bereits 98% des Gesamtanstiegs des Sauerstoffvolumenstroms stattgefunden haben. Das genaue methodische Vorgehen zur Bestimmung der $\dot{V}O_{2,\text{Brutto, SS}}$- und $\dot{V}O_{2,\text{Netto, SS}}$-Werte wird am Ende dieses Kapitels detailliert beschrieben.
<br> In der folgenden Shiny-App wird ein
Beispiel der in @eq-VO2_Start beschriebenen Modellfunktion gezeigt. Eigene $\dot{V}O_{2}$-Daten können hochgeladen und mittels
nichtlinearer Regression an die Beispieldaten angepasst werden.

#### Shiny-App: Monoexponentielle $\dot{V}O_{2}$-Modellfunktion {.unnumbered .unlisted}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)
library(minpack.lm)

# Beispieldaten
t_data <- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)
VO2_data <- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)

# UI
ui <- fluidPage(
  titlePanel("V̇O2-Modellfunktion"),
  fluidRow(
    column(3,
           style = "height: 90vh; overflow-y: auto;",
           
           tags$h4(tags$strong("Modellparameter:")),
           sliderInput("VO2", "V̇O2 Amplitude", min = 0.0, max = 7.0, value = 1.7, step = 0.001),
           sliderInput("Tau", "Tau", min = 5, max = 360, value = 23, step = 1.0),
           sliderInput("VO2_Start", "V̇O2 Start", min = 0.0, max = 4.0, value = 0.4, step = 0.001),
           sliderInput("VO2_Ruhe", "V̇O2 Ruhe", min = 0, max = 1, value = 0.3, step = 0.001),
           sliderInput("time_delay", "Zeitverzögerung", min = 0, max = 300, value = 11, step = 1),
           conditionalPanel(
             condition = "output.showFitSlider",
             sliderInput("nlsLM_end", "nlsLM Ende", min = 10, max = max(t_data), value = max(t_data), step = 1)
           ),
           actionButton("toggle_data", "Beispieldaten einfügen"),
           br(), br(),
           fileInput("file_upload", "CSV-Datei hochladen", accept = ".csv"),
           tags$h4(tags$strong("Modelanpassung:")),
           actionButton("optimize", "nlsLM - Fit"),
           br(), br(),
           tags$h4(tags$strong("Berechnung - Ruhesauerstoffaufnahme:")),
           radioButtons("geschlecht", "Geschlecht:", choices = c("Männlich", "Weiblich")),
           sliderInput("koerpermasse", "Körpermasse [kg]:", min = 40, max = 150, value = 55),
           sliderInput("koerperlaenge", "Körperlänge [cm]:", min = 140, max = 220, value = 160),
           sliderInput("alter", "Alter [Jahre]:", min = 18, max = 100, value = 24),
           sliderInput("rq", "RQ:", min = 0.7, max = 1.0, value = 0.77, step = 0.01),
           actionButton("berechne_vo2_ruhe", "VO2 Ruhe berechnen")
    ),
    mainPanel(
      width = 9,
      plotlyOutput("plot"),
      uiOutput("instructions")
    )
  )
)

# Server
server <- function(input, output, session) {
  show_data <- reactiveVal(FALSE)
  uploaded_data <- reactiveVal(NULL)
  
  observeEvent(input$toggle_data, {
    show_data(!show_data())
    max_t <- max(t_data)
    updateSliderInput(session, "nlsLM_end", min = input$time_delay, max = max_t, value = max_t)
  })
  
  observeEvent(input$file_upload, {
    req(input$file_upload)
    df <- read.csv(input$file_upload$datapath)
    if ("t_s" %in% names(df) && "VO2_t" %in% names(df)) {
      uploaded_data(df)
      show_data(TRUE)
      max_t <- max(df$t_s)
      updateSliderInput(session, "nlsLM_end", min = input$time_delay, max = max_t, value = max_t)
    } else {
      showModal(modalDialog(
        title = "Invalid CSV",
        "Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR
  berechne_grundumsatz <- function(geschlecht, masse, laenge, alter) {
    if (geschlecht == "Männlich") {
      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))
    } else {
      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))
    }
  }
  
  berechne_rmr <- function(grundumsatz, rq, geschlecht) {
    ka <- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig
    faktor <- if(geschlecht == "Männlich") 1.287 else 1.278
    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)
  }
  
  # Reaktion auf den Klick des "VO2 Ruhe berechnen" Buttons
  observeEvent(input$berechne_vo2_ruhe, {
    grundumsatz <- berechne_grundumsatz(
      input$geschlecht,
      input$koerpermasse,
      input$koerperlaenge,
      input$alter
    )
    
    rmr <- berechne_rmr(grundumsatz, input$rq, input$geschlecht)
    
    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert
    updateSliderInput(session, "VO2_Ruhe", value = round(rmr, 3))
    
    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an
    showNotification(paste("Berechnete Ruhesauerstoffaufnahme:", round(rmr, 3), "l/min"), type = "message")
  })
  
  
  
  observe({
    if (input$VO2_Start < input$VO2_Ruhe) {
      updateSliderInput(session, "VO2_Start", value = input$VO2_Ruhe)
    }
  })
  
  output$showFitSlider <- reactive({
    show_data()
  })
  outputOptions(output, "showFitSlider", suspendWhenHidden = FALSE)
  
  observeEvent(input$optimize, {
    if (show_data()) {
      Beispieldaten <- if (is.null(uploaded_data())) {
        data.frame(t_s = t_data, VO2_t = VO2_data)
      } else {
        uploaded_data()
      }
      
      t_delay <- isolate(input$time_delay)
      nlsLM_end <- isolate(input$nlsLM_end)
      
      # Finde den nächstgelegenen Zeitpunkt zu t_delay
      closest_index <- which.min(abs(Beispieldaten$t_s - t_delay))
      
      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes
      VO2_Start <- round(Beispieldaten$VO2_t[closest_index], 3)
      
      updateSliderInput(session, "VO2_Start", value = VO2_Start)
      
      data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay & Beispieldaten$t_s <= nlsLM_end, ]
      
      start_values <- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))
      
      fit <- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,
                       data = data_subset,
                       start = start_values,
                       lower = c(VO2 = 0.5, Tau = 5),
                       upper = c(VO2 = 7.0, Tau = 360),
                       control = nls.control(maxiter = 1024)), silent = TRUE)
      
      if (!inherits(fit, "try-error")) {
        params <- as.list(coef(fit))
        updateSliderInput(session, "VO2", value = params$VO2)
        updateSliderInput(session, "Tau", value = params$Tau)
      } else {
        showModal(modalDialog(
          title = "nlsLM fehlgeschlagen",
          "Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.",
          easyClose = TRUE,
          footer = NULL
        ))
      }
    }
  })
  
  output$plot <- renderPlotly({
    VO2 <- input$VO2
    Tau <- input$Tau
    VO2_Start <- input$VO2_Start
    t_delay <- input$time_delay
    VO2_Ruhe <- input$VO2_Ruhe
    nlsLM_end <- input$nlsLM_end
    
    model_function <- function(t_s, VO2, Tau, VO2_Start, t_delay) {
      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start
    }
    
    Beispieldaten <- if (show_data() && !is.null(uploaded_data())) {
      uploaded_data()
    } else {
      data.frame(t_s = t_data, VO2_t = VO2_data)
    }
    
    tau4 <- 4 * Tau
    max_t <- max(Beispieldaten$t_s, na.rm = TRUE)
    max_x <- max(1.05 * tau4 + t_delay, max_t * 1.05)
    t_s <- seq(0, max_x * 1.20, by = 1)
    model_values <- ifelse(t_s >= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)
    VO2_SS_gross <- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)
    VO2_SS_net <- VO2_SS_gross - VO2_Ruhe
    max_y <- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)
    
    eq_text <- sprintf("V̇O₂ (t) = %.3f * (1 - e<sup>-(t - %.2f) / %.2f</sup>) + %.3f",
                       VO2, t_delay, Tau, VO2_Start)
    VO2_SS_gross_text <- sprintf("V̇O₂ <sub>SS,Brutto</sub>: %.3f", VO2_SS_gross)
    VO2_SS_net_text <- sprintf("V̇O₂ <sub>SS,Netto</sub>: %.3f", VO2_SS_net)
    t_halb <- Tau * log(2)
    
    shapes <- list(
      list(
        type = "line", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.5,
        line = list(color = "gray", width = 1, dash = "dash")
      ),
      list(
        type = "line", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.5,
        line = list(color = "gray", width = 1, dash = "dash")
      ),
      list(
        type = "line", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.5,
        line = list(color = "gray", width = 1, dash = "dash")
      ),
      if (show_data()) {
        list(
          type = "line", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.5,
          line = list(color = "gray", width = 1, dash = "dash")
        )
      },
      list(
        type = "line", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,
        line = list(color = '#1CADE4', width = 1, dash = "solid")
      )
    )
    
    p <- plot_ly() %>%
      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',
                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %>%
      layout(
        title = "V̇O<sub>2</sub>-Modellfunktion",
        margin = list(t = 40),
        xaxis = list(title = "t [s]", range = c(0, max_x)),
        yaxis = list(title = "V̇O<sub>2</sub>(t) [l·min<sup>-1</sup>]", tickformat = ".3f"),
        legend = list(
          x = 0.80,
          y = 0.99,
          xanchor = "left",
          yanchor = "top",
          bgcolor = "rgba(255, 255, 255, 0.3)",
          bordercolor = "rgba(0,0,0,0)",
          borderwidth = 0
        ),
        shapes = shapes,
        annotations = list(
          list(
            x = max_x * 0.60,
            y = max_y * 0.6,
            text = eq_text,
            showarrow = FALSE,
            xanchor = 'left',
            yanchor = 'bottom',
            font = list(
              family = "Arial, sans-serif",
              size = 12,
              color = "black"
            )
          ),
          list(
            x = max_x * 0.60,
            y = max_y * 0.5,
            text = VO2_SS_gross_text,
            showarrow = FALSE,
            xanchor = 'left',
            yanchor = 'bottom',
            font = list(
              family = "Arial, sans-serif",
              size = 12,
              color = "black"
            )
          ),
          list(
            x = max_x * 0.60,
            y = max_y * 0.4,
            text = VO2_SS_net_text,
            showarrow = FALSE,
            xanchor = 'left',
            yanchor = 'bottom',
            font = list(
              family = "Arial, sans-serif",
              size = 12,
              color = "black"
            )
          ),
          list(
            x = max_x * 0.60,
            y = max_y * 0.3,
            text = paste("T<sub>1/2</sub>:", round(t_halb, 1)," s"),
            showarrow = FALSE,
            xanchor = 'left',
            yanchor = 'bottom',
            font = list(
              family = "Arial, sans-serif",
              size = 12,
              color = "black"
            )
          ),
          list(
            x = t_delay, y = max_y * 0.9, text = sprintf("t<sub>delay</sub>: %.1f s", t_delay), 
            showarrow = FALSE, xanchor = "left", yanchor = "bottom",
            textangle = -90, font = list(size = 11)
          ),
          list(
            x = Tau + t_delay, y = max_y * 0.9, text = sprintf("tau: %.1f s", Tau), 
            showarrow = FALSE, xanchor = "left", yanchor = "bottom",
            textangle = -90, font = list(size = 11)
          ),
          list(
            x = tau4 + t_delay, y = max_y * 0.9, text = sprintf("4tau: %.1f s", tau4), 
            showarrow = FALSE, xanchor = "left", yanchor = "bottom",
            textangle = -90, font = list(size = 11)
          ),
          if (show_data()) {
            list(
              x = nlsLM_end, y = max_y * 0.9, text = sprintf("nlsLM Ende: %.1f s", nlsLM_end), 
              showarrow = FALSE, xanchor = "left", yanchor = "bottom",
              textangle = -90, font = list(size = 11)
            )
          }
        )) %>%
      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',
                name = 'V̇O<sub>2, Ruhe</sub>', line = list(color = '#1CADE4'))
    
    if (show_data()) {
      model_values_at_data <- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)
      
      data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay & Beispieldaten$t_s <= input$nlsLM_end, ]
      
      ss_res <- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s >= t_delay & Beispieldaten$t_s <= input$nlsLM_end])^2, na.rm = TRUE)
      ss_tot <- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)
      r_squared <- 1 - (ss_res / ss_tot)
      
      p <- p %>%
        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',
                  name = 'V̇O<sub>2</sub>', 
                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),
                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %>%
        layout(annotations = list(
          list(
            x = max_x * 0.60,
            y = max_y * 0.2,
            text = sprintf("R²: %.3f", r_squared),
            showarrow = FALSE,
            xanchor = 'left',
            yanchor = 'bottom',
            font = list(
              family = "Arial, sans-serif",
              size = 12,
              color = "black"
            )
          )
        ))
    }
    
    p
  })
  output$instructions <- renderUI({
    HTML(
      "<div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'>
        <h4 style='color: #333;'><strong>Anleitung - Modellanpassung:</strong></h4>
        <ol style='color: #555; list-style-position: outside; padding-left: 20px;'>
          <li>Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.</li>
          <li>Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.</li>
          <li>Modellanpassung 'Fit: nlsLM' durchführen.</li>
          <li>Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.</li>
        </ol>
        <div style='margin-top: 20px;'></div>
        <pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'>
VO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:
t_s,VO2_t
0.0,0.479
1.0,0.459
2.3,0.488
…
        </pre>
      </div>"
    )
  })
}

# App ausführen
shinyApp(ui = ui, server = server)
```

::: {.callout-note icon="false" collapse="true" appearance="simple"}
#### **Modellanpassung - Details:** {.unnumbered .unlisted}

**nlsLM - Fit:**

-   Verwendete Funktion: nlsLM
-   Parameter: V̇O2 (Amplitude), Tau
-   Modell: V̇O2_t \~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start
-   Grenzen:
    -   V̇O2: *0.5 bis 7.0 l/min*
    -   Tau: *5 bis 360 s*
-   Prozess:
    a)  Bestimmung des V̇O2_Start-Wertes:
        -   Finden des nächstgelegenen Zeitpunkts zu t_delay in den
            Daten
        -   Setzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses
            Punktes
    b)  Datenauswahl:
        -   Verwendung der Daten zwischen *t_delay* und *nlsLM_end*
    c)  Startwertebestimmung:
        -   Verwendung der aktuellen Slider-Werte für V̇O2 und Tau
    d)  Durchführung der nicht-linearen Regression:
        -   Verwendung des Levenberg-Marquardt-Algorithmus
        -   Maximale Iterationen: *1024*
-   Optimierung: Minimierung der Residuenquadratsumme (RSS)
:::

## Drei-Phasen-Modell {.unnumbered .unlisted}

Die Analyse der $\dot{V}O_{2}(t)$-Kinetik kann durch die Berücksichtigung
von Zeitverzögerungen und/oder Exponentialfunktionen zweiter Ordnung
verfeinert werden. Dazu kann die Anpassungsreaktion des
$\dot{V}O_{2}\,(t)$ nach Beginn der sportlichen Betätigung in
drei Phasen unterteilt werden, wie in @fig-3_Phasen zu sehen
[@Whipp1982]. Dies ermöglicht es, die erhöhte Komplexität der
$\dot{V}O_{2}$-Kinetik oberhalb der LT besser darzustellen und eine
präzisere Analyse der physiologischen Anpassungen bei körperlicher
Belastung durchzuführen, da oberhalb der LT der $\dot{V}O_2$-Umsatz über
10 ml O~2~·W^-1^·min^-1^ steigt [@Barstow1994; @Bearden2000;
@Sietsema2020]. Die 3 Phasen lassen sich wie folgt beschreiben:

:::::: columns
::: {.column width="72%"}
![Beispiel der Drei-Phasen der VO2-Kinetik bis zum Erreichen eines SS
nach Beginn der Belastung (McNulty & Robergs,
2017)](images/McNulty2017_VO2_3_Phase.png){#fig-3_Phasen height="500"}
:::

::: {.column width="2%"}
:::

::: {.column width="25%"}
:::
::::::

:::::: columns
::: {.column width="60%"}
**Phase 1:**<br> Phase I, häufig als kardiodynamische Phase bezeichnet,
umfasst ungefähr die ersten 10 bis 25 Sekunden nach Beginn der
Belastung. Aufgrund des schnellen Anstiegs des Herzzeitvolumens und des
Lungenblutflusses zu Beginn der Belastung steigt
$\dot{V}O_2\,(t)$ abrupt an. In dieser Phase bleibt die
Zusammensetzung des gemischtvenösen Blutes sowie der respiratorische
Quotient
$RQ\,(t) = \frac{\dot{V}CO_{2}\,(t)}{\dot{V}O_{2}\,(t)}$
im Vergleich zum Ruhezustand unverändert. Somit ist der Anstieg des
$\dot{V}O_2\,(t)$ ausschließlich auf das erhöhte
Herzminutenvolumen zurückzuführen, da sich die Sauerstoffkonzentration
im arteriellen und venösen Blut (C~a~ und C~v~) noch nicht verändert
haben. Dies lässt sich mit Hilfe der Fick'schen Gleichung @eq-FICK
verdeutlichen [@Fick1855; @Whipp1982; @Stirling2005; @Clark2014;
@Sietsema2020].

$$
\dot{V}O_2 = \dot{Q} \cdot (C_a - C_v) 
$$ {#eq-FICK}

Da die anfängliche „kardiodynamische“ Phase der $\dot{V}O_2$-Reaktion
nicht direkt den Sauerstoffumsatz der aktiven Muskulatur repräsentiert,
werden in der Regel die ersten 20 bis 25 Sekunden von Phase I bei
Modellierungen der $\dot{V}O_2$-Kinetik aus der Modellanpassung
ausgeschlossen [@Bearden2000; @Oezyener2001].

**Phase 2:**<br> Phase 2 folgt auf Phase 1 und ist durch einen
schnellen, monoexponentiellen Anstieg des $\dot{V}O_2$ gekennzeichnet.
Die Zeitkonstante beträgt im Durchschnitt etwa 30 [@Sietsema2020] bis 33
Sekunden [@Oezyener2001]. Anschließend wird entweder ein SS erreicht
oder der $\dot{V}O_2$ steigt weiter an, was dann in dem Modell als Phase
3 bezeichnet wird [@Stirling2005].

**Phase 3:**<br> In Phase 3 des $\dot{V}O_2$-Modells wird bei leichten
bis moderaten Belastungen unterhalb der Laktatschwelle (LT) nach etwa 3
Minuten ein stabiler Zustand (SS) erreicht. Dieses Verhalten beschreibt,
wie der $\dot{V}O_2$ sich im 3-Phasen-Modell für Belastungen unterhalb
der LT verhält. Bei Belastungen oberhalb der LT erreicht der
$\dot{V}O_2$ nach der primären Anpassungsreaktion keinen SS mehr,
sondern steigt weiter an (siehe @fig-Verlauf_ON). Diese zusätzliche
Komponente, meist als "slow component" bezeichnet, überlagert die
anfängliche monoexponentielle Funktion aus Phase 2.
:::

::: {.column width="2%"}
:::

::: {.column width="38%"}
![Beispiele der VO<sub>2</sub>-Anstiegskinetik eines Probanden für
verschiedene Belastungsintensitäten: sehr intensiv, schwer, mittelschwer
und moderat (von oben nach unten). Unterhalb der VO<sub>2</sub>-Daten
ist der entsprechende Residuenplot zu sehen. In Spalte A wird eine
Modellfunktion mit mono-exponentieller Kurvenanpassung gezeigt, in
Spalte B eine mit bi-exponentieller Anpassung (Özyener,
2001).](images/Ozyener_ON.png){#fig-Verlauf_ON}
:::
::::::

Mathematische Modellierungen haben gezeigt, dass die langsame Komponente
etwa 90 bis 200 Sekunden nach Beginn des Übergangs einsetzt [@Whipp1972;
@Barstow1991; @Bearden2000; @Sietsema2020]. Die Komponente der
Anpassungsreaktion bis zum Beginn der slow component wird in der
Literatur oft als "primary component" oder "fundamental component"
bezeichnet [@Barstow1994; @Oezyener2001]. Im Folgenden wird diese
Hauptkomponente mit dem Index "fast" gekennzeichnet.

### Biexponentielle $\dot{V}O_{2}$-Modellfunktion {.unnumbered .unlisted}

Phase 2 und 3 des 3-Phasen-Modells lassen sich mit Hilfe der
@eq-VO2_Start modellieren:

$$
\dot{V}O_2\,(t) = \dot{V}O_{2,\text{fast}} \cdot \left(1 - e^{-\frac{t_s - t_\text{delay, fast}}{\tau_\text{fast}}}\right) + 
\dot{V}O_{2,\text{slow}} \cdot \left(1 - e^{-\frac{t_s - t_\text{delay,slow}}{\tau_\text{slow}}}\right) + 
\dot{V}O_{2,\text{Start}}
$$

$\dot{V}O_{2,\text{fast}}$ repräsentiert die Amplitude der
Hauptkomponente, während $\dot{V}O_{2,\text{slow}}$ die Amplitude der
slow component beschreibt. Die Zeitkonstanten $\tau_\text{fast}$ und
$\tau_\text{slow}$ steuern die Geschwindigkeit der jeweiligen
Reaktionsprozesse, wobei die Zeitverzögerungen $t_\text{delay, fast}$
und $t_\text{delay, slow}$ den Beginn dieser Prozesse bestimmen.
$\dot{V}O_{2,\text{Start}}$ beschreibt den Sauerstoffvolumenstrom zu
Beginn der Belastung.

In der folgenden Shiny-App wird die Modellanpassung der Gleichung
@eq-VO2_Start an Beispieldaten demonstriert. Eigene
$\dot{V}O_{2}(t)$-Daten können hochgeladen und mittels nichtlinearer
Regression an die Modellparameter angepasst werden.

#### Biexponentielle $\dot{V}O_{2}$-Shiny-App {.unnumbered .unlisted}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)
library(minpack.lm)
library(dplyr)
library(shinyjs)

# Beispieldaten
t_data <- c(0.0, 2.7, 5.3, 8.3, 11.5, 13.6, 15.4, 17.1, 19.8, 21.1, 22.3, 23.5, 24.9, 27.5, 30.9, 32.4, 35.0, 38.3, 39.7, 41.6, 43.7, 45.3, 46.8, 49.8, 52.0, 53.6, 55.5, 57.5, 59.0, 60.7, 62.4, 64.4, 66.6, 68.1, 69.8, 71.4, 73.3, 75.0, 76.7, 78.4, 80.0, 82.2, 83.9, 85.4, 87.3, 88.8, 90.6, 92.0, 93.6, 94.8, 96.3, 97.9, 99.5, 101.1, 102.7, 104.3, 106.0, 107.7, 109.3, 110.9, 112.5, 114.8, 116.4, 118.1, 119.7, 121.3, 122.8, 124.3, 125.9, 127.4, 128.9, 130.6, 132.1, 133.6, 135.6, 137.1, 138.6, 140.1, 141.6, 143.1, 144.4, 145.8, 147.2, 148.4, 149.9, 151.6, 153.1, 154.7, 156.1, 157.4, 158.7, 160.5, 161.9, 163.3, 164.7, 166.2, 167.6, 169.1, 172.6, 173.9, 175.4, 176.7, 178.1, 179.6, 181.0, 182.4, 183.8, 185.3, 186.7, 188.2, 189.6, 191.0, 192.4, 193.8, 195.2, 196.6, 198.0, 199.3, 200.7, 202.0, 203.3, 204.7, 206.1, 207.5, 208.8, 210.2, 211.6, 213.0, 214.3, 215.7, 217.1, 218.4, 219.8, 221.1, 222.4, 223.7, 225.0, 226.3, 227.7, 229.0, 230.5, 231.9, 233.1, 234.4)
VO2_data <- c(0.823, 0.898, 0.966, 1.122, 1.281, 1.313, 1.463, 1.537, 1.602, 1.595, 1.598, 1.674, 1.923, 2.168, 2.439, 2.670, 2.797, 2.712, 2.688, 2.968, 3.228, 3.371, 3.673, 3.938, 4.076, 3.959, 3.886, 3.880, 3.928, 3.962, 4.173, 4.381, 4.268, 4.208, 4.234, 4.132, 4.109, 4.192, 4.304, 4.493, 4.352, 4.349, 4.332, 4.346, 4.345, 4.373, 4.320, 4.286, 4.353, 4.346, 4.287, 4.322, 4.250, 4.332, 4.257, 4.161, 4.120, 4.144, 4.115, 4.158, 4.186, 4.206, 4.220, 4.259, 4.291, 4.279, 4.295, 4.339, 4.371, 4.425, 4.448, 4.474, 4.517, 4.536, 4.544, 4.528, 4.432, 4.371, 4.367, 4.430, 4.492, 4.535, 4.510, 4.433, 4.399, 4.305, 4.308, 4.304, 4.366, 4.434, 4.501, 4.535, 4.512, 4.463, 4.509, 4.529, 4.586, 4.624, 4.740, 4.769, 4.788, 4.794, 4.824, 4.830, 4.888, 4.887, 4.915, 4.924, 4.955, 4.965, 4.982, 4.992, 5.016, 5.024, 5.033, 5.066, 5.081, 5.053, 5.035, 4.997, 5.018, 5.038, 5.035, 5.039, 4.970, 4.970, 4.973, 4.964, 4.945, 4.953, 4.974, 4.984, 4.997, 4.995, 4.946, 4.997, 5.014, 5.092, 5.072, 5.111, 5.088, 5.065, 5.061, 5.038)

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Bi-exponentielle V̇O2-Modellfunktion"),
  fluidRow(
    column(3,
           style = "height: 90vh; overflow-y: auto;",
           
           tags$h4(tags$strong("Modellparameter:")),
           sliderInput("VO2", "V̇O2_fast", min = 0.0, max = 7.0, value = 3.7, step = 0.01),
           sliderInput("tau_fast", "Tau_fast", min = 10, max = 120, value = 45, step = 0.1),
           sliderInput("VO2_Start", "V̇O2_Start", min = 0.0, max = 4.0, value = 0.8, step = 0.01),
           sliderInput("VO2_Ruhe", "V̇O2_Ruhe", min = 0, max = 1, value = 0.4, step = 0.1),
           sliderInput("time_delay", "Zeitverzögerung_fast", min = 0, max = 600, value = 0, step = 1),
           sliderInput("VO2_slow", "V̇O2_slow", min = 0.0, max = 1.0, value = 0.3, step = 0.01),
           sliderInput("tau_slow", "Tau_slow", min = 90, max = 600, value = 110, step = 0.1),
           sliderInput("time_delay_slow", "Zeitverzögerung_slow", min = 0, max = 1200, value = 160, step = 1),
           conditionalPanel(
             condition = "output.showFitSlider",
             sliderInput("nlsLM_end", "nlsLM Ende", min = 10, max = 300, value = 300, step = 1)
           ),
           actionButton("toggle_data", "Beispieldaten einfügen"),
           br(), br(),
           fileInput("file_upload", "CSV-Datei hochladen", accept = ".csv"),
           tags$h4(tags$strong("Modellanpassung:")),
           actionButton("fit_fast", "1. Fit: Schnelle Komponente"),br(),
           actionButton("fit_slow", "2. Fit: Langsame Komponente & Verfeinerung"),br(),
           actionButton("fit_optimize", "3. Fit: Optimierung")
    ),
    mainPanel(
      width = 9,
      plotlyOutput("plot"),
      uiOutput("instructions")
    )
  )
)

# Server
server <- function(input, output, session) {
  show_data <- reactiveVal(FALSE)
  uploaded_data <- reactiveVal(NULL)
  current_data <- reactiveVal(NULL)
  current_r_squared <- reactiveVal(NA)
  
  calculate_r_squared <- function(observed, predicted) {
    ss_res <- sum((observed - predicted)^2, na.rm = TRUE)
    ss_tot <- sum((observed - mean(observed, na.rm = TRUE))^2, na.rm = TRUE)
    return(1 - (ss_res / ss_tot))
  }
  
  observeEvent(input$toggle_data, {
    show_data(!show_data())
    if (show_data()) {
      current_data(data.frame(t_s = t_data, VO2_t = VO2_data))
    } else {
      current_data(NULL)
    }
  })
  
  observeEvent(input$file_upload, {
    req(input$file_upload)
    df <- read.csv(input$file_upload$datapath)
    if ("t_s" %in% names(df) && "VO2_t" %in% names(df)) {
      uploaded_data(df)
      current_data(df)
      show_data(TRUE)
    } else {
      showModal(modalDialog(
        title = "Invalid CSV",
        "Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  observe({
    req(input$VO2_Start, input$VO2_Ruhe)
    if (input$VO2_Start < input$VO2_Ruhe) {
      updateSliderInput(session, "VO2_Start", value = input$VO2_Ruhe)
    }
  })
  
  # Hilfsfunktion zur Bestimmung des nächstgelegenen VO2-Wertes
  find_nearest_VO2 <- function(data, t_delay) {
    req(data, t_delay)
    if (nrow(data) == 0) return(NA)
    
    index <- which.min(abs(data$t_s - t_delay))
    return(data$VO2_t[index])
  }
  
  
  observeEvent(input$fit_fast, {
    req(current_data())
    Beispieldaten <- current_data()
    
    t_delay <- isolate(input$time_delay)
    
    # Bestimme den nächstgelegenen VO2-Wert als VO2_Start
    VO2_Start <- find_nearest_VO2(Beispieldaten, t_delay)
    
    # Aktualisiere den VO2_Start Slider
    updateSliderInput(session, "VO2_Start", value = VO2_Start)
    
    data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay, ]
    
    best_fit <- NULL
    best_rss <- Inf
    
    withProgress(message = 'Fitting in progress', value = 0, {
      for (i in 1:100) {
        # Randomisierte Startwerte innerhalb der Slider-Grenzen
        VO2_start <- runif(1, 0.5, 7.0)
        tau_fast_start <- runif(1, 10, 120)
        
        start_values <- list(
          VO2 = VO2_start,
          tau_fast = tau_fast_start
        )
        
        fit <- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + VO2_Start,
                         data = data_subset,
                         start = start_values,
                         lower = c(VO2 = 0.5, tau_fast = 10),
                         upper = c(VO2 = 7.0, tau_fast = 120),
                         control = nls.control(maxiter = 1024)), silent = TRUE)
        
        if (!inherits(fit, "try-error")) {
          rss <- sum(residuals(fit)^2)
          if (rss < best_rss) {
            best_rss <- rss
            best_fit <- fit
          }
        }
        
        incProgress(1/100, detail = paste("Iteration", i))
      }
    })
    
    if (!is.null(best_fit)) {
      params <- as.list(coef(best_fit))
      updateSliderInput(session, "VO2", value = params$VO2)
      updateSliderInput(session, "tau_fast", value = params$tau_fast)
      updateSliderInput(session, "VO2_slow", value = 0)
      updateSliderInput(session, "tau_slow", value = 0)
      
      predicted <- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast))
      r_squared <- calculate_r_squared(data_subset$VO2_t, predicted)
      current_r_squared(r_squared)
      
      showNotification(sprintf("Schritt 1 erfolgreich. R²: %.3f", r_squared), type = "message")
    } else {
      showModal(modalDialog(
        title = "nlsLM fehlgeschlagen",
        "Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  observeEvent(input$fit_slow, {
    req(current_data())
    Beispieldaten <- current_data()
    
    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast)
    
    t_delay <- input$time_delay
    VO2_Start <- input$VO2_Start
    VO2 <- input$VO2
    tau_fast <- input$tau_fast
    
    # Setze VO2_slow und tau_slow auf die initialen Werte
    VO2_slow <- 0.4
    tau_slow <- 160
    
    data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay, ]
    
    # Berechne die obere Grenze für t_delay_slow
    t_delay_slow_upper <- max(Beispieldaten$t_s)
    
    best_fit <- NULL
    best_rss <- Inf
    best_t_delay_slow <- NULL
    best_VO2_fast <- VO2
    best_tau_fast <- tau_fast
    best_VO2_slow <- VO2_slow
    best_tau_slow <- tau_slow
    
    # Berechne die Anzahl der Iterationen für t_delay_slow
    num_iterations <- floor(t_delay_slow_upper - (tau_fast + t_delay)) + 1
    
    withProgress(message = 'Fitting in progress', value = 0, {
      for (i in 1:num_iterations) {
        t_delay_slow <- tau_fast + t_delay + i - 1
        
        # Fit VO2_fast und tau_fast nach unten
        current_VO2_fast <- best_VO2_fast
        current_tau_fast <- best_tau_fast
        current_VO2_slow <- best_VO2_slow
        current_tau_slow <- best_tau_slow
        
        model <- function(VO2_fast, tau_fast, VO2_slow, tau_slow, t_delay_slow) {
          VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast)) + 
            VO2_slow * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow, 0)) / tau_slow)) + 
            VO2_Start
        }
        
        current_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)
        
        # Optimiere VO2_fast und tau_fast
        while (TRUE) {
          improved <- FALSE
          
          # Versuche VO2_fast zu reduzieren
          if (current_VO2_fast > 0.1) {
            new_VO2_fast <- max(0.1, current_VO2_fast - 0.01)
            new_rss <- sum((data_subset$VO2_t - model(new_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)
            if (new_rss < current_rss) {
              current_VO2_fast <- new_VO2_fast
              current_rss <- new_rss
              improved <- TRUE
            }
          }
          
          # Versuche tau_fast zu reduzieren
          if (current_tau_fast > 10) {
            new_tau_fast <- max(10, current_tau_fast - 0.1)
            new_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, new_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)
            if (new_rss < current_rss) {
              current_tau_fast <- new_tau_fast
              current_rss <- new_rss
              improved <- TRUE
            }
          }
          
          if (!improved) break
        }
        
        # Optimiere VO2_slow und tau_slow
        # Zuerst nach unten
        while (TRUE) {
          improved <- FALSE
          
          # Versuche VO2_slow zu reduzieren
          if (current_VO2_slow > 0.05) {
            new_VO2_slow <- max(0.05, current_VO2_slow - 0.01)
            new_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)
            if (new_rss < current_rss) {
              current_VO2_slow <- new_VO2_slow
              current_rss <- new_rss
              improved <- TRUE
            }
          }
          
          # Versuche tau_slow zu reduzieren
          if (current_tau_slow > 90) {
            new_tau_slow <- max(90, current_tau_slow - 0.1)
            new_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)
            if (new_rss < current_rss) {
              current_tau_slow <- new_tau_slow
              current_rss <- new_rss
              improved <- TRUE
            }
          }
          
          if (!improved) break
        }
        
        # Dann nach oben
        while (TRUE) {
          improved <- FALSE
          
          # Versuche VO2_slow zu erhöhen
          if (current_VO2_slow < 1.0) {  # Angenommen, 1.0 ist die obere Grenze für VO2_slow
            new_VO2_slow <- min(1.0, current_VO2_slow + 0.01)
            new_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)
            if (new_rss < current_rss) {
              current_VO2_slow <- new_VO2_slow
              current_rss <- new_rss
              improved <- TRUE
            }
          }
          
          # Versuche tau_slow zu erhöhen
          new_tau_slow <- current_tau_slow + 0.1
          new_rss <- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)
          if (new_rss < current_rss) {
            current_tau_slow <- new_tau_slow
            current_rss <- new_rss
            improved <- TRUE
          }
          
          if (!improved) break
        }
        
        if (current_rss < best_rss) {
          best_rss <- current_rss
          best_t_delay_slow <- t_delay_slow
          best_VO2_fast <- current_VO2_fast
          best_tau_fast <- current_tau_fast
          best_VO2_slow <- current_VO2_slow
          best_tau_slow <- current_tau_slow
        }
        
        incProgress(1 / num_iterations, detail = paste("Iteration", i, "von", num_iterations))
      }
    })
    
    if (!is.null(best_t_delay_slow)) {
      updateSliderInput(session, "time_delay_slow", value = best_t_delay_slow)
      updateSliderInput(session, "VO2", value = best_VO2_fast)
      updateSliderInput(session, "tau_fast", value = best_tau_fast)
      updateSliderInput(session, "VO2_slow", value = best_VO2_slow)
      updateSliderInput(session, "tau_slow", value = best_tau_slow)
      
      predicted <- VO2_Start + best_VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / best_tau_fast)) +
        best_VO2_slow * (1 - exp(-(pmax(data_subset$t_s - best_t_delay_slow, 0)) / best_tau_slow))
      r_squared <- calculate_r_squared(data_subset$VO2_t, predicted)
      current_r_squared(r_squared)
      
      showNotification(sprintf("Schritt 2 erfolgreich. R²: %.3f", r_squared), type = "message")
    } else {
      showModal(modalDialog(
        title = "Fit fehlgeschlagen",
        "Die Anpassung für die langsame Komponente konnte nicht erfolgreich durchgeführt werden.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  observeEvent(input$fit_optimize, {
    req(current_data())
    Beispieldaten <- current_data()
    
    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$time_delay_slow)
    
    t_delay <- input$time_delay
    VO2_Start <- input$VO2_Start
    
    data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay, ]
    
    # Werte aus Schritt 2
    VO2_step2 <- input$VO2
    tau_fast_step2 <- input$tau_fast
    VO2_slow_step2 <- input$VO2_slow
    tau_slow_step2 <- input$tau_slow
    t_delay_slow_step2 <- input$time_delay_slow
    
    # Berechne R² für Schritt 2
    step2_predicted <- VO2_Start + VO2_step2 * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast_step2)) +
      VO2_slow_step2 * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow_step2, 0)) / tau_slow_step2))
    step2_r_squared <- calculate_r_squared(data_subset$VO2_t, step2_predicted)
    
    best_fit <- NULL
    best_rss <- Inf
    
    withProgress(message = 'Optimierung läuft', value = 0, {
      for (i in 1:1000) {
        # Randomisierte Startwerte innerhalb der festgelegten Grenzen
        VO2_start <- runif(1, VO2_step2 * 0.98, VO2_step2 * 1.02)
        tau_fast_start <- runif(1, max(10, tau_fast_step2 - 3), tau_fast_step2 + 3)
        VO2_slow_start <- runif(1, VO2_slow_step2 * 0.98, VO2_slow_step2 * 1.02)
        tau_slow_start <- runif(1, max(90, tau_slow_step2 - 3), tau_slow_step2 + 3)
        t_delay_slow_start <- runif(1, max(0, t_delay_slow_step2 - 5), t_delay_slow_step2 + 5)
        
        start_values <- list(
          VO2 = VO2_start,
          tau_fast = tau_fast_start,
          VO2_slow = VO2_slow_start,
          tau_slow = tau_slow_start,
          t_delay_slow = t_delay_slow_start
        )
        
        fit <- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + 
                           VO2_slow * (1 - exp(-(t_s - t_delay_slow) / tau_slow)) + VO2_Start,
                         data = data_subset,
                         start = start_values,
                         lower = c(VO2 = VO2_step2 * 0.98, 
                                   tau_fast = max(10, tau_fast_step2 - 3), 
                                   VO2_slow = VO2_slow_step2 * 0.98, 
                                   tau_slow = max(90, tau_slow_step2 - 3), 
                                   t_delay_slow = max(0, t_delay_slow_step2 - 5)),
                         upper = c(VO2 = VO2_step2 * 1.02, 
                                   tau_fast = tau_fast_step2 + 3, 
                                   VO2_slow = VO2_slow_step2 * 1.02, 
                                   tau_slow = tau_slow_step2 + 3, 
                                   t_delay_slow = t_delay_slow_step2 + 5),
                         control = nls.control(maxiter = 1024)), silent = TRUE)
        
        if (!inherits(fit, "try-error")) {
          rss <- sum(residuals(fit)^2)
          if (rss < best_rss) {
            best_rss <- rss
            best_fit <- fit
          }
        }
        
        incProgress(1/1000, detail = paste("Iteration", i))
      }
    })
    
    if (!is.null(best_fit)) {
      params <- as.list(coef(best_fit))
      step3_predicted <- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast)) +
        params$VO2_slow * (1 - exp(-(pmax(data_subset$t_s - params$t_delay_slow, 0)) / params$tau_slow))
      step3_r_squared <- calculate_r_squared(data_subset$VO2_t, step3_predicted)
      
      if (step3_r_squared > step2_r_squared) {
        updateSliderInput(session, "VO2", value = params$VO2)
        updateSliderInput(session, "tau_fast", value = params$tau_fast)
        updateSliderInput(session, "VO2_slow", value = params$VO2_slow)
        updateSliderInput(session, "tau_slow", value = params$tau_slow)
        updateSliderInput(session, "time_delay_slow", value = params$t_delay_slow)
        
        current_r_squared(step3_r_squared)
        showNotification(sprintf("Optimierung erfolgreich. Neues R²: %.3f", step3_r_squared), type = "message")
      } else {
        current_r_squared(step2_r_squared)
        showNotification(sprintf("Kein besserer Fit gefunden. Ergebnisse von Schritt 2 beibehalten. R²: %.3f", step2_r_squared), type = "warning")
      }
    } else {
      current_r_squared(step2_r_squared)
      showNotification(sprintf("Optimierung fehlgeschlagen. Ergebnisse von Schritt 2 beibehalten. R²: %.3f", step2_r_squared), type = "warning")
    }
  })
  
  output$plot <- renderPlotly({
    req(input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$VO2_Start, input$time_delay, input$time_delay_slow, input$VO2_Ruhe)
    
    VO2 <- input$VO2
    tau_fast <- input$tau_fast
    VO2_slow <- input$VO2_slow
    tau_slow <- input$tau_slow
    VO2_Start <- input$VO2_Start
    t_delay <- input$time_delay
    t_delay_slow <- input$time_delay_slow
    VO2_Ruhe <- input$VO2_Ruhe
    
    model_function <- function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow) {
      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast)) + 
        pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0) + 
        VO2_Start
    }
    
    model_fast <- function(t_s, VO2, tau_fast, t_delay) {
      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast))
    }
    
    model_slow <- function(t_s, VO2_slow, tau_slow, t_delay_slow) {
      pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0)
    }
    
    Beispieldaten <- current_data()
    
    max_t <- if (!is.null(Beispieldaten) && nrow(Beispieldaten) > 0) max(Beispieldaten$t_s, na.rm = TRUE) else 300
    max_x <- max_t * 1.20
    t_s <- seq(0, max_x * 1.20, by = 1)
    
    model_values <- ifelse(t_s >= t_delay, model_function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow), NA)
    fast_values <- ifelse(t_s >= t_delay, model_fast(t_s, VO2, tau_fast, t_delay), NA)
    slow_values <- ifelse(t_s >= t_delay_slow, model_slow(t_s, VO2_slow, tau_slow, t_delay_slow), NA)
    
    max_y <- if (!is.null(Beispieldaten) && nrow(Beispieldaten) > 0) max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05 else max(model_values, na.rm = TRUE) * 1.05
    
    eq_text <- sprintf("V̇O₂ (t) = %.2f * (1 - e<sup>-(t - %.0f) / %.1f</sup>) + %.2f * (1 - e<sup>-(t - %.1f) / %.0f</sup>) + %.2f",
                       VO2, t_delay, tau_fast, VO2_slow, t_delay_slow, tau_slow, VO2_Start)
    t_halb <- tau_fast * log(2)
    
    shapes <- list(
      list(
        type = "line", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.5,
        line = list(color = "gray", width = 1, dash = "dash")
      ),
      list(
        type = "line", x0 = t_delay_slow, x1 = t_delay_slow, y0 = 0, y1 = max_y * 1.5,
        line = list(color = "gray", width = 1, dash = "dash")
      )
    )
    
    p <- plot_ly() %>%
      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',
                name = 'V̇O2-Modellfunktion', line = list(color = '#EF6F6A')) %>%
      add_trace(x = ~t_s, y = ~fast_values, type = 'scatter', mode = 'lines', 
                name = 'V̇O<sub>2</sub><sub>,fast</sub>', line = list(color = '#42BA97')) %>%
      add_trace(x = ~t_s, y = ~slow_values, type = 'scatter', mode = 'lines', 
                name = 'V̇O<sub>2</sub><sub>,slow</sub>', line = list(color = '#BB7693')) %>%
      layout(title = "Biexponentielle V̇O<sub>2</sub>-Modellfunktion",
             margin = list(t = 40),
             xaxis = list(title = "t [s]", range = c(0, max_x)),
             yaxis = list(title = "V̇O<sub>2</sub> (t) [l·min<sup>-1</sup>]", tickformat = ".1f"),
             legend = list(
               x = 0.05,
               y = 0.99,
               xanchor = "left",
               yanchor = "top",
               bgcolor = "rgba(255, 255, 255, 0.3)",
               bordercolor = "rgba(0,0,0,0)",
               borderwidth = 0
             ),
             shapes = shapes,
             annotations = list(
               list(
                 x = max_x * 0.35,
                 y = max_y * 0.3,
                 text = eq_text,
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   family = "Arial, sans-serif",
                   size = 10,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.35,
                 y = max_y * 0.2,
                 text = paste("T<sub>1/2</sub>:", round(t_halb, 1)," s"),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   family = "Arial, sans-serif",
                   size = 10,
                   color = "black"
                 )
               ),
               list(
                 x = t_delay, y = max_y * 0.85, text = sprintf("t<sub>delay</sub>: %.1f s", t_delay), showarrow = FALSE, xanchor = "left", yanchor = "bottom",
                 textangle = -90, font = list(size = 11)
               ),
               list(
                 x = t_delay_slow, y = max_y * 0.85, text = sprintf("t<sub>delay_slow</sub>: %.1f s", t_delay_slow), showarrow = FALSE, xanchor = "left", yanchor = "bottom",
                 textangle = -90, font = list(size = 11)
               )
             )) %>%
      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',
                name = 'V̇O<sub>2,Ruhe</sub>', line = list(color = '#1CADE4'))
    
    if (show_data() && !is.null(Beispieldaten) && nrow(Beispieldaten) > 0) {
      data_subset <- Beispieldaten[Beispieldaten$t_s >= t_delay, ]
      
      model_values_at_data <- model_function(data_subset$t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow)
      
      r_squared <- calculate_r_squared(data_subset$VO2_t, model_values_at_data)
      current_r_squared(r_squared)
      
      current_r_squared(r_squared)  # Aktualisieren Sie die reaktive Variable
      
      p <- p %>%
        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',
                  name = 'V̇O<sub>2</sub>', 
                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),
                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))
      
      p$x$layout$annotations <- c(p$x$layout$annotations,
                                  list(
                                    list(
                                      x = max_x * 0.35,
                                      y = max_y * 0.10,
                                      text = sprintf("R²: %.3f", current_r_squared()),
                                      showarrow = FALSE,
                                      xanchor = 'left',
                                      yanchor = 'bottom',
                                      font = list(
                                        family = "Arial, sans-serif",
                                        size = 10,
                                        color = "black"
                                      )
                                    )
                                  ))
    }
    
    p
  })
  output$instructions <- renderUI({
    HTML(
      "<div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'>
      <h4 style='color: #333;'><strong>Anleitung - Modellanpassung:</strong></h4>
      <ol style='color: #555; list-style-position: outside; padding-left: 20px;'>
        <li>Beispiel-VO2-Daten einfügen oder eigene VO2-Daten als CSV-Datei hochladen.</li>
        <li>Zeitverzögerung_fast festlegen, um den Startpunkt der Modellanpassung zu bestimmen.</li>
        <li>Schrittweise die Modellanpassung durchführen:
          <ol>
            <li>Fit: Schnelle Komponente</li>
            <li>Fit: Langsame Komponente Verfeinerung</li>
            <li>Fit: Optimierung</li>
          </ol>
        </li>
        <li>Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.</li>
      </ol>
      <div style='margin-top: 20px;'></div>
      <pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'>
VO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:
t_s,VO2_t
0.0,0.479
1.0,0.459
2.3,0.488
…
      </pre>
    </div>"
    )
  })
}

# App ausführen
shinyApp(ui = ui, server = server)
```

::: {.callout-note icon="false" collapse="true" appearance="simple"}
#### Modellanpassung - Details: {.unnumbered .unlisted}

**1. Schnelle Komponente (1. Fit):**

-   Verwendete Funktion: nlsLM
-   Parameter: V̇O2_fast, tau_fast
-   Grenzen:
    -   V̇O2_fast: *0.5 bis 7.0 l/min*
    -   tau_fast: *10 bis 120 s*
-   Prozess: *100 Iterationen* mit zufälligen Startwerten
-   Optimierung: Minimierung der Residuenquadratsumme (RSS)

**2. Langsame Komponente & Verfeinerung (2. Fit):**

-   Parameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow
-   Initiale Werte (basierend auf Ozyener et al., 2001):
    -   V̇O2_slow: *0.4 l/min*
    -   tau_slow: *160 s*
-   Grenzen:
    -   V̇O2_slow: *0.05 bis 1.0 l/min*
    -   tau_slow: *90 bis Unendlich s*
    -   t_delay_slow: *tau_fast + t_delay bis max(t_s)*
-   Prozess für t_delay_slow:
    a)  Berechnung des Suchbereichs: von *(tau_fast + t_delay)* bis zum
        maximalen Zeitpunkt der Daten
    b)  Iteration durch jeden möglichen Wert in diesem Bereich
        (*1-Sekunden-Schritte*)
    c)  Für jeden t_delay_slow-Wert:
        -   Berechnung der RSS mit festen Werten für V̇O2_slow (*0.4
            l/min*) und tau_slow (*160 s*)
    d)  Auswahl des t_delay_slow-Wertes mit der niedrigsten RSS
-   Optimierung von V̇O2_fast und tau_fast:
    a)  Schrittweise Reduzierung von V̇O2_fast (*0.01 l/min*) und
        tau_fast (*0.1 s*)
    b)  Bei jeder Änderung: Berechnung der neuen RSS
    c)  Akzeptanz der Änderung nur bei Verbesserung der RSS
    d)  Wiederholung bis keine Verbesserung mehr möglich
-   Optimierung von V̇O2_slow und tau_slow:
    a)  Zunächst Reduzierung: V̇O2_slow (*0.01 l/min*) und tau_slow (*0.1
        s*)
    b)  Dann Erhöhung: V̇O2_slow (*0.01 l/min*) und tau_slow (*0.1 s*)
    c)  Bei jeder Änderung: Berechnung der neuen RSS
    d)  Akzeptanz der Änderung nur bei Verbesserung der RSS
    e)  Wiederholung jeder Richtung bis keine Verbesserung mehr möglich

**3. Optimierung (3. Fit):**

-   Verwendete Funktion: nlsLM
-   Parameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow
-   Grenzen: Basierend auf den Ergebnissen von Schritt 2
    -   V̇O2_fast: *±2% des Wertes aus Schritt 2*
    -   tau_fast: *±3 s des Wertes aus Schritt 2 (Minimum 10 s)*
    -   V̇O2_slow: *±2% des Wertes aus Schritt 2*
    -   tau_slow: *±3 s des Wertes aus Schritt 2 (Minimum 90 s)*
    -   t_delay_slow: *±5 s des Wertes aus Schritt 2 (Minimum 0 s)*
-   Prozess: *1000 Iterationen* mit zufälligen Startwerten innerhalb der
    Grenzen
-   Optimierung: Minimierung der RSS
:::



## Methodik: Umgang mit $\dot{V}O_{2}$-Daten in dieser Arbeit {.unnumbered .unlisted}

In dieser Arbeit wurde der Anstieg des $\dot{V}O_{2}\,(t)$ nach
Belastungsbeginn für jede Belastungsstufe wie folgt analysiert: Zunächst
wurden aus den Atemzug-für-Atemzug $\dot{V}O_{2}$-Daten die Ausreißer
entfernt. Danach erfolgte eine Glättung der Daten mittels eines
gleitenden 3-Atemzug-Durchschnitts, gefolgt von der Kurvenanpassung.<br>
Vor der Kurvenanpassung wurde die Zeitverzögerung der Hauptkomponente
des $\dot{V}O_{2}\,(t)$ grafisch so bestimmt, dass die
Phase-I-Daten der kardiorespiratorischen Antwort nicht einbezogen
wurden. Dies entsprach in der Regel dem von [@Bearden2000;
@Stirling2005] beschriebenen Zeitraum von 10-25 Sekunden für Phase 1.
Die Kurvenanpassung wurde anschließend mit @eq-VO2_Start an die
jeweiligen Daten durchgeführt. Die Modellparameter der Kurvenanpassung
wurden wie folgt gewählt:

::: {.callout-note icon="false" collapse="true" appearance="simple"}
### Parameter - Kurvenanpassung: {.unnumbered .unlisted}

-   Verwendete Funktion: nlsLM
    -   Maximale Iterationen: *1024*
    -   Verwendung des Levenberg-Marquardt-Algorithmus
-   Parameter: V̇O2 (Amplitude), Tau
-   Modell: V̇O2_t \~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start
-   Grenzen:
    -   V̇O2: *0.5 bis 7.0 l/min*
    -   Tau: *5 bis 360 s*
-   Optimierung: Minimierung der Residuenquadratsumme (RSS)
:::

Dies erfolgte für jedes Belastungsintervall
mittels nichtlinearer Regression unter Verwendung des in @eq-VO2_Start
beschriebenen mono-exponentiellen 3-Parameter-Modells
[@Francescato2003]. Da die Probanden in den Erholungsphasen nicht
vollständig ruhten, war der Sauerstoffvolumenstrom zu Beginn der
Belastung ($\dot{V}O_{2, Start}$) signifikant höher als
$\dot{V}O_{2,Ruhe}$. $\dot{V}O_{2net, SS}$ wurde als der
Wert der Modellfunktion von $\dot{V}O_{2gross, SS}$ zum Zeitpunkt
$4 \cdot τ_{Start}$ abzüglich $\dot{V}O_{2,Ruhe}$ bestimmt. Bis zum
Zeitpunkt $4 \cdot τ_{Start}$ hat ungefähr 98,2 % des Anstiegs von
$\dot{V}O_{2, Belastung}(t)$ stattgefunden. Daher wurde dieser Zeitpunkt
näherungsweise als Steady-State (SS) Wert des Sauerstoffvolumenstroms
während der Belastung festgelegt. Ein Modellierungsbeispiel ist in
@fig-VO2_Start zu sehen:

![Modellierung der Sauerstoffkinetik während des Belastungstests 01_2 mit exponentieller Anpassungskurve](images/p_VO2_01_2.svg){#fig-VO2_Start width="1100" height="450"}



```{r}
### Dauer der Zeitkonstante bei verschiedenen Intensitäten unterschiedlich
# @Oezyener2001 fanden, dass der Wert von τ~Start~ für die Sauerstoffaufnahme im Durchschnitt bei 33 ± 16 s liegt, unabhängig von der Belastungshöhe. 
# -Im Gegensatz dazu berichten andere Studien von einem Anstieg von τ~Start~ mit zunehmender Belastung (Linnarsson 1974).
# Wasserman et al. [@Wasserman1967] prognostizierten und fanden experimentell heraus, dass der Sauerstoffverbrauch bei schweren Arbeitsbelastungen länger ansteigt als bei moderaten Intensitäten. Henry und DeMoor [@Henry1956] stellten ebenfalls fest, dass die Zeit bis zum Erreichen eines stabilen Zustands der Sauerstoffaufnahme (VO2) mit steigender Arbeitslast zunimmt. Im Gegensatz dazu berichten Di Prampero et al. [@DiPrampero1970] und Margaria et al. [@Margaria1965], dass das Muster des VO2-Anstiegs zum stabilen Zustand unabhängig von der Arbeitsintensität gleich ist und dieser Anstieg durch einen einzigen exponentiellen Prozess beschrieben wird, wobei die Reaktionskonstante für alle Arbeitslasten gleich ist.
# 
# **Moderate Intensität:**
# Die pulmonale V̇O~2~steigt monoexponentiell und erreicht innerhalb von etwa 3 Minuten einen Steady State [@Whipp1982; @Hughson1988; @Whipp1994]. Die V̇O~2~ erhöht sich linear zur Arbeitsrate um etwa 10 ml·min^-1·W^-1. Sobald der Steady State erreicht ist, sind ATP-Resynthese und oxidative Phosphorylierung im Gleichgewicht [@Kindermann1979; @Faude2009].
# 
# **Schwere Intensität:**
# Die schwere Intensität liegt zwischen der maximalen Leistungsfähigkeit (GXT) und der kritischen Leistung (CP) [@Hill1993]. Bei schwerer Belastung ist der oxidative Bedarf höher, und der Steady State verzögert sich durch die V̇O~2~ Slow Component. Die O~2~-Kosten steigen auf etwa 13 ml·min^-1·W^-1 [@WhippWasserman1972; @PearceMilhorn1977; @WhippMahler1980; @BarstowMole1991]. Die arterielle Laktatkonzentration steigt über die Ausgangswerte, erreicht aber ein erhöhtes Gleichgewicht [@Billat2003].
# 
# **Schwere Intensität:**
# In der Forschung ist umstritten, ob die primäre V̇O~2~-Kinetik bei schwerer Belastung langsamer ist als bei moderater. Dies könnte auf eine größere Zeitkonstante oder eine zusätzliche Slow Component in V̇O~2~ hindeuten, die einen verzögerten Steady State über dem vorhergesagten Niveau erreicht [@PatersonWhipp1991; @BarstowMole1991].
# 
# **Sehr schwere Intensität:**
# Bei sehr schwerer Intensität, oberhalb des maximalen Laktat-Steady-State oder der kritischen Leistung, erreichen weder V̇O~2~ noch arterielle Laktatkonzentration einen Steady State [@GaesserPoole1996]. Beide steigen unaufhaltsam, bis Ermüdung eintritt und maximale V̇O~2~-Werte erreicht werden [@WassermanWhipp1975; @GaesserPoole1996].

```






## Quellenverzeichnis

::: {#refs}
:::

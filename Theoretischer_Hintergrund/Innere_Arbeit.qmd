---
execute:
  message: false
  echo: false
  warning: false
  error: false
  
bibliography: references.bib
lang: de
number-sections: false
tbl-cap-location: bottom
---

```{css}
#| echo: false
p {
  text-align: justify
}
caption {
  text-align: justify;
}

```

# Innere Arbeit {#sec-InnereArbeit}



```{r}
#@Winter1979 @Winter2009 ***–\> Darauf beziehen***
#Auszug aus Luhtanen et al. (1987) –> The internal work ( W,) performed during one revolution was calculated from the translator, rotational and potential energy states allowing energy transfer between segments and from state to state (Winter 1979).

# UNBEDING FRANCESCATO1995 DURCHARBEITEN !!!!! EINFACHE ERKLÄRUNGEN UND FORMELN!!!!
# UND SJØGAARD für die Beschriebung meiner Berechnung
# UND UNBEDINGT BELL2009 und TOKUI2008 und 2007 -> Hier auch schöne Abbildung der VO2 Kosten von Pint

##Die mechanische innere Leistung (Wint) beim Radfahren wurde von di Prampero et al. (1979) durch grafische Analyse der Bewegung der unteren Extremitäten berechnet. Dabei wurde angenommen, dass die Winkelgeschwindigkeit konstant ist und sich nur die unteren Extremitäten bewegen. Aus dieser Analyse schlossen sie, dass Wint mit der 3. Potenz der Tretfrequenz (fp) zunimmt, beschrieben durch $$ W_{int} = c \times f_p^3 $$, wobei Wint in Watt gemessen wird, fp in Hertz und c für einen normalen 70-kg-Probanden zwischen 5,1 und 7 J·s⁻¹ lag. Bei einem angenommenen Gesamtwirkungsgrad der inneren Leistung (Wint) von 0,22 ergab die theoretische Analyse von di Prampero et al. (1979) folgende Werte für a: 8,3 W bei 40 U/min, 28,0 W bei 60 U/min, 66,4 W bei 80 U/min und 130,0 W bei 100 U/min.

```

Innere Arbeit, auch bekannt als Blind- oder Leerleistung, spielt eine zentrale Rolle bei zyklischen Bewegungen wie dem Radfahren. Sie resultiert aus der erforderlichen Rotation und Verschiebung der Gliedmaßenschwerpunkte, was unerlässlich für die Aufrechterhaltung der Gesamtkörperbalance ist. Die Innere Arbeit, obwohl sie keine externen vortriebswirksamen Kräfte erzeugt, ist für die kontinuierliche Bewegung entscheidend und unterscheidet sich damit von der externen Arbeit, die für den direkten Vortrieb verantwortlich ist.

Im Rahmen der Radfahrbewegung bewegen sich Beine und Gliedmaßen entlang eines spezifischen Pfades und verbrauchen Energie, um diese Bewegung aufrechtzuerhalten. Aus physikalischer Perspektive entsteht dabei bei einem vollständigen Bewegungszyklus keine Nettoarbeit, da Anfangs- und Endpositionen gleich sind. Diese muskuläre Leistung reflektiert die innere Arbeit, die, obwohl ohne direkten Beitrag zum Vortrieb, für die Bewegungsdynamik essentiell ist.

Verschiedene Faktoren beeinflussen diese innere Arbeit und führen insbesondere bei hohen Trittraten zu einer Zunahme der metabolischen Kosten. Diese Faktoren umfassen die durch die Hill-Gleichung beschriebene verminderte Kraftproduktion der Muskeln bei hoher Kontraktionsgeschwindigkeit, die gleichzeitige Aktivierung von Agonisten und Antagonisten – was zu einem erhöhten Abbremsen der Streckbewegung der unteren Extremität führt – und den Reibungs- sowie Viskositätswiderstand von Gelenkknorpel, Bändern und anderen bewegungsunterstützenden Strukturen. Insbesondere das verstärkte Abbremsen der Streckbewegung bei hohen Drehraten, verbunden mit einer höheren muskulären Leistung der Antagonisten, führt zu hohen Blindleistungen.

Durch eine detaillierte Betrachtung dieser Prozesse – das Erfassen aller Energiebeiträge entlang des Bewegungsverlaufs – erhalten wir ein umfassendes Verständnis der energetischen Anforderungen der Bewegung. Diese Analyse ähnelt der Betrachtung der mechanischen Arbeit über einen gesamten Pedalzyklus und veranschaulicht, wie trotz der Abwesenheit von Nettoarbeit Energie für die Aufrechterhaltung der Bewegung eingesetzt wird. Damit kann die Rolle der inneren Arbeit im Kontext der Tretbewegung beim Radfahren dargestellt werden.

```{r echo=TRUE, output=FALSE}
# Library und dfs laden
library(plotly)
library(ggplot2)
library(dplyr)
library(tidyr)
library(htmltools)
library(htmlwidgets)
library(shiny)
library(DT)
library(RColorBrewer)
library(patchwork)
library(minpack.lm)
library(zoo)
library(purrr)
library(readxl)

EPOC_data_df <- readRDS("rds/EPOC_data_df.rds")
Erg_data_df <- readRDS("rds/Erg_data_df.rds")
Erg_data_komplett <- readRDS("rds/Erg_data_komplett.rds")
Messwerte_Bedingungen_df <- readRDS("rds/Messwerte_Bedingungen_df.rds")
Messwerte_Intensitäten_df <- readRDS("rds/Messwerte_Intensitäten_df.rds")
Messwerte_Bedingung_Intensität_df <- readRDS("rds/Messwerte_Bedingung_Intensität_df.rds")
Bedingungen_data <- readRDS("rds/Bedingungen_data.rds")
P_Ges_df <- readRDS("rds/Efficiency_Daten_df.rds")
Efficiency_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_Int_Drehzahl_Masse <- readRDS("rds/P_Int_Drehzahl_Masse.rds")
Simulation_df <- readRDS("rds/Simulation_df.rds")
ΔBLC_list <- readRDS("rds/BLC_list.rds")
proband_data <- readRDS("rds/proband_data.rds")
ΔBLC_data_df <- readRDS("rds/BLC_data_df.rds")
BLC_Modell_list <- readRDS("rds/BLC_Modell_list.rds")
Efficiency_Daten_df <- readRDS("rds/Efficiency_Daten_df.rds")
P_R_list <- readRDS("rds/P_R_list.rds")
P_L_list <- readRDS("rds/P_L_list.rds")
start_vals_list <- readRDS("rds/start_vals_list.rds")
VO2_list <- readRDS("rds/VO2_list.rds")
df_anthropometrisch_female <- readRDS("rds/df_anthropometrisch_female.rds")
df_anthropometrisch_male <- readRDS("rds/df_anthropometrisch_male.rds")
Kinematik_list <- readRDS("rds/Kinematik_list.rds")
```

## Kinematik Daten

Die Bestimmung der inneren Arbeit erfolgte mit Hilfe einer dreidimensionalen Bewegungserfassung. Dazu werden Marker an den Oberflächenrepräsentaten der angenommenen Positionen der relevanten Gelenken für die Bewegung angebracht. Die Einschätzung der Positionen der jeweiligen Gelenkzentren erfolgt aufgrund von anatomischen Annahmen und deren geometrische Beziehungen. Dazu wurde vor den Tests Marker auf einem eng anliegenden Anzug, einer Hose sowie auf Schweißbändern, den Radschuhen und einem Kopfband befestigt. Die Positionierung der Marker orientiert sich am Ganzkörpermodellierungsmodell "Full body modelling with Plug-in Gait", dessen Details in der nachstehenden Abbildung dargestellt sind. Die nahinfrarot reflektierenden Marker wurden durch ein Kamerasystem von acht Vicon Vero Kameras erfasst, die im Labor um das Fahrradergometer positioniert wurden, um den Bereich abzudecken, in dem sich der Proband bewegt. Das Vicon-System erfasst dabei fortlaufend Bilder und verfolgt die Position und Bewegung der Marker im Raum.

![Proband mit allen angelegten Messystemen und Marker-Anzug](images/Marker.png)

## Berechnung der Inneren Arbeit

::: columns
::: {.column width="65%"}
In den folgenden Abschnitten wird beschrieben, wie aus den erfassten Kinematikdaten des Fahrradfahrens mechanische und kinematische Parameter der Tretbewegung berechnet wurden. Diese Berechnungen basieren auf der Kinematik von Drehbewegungen menschlicher Gliederketten, die eine wichtige Grundlage für das Verständnis der Bewegungsmechanik beim Radfahren darstellen. Die Analyse zielt darauf ab, ein detailliertes Verständnis der Bewegungs- und Leistungsdynamik zu ermöglichen, und berücksichtigt dabei die Wechselbeziehungen zwischen den achsenbezogenen kinematischen Größen – wie Winkel und Winkelgeschwindigkeiten – der menschlichen Bein-Gliederketten. Diese Größen werden in Abhängigkeit von der Winkelgeschwindigkeit des Pedalarms sowie den geometrischen Beziehungen der Gliederketten bestimmt. Die Bestimmung der relevanten Parameter erfolgte folgendermaßen:

**Berechnung der relevanten Winkel:** Zunächst wurden die Winkel bestimmt, die die Positionen und Bewegungen der Füße (P1), Knie (P2) und Hüfte (P3) relativ zur Kurbelachse des Fahrrads repräsentieren. Diese Winkel beschreiben die Ausrichtung und Bewegung der Beine während des Pedalzykluses. Der Winkel phi1, der die jeweilige Winkelstellung des Kurbelarmes im Bezug zu einem Startpunkt während des Pedalzykluses repräsentiert, wird aus der Position von P1 relativ zur Kurbelachse berechnet.

**Berechnung der Winkelgeschwindigkeiten:** Aus den Änderungen der Winkel über die Zeit werden Winkelgeschwindigkeiten (omega) abgeleitet. Zusätzlich werden die Winkelgeschwindigkeiten für das obere (OS) und untere Segment (US) des Beines separat berechnet.

**Ermittlung der kinetischen Energie:** Die rotatorische kinetische Energie wird für den Oberschenkel, den Unterschenkel sowie die Fahrradkurbel berechnet, basierend auf ihren jeweiligen Winkelgeschwindigkeiten (omega_SpOS & omega_SpUS) und Trägheitsmomenten (thetaOS & thetaUS). Die translatorische kinetische Energie wird aus den Geschwindigkeiten der Schwerpunkte der Beinsegmente (v_SpOS & v_SpUS) sowie den jeweiligen Segmentmassen (mOS & mUS) bestimmt.

**Berechnung der inneren Arbeit & Blindleistung:** Die zentrale Größe in dieser Berechnung ist die integrierte Leistung, die Blindleistung, die aus der Änderung der kinetischen Energie über die Zeit integriert wird. Die Blindleistung reflektiert, wie viel Arbeit vom Fahrer in einem bestimmten Zeitintervall geleistet wird. Die Berechnung der Blindleistung erfolgt sowohl für die rotierende als auch für die translatorische Bewegung.



## Schritte in der Berechnung

In den folgenden Abschnitten wird beschrieben, wie aus den erfassten Kinematikdaten des Fahrradfahrens mechanische und kinematische Parameter der Tretbewegung berechnet wurden. Diese Berechnungen basieren auf der Kinematik von Drehbewegungen menschlicher Gliederketten, die eine wichtige Grundlage für das Verständnis der Bewegungsmechanik beim Radfahren darstellen. Die Analyse zielt darauf ab, ein detailliertes Verständnis der Bewegungs- und Leistungsdynamik zu ermöglichen, und berücksichtigt dabei die Wechselbeziehungen zwischen den achsenbezogenen kinematischen Größen – wie Winkel und Winkelgeschwindigkeiten – der menschlichen Bein-Gliederketten. Diese Größen werden in Abhängigkeit von der Winkelgeschwindigkeit des Pedalarms sowie den geometrischen Beziehungen der Gliederketten bestimmt. Die Bestimmung der relevanten Parameter erfolgte folgendermaßen:

**Berechnung der relevanten Winkel:** Zunächst wurden die Winkel bestimmt, die die Positionen und Bewegungen der Füße (P~1~), Knie (P~2~) und Hüfte (P~3~) relativ zur Kurbelachse des Fahrrads repräsentieren. Diese Winkel beschreiben die Ausrichtung und Bewegung der Beine während des Pedalzykluses. Der Winkel phi~1~, der die jeweilige Winkelstellung des Kurbelarmes im Bezug zu einem Startpunkt während des Pedalzykluses repräsentiert, wird aus der Position von P~1~ relativ zur Kurbelachse berechnet @eq-phi1. 

$$
\phi_1 = \text{atan2}(P1_y, P1_x)
$$ {#eq-phi1}

**Berechnung der Winkelgeschwindigkeiten:** Aus den Änderungen der Winkel über die Zeit werden Winkelgeschwindigkeiten (omega) abgeleitet @eq-omega. Zusätzlich werden die Winkelgeschwindigkeiten für das obere (Oberschenkel) und untere Segment (Unterschenkel) des Beines separat berechnet.

$$
\omega = \frac{\Delta \phi_1}{\Delta t}
$$ {#eq-omega}

**Ermittlung der kinetischen Energie:** Die rotatorische kinetische Energie wird für den Oberschenkel, den Unterschenkel sowie die Fahrradkurbel berechnet, basierend auf ihren jeweiligen Winkelgeschwindigkeiten (omega~SPOberschenkel~ & omega~SPUnterschenkel~) und Trägheitsmomenten (theta~Oberschenkel~ & theta~Unterschenkel~) @eq-Ekin_rot. Die translatorische kinetische Energie wird aus den Geschwindigkeiten der Schwerpunkte der Beinsegmente (v~SPOberschenkel~ & v~SPUnterschenkel~) sowie den jeweiligen Segmentmassen (m~Oberschenkel~ & m~Unterschenkel~) bestimmt @eq-Ekin_trans. Hierbei stehen SPOberschenkel und SPUnterschenkel für die Schwerpunkte (SP) des Oberschenkels bzw. Unterschenkels.

$$
E_{kin,rot} = \frac{1}{2}(I_{Oberschenkel} \cdot \omega_{Oberschenkel}^2 + I_{Unterschenkel} \cdot \omega_{Unterschenkel}^2 + I_{Kurbel} \cdot \omega_{Kurbel}^2)
$$ {#eq-Ekin_rot}

$$
E_{kin,trans} = \frac{1}{2}(m_{Oberschenkel} \cdot v_{Oberschenkel}^2 + m_{Unterschenkel} \cdot v_{Unterschenkel}^2)
$$ {#eq-Ekin_trans}

**Berechnung der inneren Arbeit & Blindleistung:** Die zentrale Größe in dieser Berechnung ist die integrierte Leistung, die Blindleistung, die aus der Änderung der kinetischen Energie über die Zeit integriert wird. Die Blindleistung reflektiert, wie viel Arbeit vom Fahrer in einem bestimmten Zeitintervall geleistet wird. Die Berechnung der Blindleistung erfolgt sowohl für die rotierende als auch für die translatorische Bewegung. Die Leistung (PInt_Rechts) wird schließlich als Änderung der Gesamtenergie pro Zeiteinheit berechnet @eq-PInt_Rechts.

$$
P_{Int,Rechts} = \frac{\Delta E_{kin,ges}}{\Delta t}
$$ {#eq-PInt_Rechts}

Um die Qualität der Daten zu gewährleisten und mögliche Fehler in der Markerauzeichnung zu korrigieren, werden Ausreißer in PInt_Rechts identifiziert und durch gleitende Mittelwerte ersetzt. PInt_Links wird durch eine zeitliche Verschiebung von PInt_Rechts um einen halben Zyklus berechnet. Negative Werte in beiden Leistungskurven werden auf null gesetzt, um physiologisch sinnvolle Ergebnisse zu erhalten @eq-PInt_Rechts_Positiv @eq-PInt_Links_Positiv:

$$
P_{Int,Rechts,Positiv} = \max(P_{Int,Rechts}, 0)
$$ {#eq-PInt_Rechts_Positiv}

$$
P_{Int,Links,Positiv} = \max(P_{Int,Links}, 0)
$$ {#eq-PInt_Links_Positiv}

PInt_Kinematik ergibt sich als Summe der Mittelwerte von PInt_Rechts_Positiv und PInt_Links_Positiv @eq-PInt_Kinematik:

$$
P_{Int,Kinematik} = \overline{P_{Int,Rechts,Positiv}} + \overline{P_{Int,Links,Positiv}}
$$ {#eq-PInt_Kinematik}

Zur weiteren Verbesserung der Datenqualität insbesondere für die Datendarstellung werden die Leistungskurven mittels eines gleitenden Fensters geglättet.

Diese detaillierte Analyse der Leistungsparameter bietet wertvolle Einblicke in die Bewegungsmechanik und Effizienz des Radfahrens, die für weitere biomechanische Studien oder die Optimierung der Fahrleistung genutzt werden können.

Im Anschluss an die Berechnung von PInt_Kinematik wurde ein Verfahren entwickelt, um PInt_Kinematik_Modell zu erstellen. Dieses Modell dient dazu, vergleichbare Daten für Probanden zu generieren, für die keine Kinematikdaten verfügbar waren. Der Prozess basiert auf der Nutzung von PInt_Modell, einer berechneten internen Leistung, die auf simulierten Daten statt auf tatsächlichen Kinematikdaten beruht. Anschließend wurde eine Differenz (PInt_Diff) zwischen PInt_Kinematik und PInt_Modell berechnet, um die systematischen Abweichungen zwischen den beiden Methoden zu quantifizieren @eq-PInt_Diff.

$$
P_{Int,Diff} = P_{Int,Kinematik} - P_{Int,Modell}
$$ {#eq-PInt_Diff}

Dabei wurden die Werte für den ersten Probanden aufgrund zu großer Abweichungen trotz der Glättung der Ausreißer gegenüber PInt_Kinematik entfernt. 

Für die Erstellung von PInt_Kinematik_Modell wurden zunächst die mittleren Differenzen zwischen PInt_Kinematik und PInt_Modell für die Bedingungen "stehen" und "sitzen" berechnet. Diese mittleren Differenzen wurden dann verwendet, um die fehlenden PInt_Kinematik-Werte zu schätzen, indem sie zu den entsprechenden PInt_Modell-Werten addiert wurden @eq-PInt_Kinematik_Modell. 

$$
P_{Int,Kinematik,Modell} = 
\begin{cases} 
P_{Int,Modell} + \overline{P_{Int,Diff,stehen}} & \text{für Bedingung "stehen"} \\
P_{Int,Modell} + \overline{P_{Int,Diff,sitzen}} & \text{für Bedingung "sitzen"}
\end{cases}
$$ {#eq-PInt_Kinematik_Modell}

Dieses Verfahren ermöglichte es, für alle Probanden und Bedingungen vergleichbare PInt_Kinematik_Modell-Werte zu generieren, auch wenn keine direkten Kinematikdaten verfügbar waren.


### DIE ABBILDUNGEN DIE ICH IN DER MA HABEN MÖCHTE DANN NOCH UPDATEN ###






:::

::: {.column width="35%"}
![Das auf einer Viergelenk-Gliederkette basierende Simulationsmodell der Kurbel- und Beinbewegung für den Radsport, dargestellt an einem Fahrradergometer (Sagittalebene)](images/PInt_Simulation.png)
:::
:::

<!--Dynamik der Beinbewegungen: Zusätzlich zu den oben genannten Berechnungen werden die Längen und Geschwindigkeiten der Beinsegmente analysiert, um ein vollständiges Bild der Bewegungsdynamik zu erhalten. Dies beinhaltet die Berechnung der tatsächlichen Längen der Oberschenkel und Unterschenkel sowie deren Bewegungsgeschwindigkeiten. Diese Informationen sind entscheidend, um die Mechanik der Beinbewegungen während des Fahrradfahrens zu verstehen und um Bereiche für mögliche Verbesserungen in der Effizienz oder in der Technik zu identifizieren. -->

##### **Code zur Berechnung der Inneren Arbeit und Erstellung des Simulationsmodells**

```{r echo=TRUE, output=FALSE}

# Neue Spalten für die berechnete Leistung und den verwendeten Faktor 
Erg_data_df$Faktor_Used <- NA  
Erg_data_df$PInt_Modell <- NA

# ------------ Berechnungen_P_Int ----------
# Initialisiere die Liste für Dataframes
PInt_list <- list()

# ------------ Eingabeparameter ------------ 
# Schleife über alle Zeilen in Erg_data_df
for(i in 1:nrow(Erg_data_df)) {
  # Übernahme der Werte aus der aktuellen Zeile...
  Masse <- as.numeric(Erg_data_df[i, 'Masse'])
  lOS <- as.numeric(Erg_data_df[i, 'lOS'])
  lUS <- as.numeric(Erg_data_df[i, 'lUS'])
  lBein <- as.numeric(Erg_data_df[i, 'lBein'])
  lKurbel <- as.numeric(Erg_data_df[i, 'lKurbel'])
  uOS <- as.numeric(Erg_data_df[i, 'uOS'])
  uUS <- as.numeric(Erg_data_df[i, 'uUS'])
  nD <- as.numeric(Erg_data_df[i, 'nD'])
  Umdrehungen_ges <- as.numeric(Erg_data_df[i, 'Umdrehungen_ges'])
  nD_HZ <- as.numeric(Erg_data_df[i, 'nD_Hz'])
  Testdauer <- 300

  # Konstanten und weitere Berechnungen
  Faktor <- 1.00 # Faktor zur Anpassung des Abstandes vom Hüftgelenk zur Kurbelachse
  S <- lBein * 0.883 * Faktor # Abstand vom Hüftgelenk zur Kurbelachse - Lemond Methode
  P3x <- -0.150 # x-Koordinate von P3 (Oberflächenrepräsentant der Hüfte) [m]
  P3y <- sqrt((S^2)-(P3x^2)) # y-Koordinate von P3 (Oberflächenrepräsentant der Hüfte) [m]
  P3 <- c(P3x,P3y) # kartesische Koordinaten P3 (Oberflächenrepräsentant der Hüfte) [m]
  rRelOS <- 0.1416 # relative Segmentmasse OS
  rRelUS <- 0.0433 # relative Segmentmasse US
  lambdaOS <- 0.4095 # Abstand zw. dem proximalen Punkt des Oberschenkelsegments und dessen Schwerpunkt
  lambdaUS <- 0.4459 # Abstand proximaler Segmentpunkt - Schwerpunkt
  thetaKurbel <- 0.002 # Trägheitsmoment der Fahrradkurbel [kg m^2]
  n <- 360 # Anzahl Messwerte pro Umdrehung
  delta_t <- 60 / (n * nD) # Zeitintervalle
  T <- 60 / nD # Periodendauer einer Umdrehung
  omega <- 2 * pi * nD / 60 # mittlere Winkelgeschwindigkeit
  
  # Segmentmasse OS und US [kg]
  mOS <- Masse * rRelOS 
  mUS <- Masse * rRelUS 
  
  # Trägheitsmoment des Segments [kg m^2]
  thetaOS <- (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS^2
  thetaUS <- (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS^2
  
  # Winkel und Geschwindigkeiten berechnen
  delta_phi1 <- 2 * pi / n # Winkelintervalle
  phi1 <- seq(0, 2 * pi, by=delta_phi1) # Erstellung von Winkelintervallen für eine komplette Umdrehung
  phi1 <- phi1[-length(phi1)]  # Entfernt das letzte Element
  grad <- phi1 * 180 / pi # Umrechnung von Bogenmaß in Grad
  time <- seq(0, T, by=delta_t) # Erstellung von Zeitintervallen für eine komplette Umdrehung
  time <- time[-length(time)]  # Entfernt das letzte Element
  
  # Berechnung der kartesischen Koordinaten von Punkt P1 in Abhängigkeit von der Zeit
  P1 <- list(lKurbel * sin(phi1), lKurbel * cos(phi1))
  
  # Abstand vom Hüftgelenk zur Kurbelachse (0,0) berechnen
  G4 <- sqrt(sum(P3^2))
  
  # Berechnung des Winkels des Gestänges
  delta <- acos(P3[2] / S)
  
  # Berechnung der Länge des Verbindungssegments zw. Kurbel und Hüftgelenk > 'c' kann nicht kürzer als die Summe der Längen der Beinsegmente sein
  c <- sqrt(lKurbel^2 + S^2 - 2 * S * lKurbel * cos(phi1 + delta))
  
  # Schleife zur Anpassung des Faktors, falls c größer als die Summe der Segmentlängen ist
  while (any(lUS + lOS < c)) {
    Faktor <- Faktor - 0.01  # Verringere den Faktor um 0.01
    S <- lBein * 0.883 * Faktor  # Neuberechnung von S
    P3y <- sqrt((S^2) - (P3x^2))  # Neuberechnung von P3y
    P3 <- c(P3x, P3y)  # Neuberechnung von P3
    delta <- acos(P3[2] / S)  # Neuberechnung von delta
    c <- sqrt(lKurbel^2 + S^2 - 2 * S * lKurbel * cos(phi1 + delta))  # Neuberechnung von c
  }
  
  # Überprüfung, ob die Segmentlängen zusammen größer sind als die berechnete Länge c
  control <- sum(ifelse(lUS + lOS <= c, 1, 0))
  
  # Ausgabe, ob control bzw. die Segmentlängen größer sind als c
  if (control > 0) {
    print("Mindestens eine Segmentlänge ist größer als c.")
  } else {
    print("Alle Segmentlängen sind kleiner oder gleich c.")
  }
  
  # Speichere den verwendeten Faktor in der Spalte 'Faktor_Used'
  Erg_data_df$Faktor_Used[i] <- Faktor
  
  # Winkelberechnungen für das Beinsegment    
  alpha <- asin(lKurbel * sin(phi1 + delta) / c) # Winkel zwischen Gestell und c (Verbindungsseg. zwischen Kurbel und Hüftgelenk )               
  beta <- acos((lOS^2 + c^2 - lUS^2) / (2 * lOS * c)) # Winkel zwischen Oberschenkel und L       
  
  # Berechnung der kartesischen Koordinaten von Punkt P2 in Abhängigkeit von der Zeit
  P2 <- list(P3[1] + lOS * cos(pi/2 - (alpha + beta + delta)),
             P3[2] - lOS * sin(pi/2 - (alpha + beta + delta)))
  
  # Winkelberechnungen zwischen den Segmentpunkten
  phi2 <- acos((P2[[1]] - P1[[1]]) / lUS)
  phi3 <- acos((P3[2] - P2[[2]]) / lOS)
  
  # Berechnung der kartesischen Koordinaten der Schwerpunkte der Oberschenkel- und Unterschenkelsegmente
  SpOS <- list(P3[1] - lambdaOS * (P3[1] - P2[[1]]), 
               P3[2] - lambdaOS * (P3[2] - P2[[2]]))
  SpUS <- list(P2[[1]] - lambdaUS * (P2[[1]] - P1[[1]]), 
               P2[[2]] - lambdaUS * (P2[[2]] - P1[[2]]))
  
  # Funktion zur Berechnung der Geschwindigkeit
  berechneGeschwindigkeit <- function(Sp, delta_t) {
    diff_x <- c(diff(Sp[[1]]), Sp[[1]][1] - Sp[[1]][length(Sp[[1]])])
    diff_y <- c(diff(Sp[[2]]), Sp[[2]][1] - Sp[[2]][length(Sp[[2]])])
    return(sqrt(diff_x^2 + diff_y^2) / delta_t)
  }
  
  # Anwenden der Funktion
  vOS <- berechneGeschwindigkeit(SpOS, delta_t)
  vUS <- berechneGeschwindigkeit(SpUS, delta_t)
  
  # Berechnung der translatorischen kinetischen Energie
  Ekin_trans <- 0.5 * (mOS * vOS^2 + mUS * vUS^2)
  
  # Delta der Winkelgeschwindigkeiten für zyklische Bewegung
  delta_phi2 <- c(diff(phi2), phi2[1] - phi2[length(phi2)])
  delta_phi3 <- c(diff(phi3), phi3[1] - phi3[length(phi3)])
  
  # Berechnung der Winkelgeschwindigkeiten der Schwerpunkte von Oberschenkel- und Unterschenkel
  omega_SpOS <- delta_phi2 / delta_t
  omega_SpUS <- delta_phi3 / delta_t
  omega_Kurbel <- delta_phi1 / delta_t
  
  # Trägheitsmoment des Segments (Vollzylinder, der um eine Querachse (zweizählige Symmetrieachse) rotiert) [kg m^2]
  thetaOS <- (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS^2
  thetaUS <- (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS^2
  
  # Berechnung der rotatorischen kinetischen Energie
  Ekin_rot <- 0.5 * (thetaOS * omega_SpOS^2 + thetaUS * omega_SpUS^2 + thetaKurbel * omega_Kurbel^2)
  
  # Delta der kinetischen Energie (translatorisch) für zyklische Bewegung
  delta_Ekin_trans <- c(diff(Ekin_trans), Ekin_trans[1] - Ekin_trans[length(Ekin_trans)])
  
  # Delta der kinetischen Energie (rotatorisch) für zyklische Bewegung
  delta_Ekin_rot <- c(diff(Ekin_rot), Ekin_rot[1] - Ekin_rot[length(Ekin_rot)])
  
  # Delta Gesamt für zyklische Bewegung
  delta_Ekin_ges <- delta_Ekin_rot + delta_Ekin_trans 
  
  # Berechnung der internen Leistung für die aktuelle Drehzahl und Masse
  PInt_Zyklus_Rechts <- delta_Ekin_ges / delta_t
  PInt_Zyklus_Rechts_Positiv <- ifelse(PInt_Zyklus_Rechts < 0, 0, PInt_Zyklus_Rechts)
  
  # Verschiebe die Werte von PInt_Zyklus_Rechts um 180 Positionen, um PInt_Zyklus_Links zu erhalten
  verschieben <- 180 # Die Anzahl der Zeilen, die verschoben werden sollen
  PInt_Zyklus_Links <- c(PInt_Zyklus_Rechts[(verschieben + 1):length(PInt_Zyklus_Rechts)], 
                          PInt_Zyklus_Rechts[1:verschieben])
  PInt_Zyklus_Links_Positiv <- ifelse(PInt_Zyklus_Links < 0, 0, PInt_Zyklus_Links)

  # Durchschnittliche PInt alle Positiven Werte, Negative Werte = 0
  PInt_Zyklus_mean <- mean(PInt_Zyklus_Rechts_Positiv) + mean(PInt_Zyklus_Links_Positiv)
  #PInt_Zyklus_mean_0 <- mean(PInt_Zyklus_Rechts_Positiv[PInt_Zyklus_Rechts_Positiv != 0]) + mean(PInt_Zyklus_Links_Positiv[PInt_Zyklus_Links_Positiv != 0])
  
  # Geben Sie das berechnete _PInt_mean zurück
  print(PInt_Zyklus_mean)
  
  # Berechnen Sie _PInt_mean für die aktuelle Zeile und speichern Sie es im DataFrame
  #Erg_data_df$_PInt_mean[i] <- _PInt_mean
  #Erg_data_df$PInt_Ges_Watt2[i] <- PInt_Ges_Watt2
  
  current_df <- data.frame(
    Time = time,
    Phi1 = phi1,
    Grad = grad,
    P1x = P1[[1]],
    P1y = P1[[2]],
    P2x = P2[[1]],
    P2y = P2[[2]],
    P3x = rep(P3[1], n),
    P3y = rep(P3[2], n),
    SpOS_X = SpOS[[1]],
    SpOS_Y = SpOS[[2]],
    SpUS_X = SpUS[[1]],
    SpUS_Y = SpUS[[2]],
    VOS = vOS,
    VUS = vUS,
    EkinTrans = Ekin_trans,
    EkinRot = Ekin_rot,
    DeltaEkinTrans = delta_Ekin_trans,
    DeltaEkinRot = delta_Ekin_rot,
    DeltaEkinGes = delta_Ekin_ges,
    PIntMittelZyklusRechts = PInt_Zyklus_Rechts,
    PIntMittelZyklusRechtsPositiv = PInt_Zyklus_Rechts_Positiv,
    PIntMittelZyklusLinks = PInt_Zyklus_Links,
    PIntMittelZyklusLinksPositiv = PInt_Zyklus_Links_Positiv,
    PInt_Modell = PInt_Zyklus_mean
  )
  
  # Füge den neuen Dataframe zur Liste hinzu
  PInt_list[[i]] <- current_df
  
  # Benenne das i-te Element der Liste basierend auf den Werten der ersten beiden Spalten in Erg_data_df
  name <- paste(Erg_data_df[i, 1], Erg_data_df[i, 2], sep = "_")
  # Überprüfe, ob die Länge des Namens weniger als 4 ist
  if(nchar(name) < 4) {
    name <- paste0("0", name)  # Füge eine "0" vor dem Namen hinzu, falls notwendig
  }
  names(PInt_list)[i] <- name
  
  # Berechnen Sie PInt_mean für die aktuelle Zeile und speichern Sie es im DataFrame
  Erg_data_df$PInt_Modell[i] <- mean(current_df$PInt_Modell)
}

df <- PInt_list[["15_5"]]

# Für Website einheitliche Achsen setzen
range_x <- c(-0.5, 0.5)
range_y <- c(-0.4, 1)

df$P0x <- 0
df$P0y <- 0

Modell_Simulation <- plot_ly(data = df[0000:0360,], frames = ~Grad) %>%
  
  # Verlauf von P1
  add_trace(
    x = ~P1x,
    y = ~P1y,
    type = 'scatter',
    mode = 'lines',
    name = "P1 Path",
    line = list(color = 'lightgrey', dash = 'dot'), 
    showlegend = FALSE
  ) %>%
  
  # Trace für P1
  add_trace(
    x = ~P1x,
    y = ~P1y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P1",
    showlegend = FALSE
  ) %>%

  
  # Trace für P3
  add_trace(
    x = ~P3x,
    y = ~P3y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P3",
    showlegend = FALSE
  ) %>%
  
  # Trace für P2
  add_trace(
    x = ~P2x,
    y = ~P2y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P2",
    showlegend = FALSE
  ) %>%
  
  # Trace für P0
  add_trace(
    x = ~P0x,
    y = ~P0y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Trace für SPOS
  add_trace(
    x = ~SpOS_X,
    y = ~SpOS_Y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Trace für SPUS
  add_trace(
    x = ~SpUS_X,
    y = ~SpUS_Y,
    frame = ~Grad,
    type = 'scatter',
    mode = 'markers',
    name = "P0",
    showlegend = FALSE
  ) %>%
  
  # Segmente hinzufügen
  add_segments(
    x = ~P0x, xend = ~P1x,
    y = ~P0y, yend = ~P1y,
    frame = ~Grad,
    line = list(color = 'black'),
    showlegend = FALSE
  ) %>%
  
  add_segments(
    x = ~P2x, xend = ~P3x,
    y = ~P2y, yend = ~P3y,
    frame = ~Grad,
    line = list(color = 'darkgrey'),
    showlegend = FALSE
  ) %>%
  
  add_segments(
    x = ~P2x, xend = ~P1x,
    y = ~P2y, yend = ~P1y,
    frame = ~Grad,
    line = list(color = 'darkgrey'),
    showlegend = FALSE
  ) %>%
  
  # Layout und weitere Einstellungen, inklusive der festgelegten Achsenbereiche
  layout(
    title = 'Kinematik-Modell',
    margin = list(t = 40),
    xaxis = list(title = 'X-Koordinate', range = range_x),
    yaxis = list(title = 'Y-Koordinate', range = range_y),
    showlegend = TRUE,
    legend = list(x = 1, y = 1)
  ) %>%
  
  # Animationsoptionen
  animation_opts(
    frame = 100,  # Dauer jedes Frames in Millisekunden
    redraw = TRUE
  ) %>%
  
  # Animation-Steuerelemente
  animation_button(
    label = "Play",
    method = "animate",
    args = list(NULL, list(frame = list(duration = 50, redraw = TRUE), fromcurrent = TRUE, mode = "immediate"))
  ) %>%
  
  animation_slider(
    currentvalue = list(prefix = "Grad: ")
  )

```

### Erstellung - Simulaitonsmodell

Aufgrund von Messungenauigkeiten oder Defiziten im Kamerasystem mit Markern war es nicht möglich, für jeden Probanden die erforderlichen kinematischen Daten zur Erstellung eines 2D-Simulationsmodells zu erhalten. Daher wurde zusätzlich ein alternatives Simulationsmodell basierend auf den verfügbaren anthropometrischen Daten der Probanden entwickelt, für die keine konkreten Kinematikdaten vorhanden waren. Für Probanden ohne die für die Modellbildung essentiellen anthropometrischen Daten wie Länge und Umfang von Ober- und Unterschenkel wurden diese Angaben entsprechend den Standardwerten aus folgenden anthropometrischen Tabellen bestimmt (siehe Abschnitt "Anthropometrische Tabellen").

#### **Simulationsmodell auf Basis anthropometrische Daten und bekannten Größen**

::: columns
::: {.column width="65%"}
**Erstellung des Simulationsmodells**

Zunächst wurden alle für die Berechnung essentielle individuelle Parameter wie Körpermasse (Masse), die Längen der Beinsegmente (lOS & lUS), die Länge der Kurbel (lKurbel) sowie die Drehzahl (nD) erstellt. Der Abstand vom Hüftgelenk zur Kurbelachse, bezeichnet als S wurde mittels der Lemond-Methode bestimmt. Zudem wird die Position des Hüftgelenks (P3) im Raum mit seinen Koordinaten P3x und P3y festgelegt.

Im nächsten Schritt, wurden die Winkel phi1, alpha und beta ermittelt. Diese Winkel definieren die Position und Bewegung der Beine und sind essentiell für die Berechnung der Winkelgeschwindigkeiten der Beinsegmente (thetaOS & thetaUS) sowie der kinetischen Energien der Beinsegmente und der Kurbel .

Anschließend wurden die translatorische und rotatorische kinetische Energie für die Oberschenkel- und Unterschenkelsegmente sowie für die Kurbel berechnet. Diese Energien, bezeichnet als Ekin_trans und Ekin_rot, basieren auf den Geschwindigkeiten vOS und vUS sowie den Winkelgeschwindigkeiten omega_SpOS und omega_SpUS. Die Veränderungen dieser Energien über die Zeit (delta_Ekin_trans & delta_Ekin_rot) geben Aufschluss über die geleistete Arbeit und führen zur Berechnung der internen Leistung (PInt_Zyklus_Rechts und PInt_Zyklus_Links).

Abschließend wird die interne Leistung für jeden Teil des Pedalzyklus, angegeben durch PInt_Zyklus_Rechts für das rechte Bein und PInt_Zyklus_Links für das linke Bein, berechnet. Die Werte von PInt_Zyklus_Links wurden um einen halben Zyklus verschoben, um die symmetrische Natur des Radfahrens zu reflektieren. Die durchschnittliche interne Leistung, bezeichnet als PInt_Zyklus_mean, ergibt sich aus den positiven Werten der Leistungsberechnungen für beide Beine.
:::

::: {.column width="35%"}
![Das auf einer Viergelenk-Gliederkette basierende Simulationsmodell der Kurbel- und Beinbewegung für den Radsport, dargestellt an einem Fahrradergometer (Sagittalebene)](images/PInt_Simulation.png)
:::
:::

##### **Simulationsmodell der Kurbel- und Beinbewegung auf dem Radergometer**

::: columns
::: {.column width="65%"}
Zunächst wurden alle für die Berechnung essentielle individuelle Parameter wie Körpermasse (Masse), die Längen der Beinsegmente (lOS für Oberschenkel, lUS für Unterschenkel), die Länge der Kurbel (lKurbel) sowie die Drehzahl (nD) erstellt. In den geometrischen und kinematischen Grundlagenberechnungen wird der Abstand vom Hüftgelenk zur Kurbelachse, bezeichnet als S, mittels der Lemond-Methode bestimmt. Diese Methode basiert auf der Länge des Beins (lBein). Zudem wird die Position des Hüftgelenks (P3) im Raum mit seinen Koordinaten P3x und P3y festgelegt.

Im nächsten Schritt, der kinematischen Sequenz und den energetischen Berechnungen, werden die Winkel phi1, alpha und beta ermittelt. Diese Winkel definieren die Position und Bewegung der Beine und sind essentiell für die Berechnung der Winkelgeschwindigkeiten der Beinsegmente sowie der kinetischen Energien der Beinsegmente und der Kurbel (thetaOS für den Oberschenkel, thetaUS für den Unterschenkel, thetaKurbel für die Kurbel).

Bei den Energieumwandlungen und Leistungsberechnungen werden die translatorische und rotatorische kinetische Energie für die Oberschenkel- und Unterschenkelsegmente sowie für die Kurbel berechnet. Diese Energien, bezeichnet als Ekin_trans und Ekin_rot, basieren auf den Geschwindigkeiten vOS und vUS sowie den Winkelgeschwindigkeiten omega_SpOS und omega_SpUS. Die Veränderungen dieser Energien über die Zeit (delta_Ekin_trans und delta_Ekin_rot) geben Aufschluss über die geleistete Arbeit und führen zur Berechnung der internen Leistung (PInt_Zyklus_Rechts und PInt_Zyklus_Links).

Abschließend wird die interne Leistung für jeden Teil des Pedalzyklus, angegeben durch PInt_Zyklus_Rechts für das rechte Bein und PInt_Zyklus_Links für das linke Bein, berechnet. Diese Werte werden um einen halben Zyklus verschoben, um die symmetrische Natur des Radfahrens zu reflektieren. Die durchschnittliche interne Leistung, bezeichnet als PInt_Zyklus_mean, ergibt sich aus den positiven Werten der Leistungsberechnungen für beide Beine, was ein Maß für die effektive Nutzung der mechanischen Energie durch den Radfahrer darstellt.
:::

::: {.column width="35%"}
![Simulationsmodell](images/Modell_Simulation.html){fig-align="left" width="500" height="720"}
:::
:::

##### **Code zur Berechnung der Inneren Arbeit auf Basis der tatsächlichen Kinematikdaten**

```{r echo=TRUE, output=FALSE}

# Initialisiere die Listen für die Ergebnisse
PInt_Kinematik_list <- list()
plotly_Pint_list <- list()

# Schleife durch alle Einträge in Kinematik_list
for (name in names(Kinematik_list)) {
  # Lese die Daten ein
  df <- Kinematik_list[[name]]

  # Definiere die ausgewählten Spalten und deren neue Namen direkt
  selected_columns <- c(Frame = "Frame",
                        P0x = "Kurbelachse_X", P0y = "Kurbelachse_Y",
                        P3x = "LHJC_X", P3y = "LHJC_Y",
                        P2x = "LKJC_X", P2y = "LKJC_Y",
                        P1x = "LToe_X", P1y = "LToe_Y",
                        LAJC_X = "LAJC_X", LAJC_Y = "LAJC_Y")
  
  # Entferne die erste und letzte Zeile, wähle und benenne die Spalten + Masse-Spalte
  df <- df[-c(1, nrow(df)), ] %>% 
    select(all_of(selected_columns)) %>%
    mutate(Masse = Erg_data_df[Erg_data_df$Name == name, "Masse"]) 
  
  # Funktion, um korrekten Winkelunterschied für zyklische Bewegungen zu berechnen
  corrected_delta_phi1 <- function(phi1) {
    # Berechnet die Winkeldifferenz zwischen aufeinanderfolgenden Werten. Fügt 'NA' für den letzten Wert ein.
    delta_phi1 = diff(phi1)
    
    # Korrigiert die Winkeldifferenzen, die die Grenzen einer zyklischen Bewegung überschreiten.
    # Für Übergänge nahe der Grenzen (0 und 360 Grad oder 0 und 2*pi), passen wir die Differenz an,
    # um korrekte kleine Werte zu erhalten statt großer Sprünge.
    delta_phi1 = ifelse(delta_phi1 > pi, delta_phi1 - 2*pi, delta_phi1)
    delta_phi1 = ifelse(delta_phi1 < -pi, delta_phi1 + 2*pi, delta_phi1)
    
    # Nimmt die letzten 3 Änderungen oder alle vorhandenen, falls weniger als 3
    num_values = min(length(delta_phi1), 3)
    last_values = tail(delta_phi1, num_values)
    
    # Berechnet die durchschnittliche Differenz der letzten Werte
    avg_difference = mean(last_values, na.rm = TRUE)
    
    # Fügt die durchschnittliche Differenz zum letzten verfügbaren Wert hinzu, um den nächsten Wert zu schätzen
    extrapolated_value = last(phi1) + avg_difference  # Der neue Wert basiert auf dem letzten phi1-Wert
    
    # Fügt den extrapolierten Wert zum Vektor hinzu
    delta_phi1 = c(delta_phi1, extrapolated_value - last(phi1))  # Differenz zum letzten phi1
    
    return(delta_phi1)
  }
  
  # Konstanten und Parameter
  # Suche den Wert für 'Masse' basierend auf 'Name' in Erg_data_df
  Masse <- Erg_data_df[Erg_data_df$Name == name, "Masse"]
  uOS <- Erg_data_df[Erg_data_df$Name == name, "uOS"]
  uUS <- Erg_data_df[Erg_data_df$Name == name, "uUS"]
  lBein <- Erg_data_df[Erg_data_df$Name == name, "lBein"]
  Faktor <- 1.0
  S <- lBein * 0.883 * Faktor # Abstand vom Hüftgelenk zur Kurbelachse - Lemond Methode
  rRelOS <- 0.1416 # relative Segmentmasse OS
  rRelUS <- 0.0433 # relative Segmentmasse US
  lambdaOS <- 0.4095 # Abstand zw. dem proximalen Punkt des Oberschenkelsegments und dessen Schwerpunkt
  lambdaUS <- 0.4459 # Abstand proximaler Segmentpunkt - Schwerpunkt
  mOS <- Masse * rRelOS # Segmentmasse OS
  mUS <- Masse * rRelUS # Segmentmasse US
  thetaKurbel <- 0.002  # Trägheitsmoment der Fahrradkurbel [kg m^2]                                                 
  
  # df Berechnen
  df <- df %>%
    mutate(
           phi1 = ifelse(atan2(P1y, P1x) < 0, atan2(P1y, P1x) + 2 * pi, atan2(P1y, P1x)),
           Grad = phi1 * (180 / pi),
           delta_t = 1 / 100,
           delta_phi1 = corrected_delta_phi1(phi1),
           omega = delta_phi1 / delta_t,
           nD = omega / (2 * pi) * 60,
           nD_avg = mean(omega, na.rm = TRUE) / (2 * pi) * 60,
           T = 60 / nD,
           lOS = sqrt((P3x-P2x)^2+(P3y-P2y)^2),                                     # Gerade zwischen Hüfte und Knie
           lUS = sqrt((P2x-LAJC_X)^2+(P2y-LAJC_Y)^2),                               # Gerade zwischen Knie und Ankle
           lOS_avg = mean(lOS),
           lUS_avg = mean(lUS),
           thetaOS = (1/4) * mOS * (uOS / (2 * pi))^2 + (1/12) * mOS * lOS_avg^2,   # Trägheitsmoment des OS [kg m^2]
           thetaUS = (1/4) * mUS * (uUS / (2 * pi))^2 + (1/12) * mUS * lUS_avg^2,   # Trägheitsmoment des OS [kg m^2]
           SpOS_X = P3x - lambdaOS * (P3x-P2x),
           SpOS_Y  = P3y - lambdaOS * (P3y-P2y),
           SpUS_X  = P2x - lambdaOS * (P2x-LAJC_X),
           SpUS_Y  = P2y - lambdaOS * (P2y-LAJC_Y),
           d_SpOS = sqrt((lead(SpOS_X) - SpOS_X)^2 + (lead(SpOS_Y) - SpOS_Y)^2),    # Abstand zwischen aufeinanderfolgenden SpOS-Punkten
           d_SpUS = sqrt((lead(SpUS_X) - SpUS_X)^2 + (lead(SpUS_Y) - SpUS_Y)^2),    # Abstand zwischen aufeinanderfolgenden SpUS-Punkten
           v_SpOS = ifelse(is.na(d_SpOS), NA, d_SpOS / delta_t),                    # Geschwindigkeit von SpOS
           v_SpUS = ifelse(is.na(d_SpUS), NA, d_SpUS / delta_t),                    # Geschwindigkeit von SpOS
           phi2 = acos((P2x-P1x) / lUS),                                            # Winkeln zwischen x-Achse und Verbindung Pedale-Knie
           phi3 = acos((P3x-P2x) / lOS),                                            # Winkel zwischen OS und Gestell
           omega_SpOS = (lead(phi2) - phi2) / delta_t,
           omega_SpUS = (lead(phi3) - phi3) / delta_t,
           omega_Kurbel = (lead(phi2) - phi2) / delta_t,
           Ekin_rot = 0.5 * (thetaOS * omega_SpOS^2 + thetaUS * omega_SpUS^2 + thetaKurbel * omega_Kurbel^2),
           Ekin_trans = 0.5 * (mOS * v_SpOS^2 + mUS * v_SpUS^2),
           delta_Ekin_rot = lead(Ekin_rot) - Ekin_rot,
           delta_Ekin_trans = lead(Ekin_trans) - Ekin_trans,
           delta_Ekin_ges = delta_Ekin_rot + delta_Ekin_trans,
           PInt_Rechts = delta_Ekin_ges / delta_t
    ) %>%
    slice(1:(n() - 2)) %>%
    select(Frame, Grad, phi1, delta_phi1, omega, T, nD, nD_avg, Masse, everything())
  
  # Ausreißer
  # Erkennung und Behandlung von Ausreißern in PInt_Rechts
  Q1 <- quantile(df$PInt_Rechts, 0.25, na.rm = TRUE)
  Q3 <- quantile(df$PInt_Rechts, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  # Ausreißer sind Werte, die unter Q1 - 1.5*IQR oder über Q3 + 1.5*IQR liegen
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  
  # Ersetze Ausreißer mit NA
  df$PInt_Rechts <- ifelse(df$PInt_Rechts < lower_bound | df$PInt_Rechts > upper_bound, NA, df$PInt_Rechts)
  
  # Ersetzen der NA-Werte durch gleitende Mittelwerte
  # Für jeden NA-Wert berechne den Durchschnitt der zwei oberen und unteren gültigen Werte
  df$PInt_Rechts_imputed <- df$PInt_Rechts
  
  for (i in 1:length(df$PInt_Rechts_imputed)) {
    if (is.na(df$PInt_Rechts_imputed[i])) {
      # Finde die Indizes der nächsten drei gültigen Werte sowohl oberhalb als auch unterhalb des NA-Wertes
      valid_indices_above <- which(!is.na(df$PInt_Rechts_imputed[i:min(i+2, nrow(df))]))
      valid_indices_below <- which(!is.na(df$PInt_Rechts_imputed[max(i-2, 1):i]))
      
      # Berechne die Mittelwerte der gültigen Werte, falls vorhanden
      if (length(valid_indices_above) > 0 && length(valid_indices_below) > 0) {
        upper_mean <- mean(df$PInt_Rechts_imputed[i + valid_indices_above], na.rm = TRUE)
        lower_mean <- mean(df$PInt_Rechts_imputed[i - valid_indices_below], na.rm = TRUE)
        df$PInt_Rechts_imputed[i] <- mean(c(upper_mean, lower_mean), na.rm = TRUE)
      } else if (length(valid_indices_above) > 0) {
        df$PInt_Rechts_imputed[i] <- mean(df$PInt_Rechts_imputed[i + valid_indices_above], na.rm = TRUE)
      } else if (length(valid_indices_below) > 0) {
        df$PInt_Rechts_imputed[i] <- mean(df$PInt_Rechts_imputed[i - valid_indices_below], na.rm = TRUE)
      }
    }
  }
  # Übertragen der imputierten Werte zurück in die ursprüngliche Spalte
  df$PInt_Rechts <- df$PInt_Rechts_imputed
  # Löschen der Hilfsspalte
  df$PInt_Rechts_imputed <- NULL
  
  # Zyklusfindung
  ## Variablen
  Startwert_Grad <- df$Grad[1]
  Toleranz <- 3
  ## Endpunkte und Anzahl
  Ende_Zyklus_Indizes <- which(abs(df$Grad - Startwert_Grad) <= Toleranz)
  diff_Ende_Zyklus_Indizes <- c(diff(Ende_Zyklus_Indizes), Toleranz + 1)  # Hinzufügen eines hohen Werts am Ende für den letzten Index
  gefilterte_Indizes <- Ende_Zyklus_Indizes[diff_Ende_Zyklus_Indizes > 1] # Bereinigen der Indizes
  Anzahl_Zyklen <- length(gefilterte_Indizes)-1
  Werte_Indizes <- df$Grad[gefilterte_Indizes]
  Ende_Zyklen <- gefilterte_Indizes[length(gefilterte_Indizes)]
  df$Grad[Ende_Zyklen]
  
  # Beschränkung des DataFrames bis zum letzten gefundenen Zyklusende
  df <- df[1:Ende_Zyklen, ]
  
  # Berechnung der durchschnittlichen Zykluslänge
  Laenge_Zyklus <- round(length(df$Grad) / Anzahl_Zyklen, 0)
  
  # Einstellen der Verschiebung basierend auf Zykluslänge für Spaltenanpassungen
  verschieben <- round(Laenge_Zyklus * 0.5)
  
  # Initialisierung und Berechnung verschobener Werte für PInt_Links
  verschobene_Werte <- numeric(nrow(df))
  for (i in 1:nrow(df)) {
    index_in_PInt_Rechts <- ((i + verschieben - 1) %% nrow(df)) + 1
    verschobene_Werte[i] <- df$PInt_Rechts[index_in_PInt_Rechts]
  }
  
  # Zuweisung der verschobenen Werte und Anpassung negativer Werte
  df$PInt_Links <- verschobene_Werte
  df$PInt_Links_Positiv <- ifelse(df$PInt_Links < 0, 0, df$PInt_Links)
  
  # Definition der Breite des gleitenden Fensters für Glättung
  fensterbreite <- 15
  
  # Aktualisierung der Daten mit geglätteten Werten und Durchschnittsbildung
  df <- df %>%
    mutate(
      PInt_Rechts_Positiv = ifelse(PInt_Rechts < 0, 0, PInt_Rechts),
      PInt_Kinematik = mean(PInt_Rechts_Positiv, na.rm = TRUE) + mean(PInt_Links_Positiv, na.rm = TRUE),
      PInt_Rechts_smooth = rollmean(PInt_Rechts, fensterbreite, fill = NA, align = "right"),
      PInt_Rechts_Positiv_smooth = ifelse(PInt_Rechts_smooth < 0, 0, PInt_Rechts_smooth),
      PInt_Links_smooth = rollmean(PInt_Links, fensterbreite, fill = NA, align = "right"),
      PInt_Links_Positiv_smooth = ifelse(PInt_Links_smooth < 0, 0, PInt_Links_smooth)
    )
  
  # Speichere das bearbeitete DataFrame in PInt_Kinematik_list
  PInt_Kinematik_list[[name]] <- df
  
  # Berechne den Mittelwert von nD_avg
  mean_nD_avg <- mean(df$nD_avg, na.rm = TRUE)
  
  # Erstelle die Plotly-Plots und speichere sie in plotly_Pint_list
  plot1 <- plot_ly(df[1:(Laenge_Zyklus*1.5), ], x = ~Frame, y = ~PInt_Rechts_smooth, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(yaxis = list(title = "PInt-Positiv für einen Zyklus")) %>%
    layout(xaxis = list(title = "Frame"))
  
  plot2 <- plot_ly(df[1:(Laenge_Zyklus*4), ], x = ~Frame, y = ~PInt_Rechts_Positiv_smooth, type = "scatter", mode = "lines", name = "Rechts",line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_Positiv_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(yaxis = list(title = "PInt-Positiv für einen Zyklus")) %>%
    layout(xaxis = list(title = "Frame"))
  
  plot3 <- plot_ly(df, x = ~Frame, y = ~PInt_Rechts_Positiv_smooth, type = "scatter", mode = "lines", name = "Rechts", line = list(color = "#42BA97")) %>%
    add_trace(y = ~PInt_Links_Positiv_smooth, name = "Links", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "PInt-Positiv für alle Zyklen", range = c(0, 80), dtick = 10), 
           xaxis = list(title = "Frame", dtick = 200),
           annotations = list(
             list(x = 0.02, y = 0.95, xref = 'paper', yref = 'paper',
                  text = paste("nD_avg =", round(mean_nD_avg, 2)),
                  showarrow = FALSE,
                  font = list(
                    size = 12
                  ))))
  
  plot4 <- plot_ly(df, x = ~Grad, y = ifelse(df$PInt_Rechts_Positiv_smooth == 0, NA, df$PInt_Rechts_Positiv_smooth), type = "scatter", mode = "markers", name = "Rechts", marker = list(color = "#42BA97")) %>%
    add_trace(y = ifelse(df$PInt_Links_Positiv_smooth == 0, NA, df$PInt_Links_Positiv_smooth), name = "Links", mode = "markers", marker = list(color = "#F4737A")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "PInt-Positiv über alle Zyklen"), 
           xaxis = list(title = "Grad"))
  
  plot5 <- plot_ly(df, x = ~Frame, y = ~PInt_Links_Positiv_smooth, name = "Links", type = "scatter", mode = "lines", line = list(color = "#F4737A")) %>%
    add_trace(y = ~PInt_Kinematik, name = "PInt_Kinematik", mode = "lines", line = list(color = "lightgrey", dash = "dash")) %>%
    layout(title = paste('Test', name),
           margin = list(t = 40),
           yaxis = list(title = "PInt-Positiv für Links"), 
           xaxis = list(title = "Frame"))
  
  # Speichere die Plots
  plotly_Pint_list[[name]] <- list(plot1, plot2, plot3, plot4, plot5)
}

```

#### 2D-Simulationsmodelle anhand der Kinematik Daten

::: columns
::: {.column width="50%"}
![Sitzen](images/Modell_Kinematik_sitzen_full.html){width="640" height="720"}
:::

::: {.column width="50%"}
![Stehen](images/Modell_Kinematik_stehen_full.html){width="640" height="720"}
:::
:::

#### 2D-Simulationsmodelle anhand der Kinematik Daten für die Berechnung

::: columns
::: {.column width="50%"}
![Sitzen](images/Modell_Kinematik_sitzen.html){width="500" height="720"}
:::

::: {.column width="50%"}
![Stehen](images/Modell_Kinematik_stehen.html){width="500" height="720"}
:::
:::

## Quellenverzeichnis

::: {#refs}
:::
